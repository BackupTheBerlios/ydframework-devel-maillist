From ximian at mail.berlios.de  Mon Sep 10 18:24:15 2007
From: ximian at mail.berlios.de (ximian at mail.berlios.de)
Date: Mon, 10 Sep 2007 18:24:15 +0200
Subject: [ydf-devel] r2477 - YDFramework2.0/trunk/YDFramework2/YDClasses
Message-ID: <200709101624.l8AGOFu3013690@sheep.berlios.de>

Author: ximian
Date: 2007-09-10 18:23:31 +0200 (Mon, 10 Sep 2007)
New Revision: 2477

Modified:
   YDFramework2.0/trunk/YDFramework2/YDClasses/YDFileSystem.php
Log:
- FIX: YDFSFile::setContents was not returning any value

Modified: YDFramework2.0/trunk/YDFramework2/YDClasses/YDFileSystem.php
===================================================================
--- YDFramework2.0/trunk/YDFramework2/YDClasses/YDFileSystem.php	2007-08-20 09:16:55 UTC (rev 2476)
+++ YDFramework2.0/trunk/YDFramework2/YDClasses/YDFileSystem.php	2007-09-10 16:23:31 UTC (rev 2477)
@@ -1,1854 +1,1855 @@
-<?php
-
-    /*
-
-        Yellow Duck Framework version 2.1
-        (c) Copyright 2002-2007 Pieter Claerhout
-
-        This library is free software; you can redistribute it and/or
-        modify it under the terms of the GNU Lesser General Public
-        License as published by the Free Software Foundation; either
-        version 2.1 of the License, or (at your option) any later version.
-
-        This library is distributed in the hope that it will be useful,
-        but WITHOUT ANY WARRANTY; without even the implied warranty of
-        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
-        Lesser General Public License for more details.
-
-        You should have received a copy of the GNU Lesser General Public
-        License along with this library; if not, write to the Free Software
-        Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
-
-    */
-
-    /**
-     *  @addtogroup YDFramework Core
-     */
-
-    // Check if the framework is loaded
-    if ( ! defined( 'YD_FW_NAME' ) ) {
-        die( 'Yellow Duck Framework is not loaded.' );
-    }
-
-    // Includes
-    include_once( YD_DIR_HOME_CLS . '/YDUtil.php');
-    include_once( YD_DIR_HOME . '/3rdparty/bmp.php' );
-
-    // YDFSImage cropping specific constants
-    define( 'YD_FS_CROP_UNCHANGED', 1 );
-    define( 'YD_FS_CROP_ENLARGED',  2 );
-    define( 'YD_FS_CROP_BORDERED',  3 );
-
-    // Config when cropping smaller images
-    YDConfig::set( 'YD_FS_CROP', YD_FS_CROP_ENLARGED, false );
-
-    // The mime types mapping
-    $GLOBALS['YD_FS_MIME_MAPPING'] = array(
-        'ez' => 'application/andrew-inset',
-        'hqx' => 'application/mac-binhex40',
-        'cpt' => 'application/mac-compactpro',
-        'mathml' => 'application/mathml+xml',
-        'doc' => 'application/msword',
-        'oda' => 'application/oda',
-        'ogg' => 'application/ogg',
-        'pdf' => 'application/pdf',
-        'rdf' => 'application/rdf+xml',
-        'gram' => 'application/srgs',
-        'grxml' => 'application/srgs+xml',
-        'mif' => 'application/vnd.mif',
-        'xul' => 'application/vnd.mozilla.xul+xml',
-        'xls' => 'application/vnd.ms-excel',
-        'ppt' => 'application/vnd.ms-powerpoint',
-        'wbxml' => 'application/vnd.wap.wbxml',
-        'wmlc' => 'application/vnd.wap.wmlc',
-        'wmlsc' => 'application/vnd.wap.wmlscriptc',
-        'vxml' => 'application/voicexml+xml',
-        'bcpio' => 'application/x-bcpio',
-        'vcd' => 'application/x-cdlink',
-        'pgn' => 'application/x-chess-pgn',
-        'cpio' => 'application/x-cpio',
-        'csh' => 'application/x-csh',
-        'dvi' => 'application/x-dvi',
-        'spl' => 'application/x-futuresplash',
-        'gtar' => 'application/x-gtar',
-        'hdf' => 'application/x-hdf',
-        'js' => 'application/x-javascript',
-        'latex' => 'application/x-latex',
-        'sh' => 'application/x-sh',
-        'shar' => 'application/x-shar',
-        'swf' => 'application/x-shockwave-flash',
-        'sit' => 'application/x-stuffit',
-        'sv4cpio' => 'application/x-sv4cpio',
-        'sv4crc' => 'application/x-sv4crc',
-        'tar' => 'application/x-tar',
-        'tcl' => 'application/x-tcl',
-        'tex' => 'application/x-tex',
-        'man' => 'application/x-troff-man',
-        'me' => 'application/x-troff-me',
-        'ms' => 'application/x-troff-ms',
-        'ustar' => 'application/x-ustar',
-        'src' => 'application/x-wais-source',
-        'xslt' => 'application/xslt+xml',
-        'dtd' => 'application/xml-dtd',
-        'zip' => 'application/zip',
-        'm3u' => 'audio/x-mpegurl',
-        'rpm' => 'audio/x-pn-realaudio-plugin',
-        'ra' => 'audio/x-realaudio',
-        'wav' => 'audio/x-wav',
-        'pdb' => 'chemical/x-pdb',
-        'xyz' => 'chemical/x-xyz',
-        'bmp' => 'image/bmp',
-        'cgm' => 'image/cgm',
-        'gif' => 'image/gif',
-        'ief' => 'image/ief',
-        'png' => 'image/png',
-        'jpg' => 'image/jpeg',
-        'svg' => 'image/svg+xml',
-        'wbmp' => 'image/vnd.wap.wbmp',
-        'ras' => 'image/x-cmu-raster',
-        'ico' => 'image/x-icon',
-        'pnm' => 'image/x-portable-anymap',
-        'pbm' => 'image/x-portable-bitmap',
-        'pgm' => 'image/x-portable-graymap',
-        'ppm' => 'image/x-portable-pixmap',
-        'rgb' => 'image/x-rgb',
-        'xbm' => 'image/x-xbitmap',
-        'xpm' => 'image/x-xpixmap',
-        'xwd' => 'image/x-xwindowdump',
-        'css' => 'text/css',
-        'rtx' => 'text/richtext',
-        'rtf' => 'text/rtf',
-        'tsv' => 'text/tab-separated-values',
-        'wml' => 'text/vnd.wap.wml',
-        'wmls' => 'text/vnd.wap.wmlscript',
-        'etx' => 'text/x-setext',
-        'avi' => 'video/x-msvideo',
-        'movie' => 'video/x-sgi-movie',
-        'ice' => 'x-conference/x-cooltalk',
-        'php' => 'text/plain',
-    );
-
-    /**
-     *	This class houses all different path related functions.
-     *
-     *  @ingroup YDFramework
-     */
-    class YDPath extends YDBase {
-
-        /**
-         *	Provides a platform-specific character used to separate directory levels in a path string that reflects a
-         *	hierarchical file system organization.
-         *
-         *	@returns	String containing the directory separator
-         *
-         *	@static
-         */
-        function getDirectorySeparator() {
-            return ( YD_PATHDELIM == ':' ) ? '/' : '\\';
-        }
-
-        /**
-         *	A platform-specific separator character used to separate path strings in environment variables.
-         *
-         *	@returns	String containing the path separator
-         *
-         *	@static
-         */
-        function getPathSeparator() {
-            return YD_PATHDELIM;
-        }
-
-        /**
-         *	Provides a platform-specific volume separator character.
-         *
-         *	@returns	String containing the volume separator
-         *
-         *	@static
-         */
-        function getVolumeSeparator() {
-            if ( strtoupper( substr( PHP_OS, 0, 3 ) ) == 'WIN' || strtoupper( PHP_OS ) == 'DARWIN' ) {
-                return ':';
-            } else {
-                return '/';
-            }
-        }
-
-        /**
-         *	Changes the extension of a path string.
-         *
-         *	@param $path	Path of the file or directory.
-         *	@param $ext	The new extension.
-         *
-         *	@returns	String with the changed extension
-         *
-         *	@static
-         */
-        function changeExtension( $path, $ext ) {
-            if ( ! empty( $ext ) && substr( $ext, 0, 1 ) != '.' ) {
-                $ext = '.' . $ext;
-            }
-            return YDPath::getFilePathWithoutExtension( $path ) . $ext;
-        }
-
-        /**
-         *	@param $path	Path of the file or directory.
-         *
-         *	@returns	The directory information for the specified path string
-         *
-         *	@static
-         */
-        function getDirectoryName( $path ) {
-            return dirname( $path );
-        }
-
-        /**
-         *	@param $path	Path of the file or directory.
-         *
-         *	@param $format	(Optional) Boolean that defines if free space should be returned as bytes or formated
-         *
-         *	@param $decimals (Optional) Decimals to use when free space is formated
-         *
-         *	@returns	The number of bytes available on the specified path
-         *
-         *	@static
-         */
-        function getFreeSpace( $path, $format = false, $decimals = 1 ) {
-
-            // get free disk space on the path
-            $space = disk_free_space( $path );
-
-            // return number of bytes if we don't want to format
-            if ( $format == false ) return $space;
-
-            // include util lib
-            YDInclude( 'YDUtil.php' );
-
-            // return formated string
-            return YDStringUtil::formatFilesize( $space, $decimals );
-        }
-
-        /**
-         *	@param $path	Path of the file or directory.
-         *
-         *	@returns	The extension of the specified path string
-         *
-         *	@static
-         */
-        function getExtension( $path ) {
-            if ( strrchr( $path, '.' ) ) {
-                return substr( strrchr( $path, '.' ), 1 );
-            } else {
-                return '';
-            }
-        }
-
-        /**
-         *	@param $path	Path of the file or directory.
-         *
-         *	@returns	The file name and extension of the specified path string
-         *
-         *	@static
-         */
-        function getFileName( $path ) {
-            return basename( $path );
-        }
-
-        /**
-         *	@param $path	Path of the file or directory.
-         *
-         *	@returns	The file name of the specified path string without the extension
-         *
-         *	@static
-         */
-        function getFileNameWithoutExtension( $path ) {
-            return basename( $path, '.' . YDPath::getExtension( $path ) );
-        }
-
-        /**
-         *	@param $path	Path of the file or directory.
-         *
-         *	@returns	The file path and extension of the specified path string
-         *
-         *	@static
-         */
-        function getFilePath( $path ) {
-            return realpath( $path );
-        }
-
-        /**
-         *	@param $path	Path of the file or directory.
-         *
-         *	@returns	The file path of the specified path string without the extension
-         *
-         *	@static
-         */
-        function getFilePathWithoutExtension( $path ) {
-            return YDPath::getDirectoryName( $path ) . YDPath::getDirectorySeparator() . YDPath::getFileNameWithoutExtension( $path );
-        }
-
-        /**
-         *	@param $path	Path of the file or directory.
-         *
-         *	@returns	The absolute path for the specified path string
-         *
-         *	@static
-         */
-        function getFullPath( $path ) {
-            return realpath( $path );
-        }
-
-        /**
-         *	@returns	A uniquely named temporary file on disk and returns the full path to that file
-         *
-         *	@static
-         */
-        function getTempFileName() {
-            $tmpName = '';
-            for ($i=0;$i<rand(0,50);$i++) {
-                $tmpName .= "&#" . rand(33,255) . ";";
-            }
-            return YDPath::getTempPath() . YDPath::getDirectorySeparator() . md5( $tmpName ) . '.temp';
-        }
-
-        /**
-         *	@returns	The path of the current system's temporary folder.
-         *
-         *	@static
-         */
-        function getTempPath() {
-            return YD_DIR_TEMP;
-        }
-
-        /**
-         *	@param $path	Path of the file or directory.
-         *
-         *	@returns	Determines whether a path includes a file name extension
-         *
-         *	@static
-         */
-        function hasExtension( $path ) {
-            $ext = YDPath::getExtension( $path );
-            return empty( $ext ) ? false : true;
-        }
-
-        /**
-         *	This function will check if the path is an absolute path or not.
-         *
-         *	@param	$path	The path to check
-         *
-         *	@returns	Boolean indicating if the path is absolute or not.
-         *
-         *	@static
-         */
-        function isAbsolute( $path ) {
-            if ( strtoupper( substr( PHP_OS, 0, 3 ) ) == 'WIN' ) {
-                if ( strlen( $path ) > 3 && substr( $path, 1, 2 ) == ':\\' ) {
-                    return true;
-                } else {
-                    return false;
-                }
-            } else {
-                return ( substr( $path, 0, 1 ) == '/' );
-            }
-        }
-
-        /**
-         *	This function combines different file path elements to each other.
-         *
-         *	@code
-         *	join( 'C:\temp', 'subdir', 'file.html' )
-         *	@endcode
-         *
-         *	results in the following path:
-         *
-         *	@code
-         *	C:\temp\subdir\file.html
-         *	@endcode
-         *
-         *	@returns	The joined path.
-         *
-         *	@static
-         */
-        function join() {
-
-            // Get the arguments for this function
-            $args = func_get_args();
-
-            // Start with an empty path
-            $path = '';
-
-            // Loop over the different elements
-            foreach ( $args as $arg ) {
-
-                if ( ! strlen( $arg ) ) {
-                    continue;
-                }
-
-                // Normalize the path elements
-                $arg = str_replace( '/', YDPath::getDirectorySeparator(), $arg );
-                $arg = str_replace( '\\', YDPath::getDirectorySeparator(), $arg );
-
-                // Check for an absolute path
-                if ( YDPath::isAbsolute( $arg ) ) {
-                    $path = $arg;
-                } else {
-
-                    // Remove the trailing directory separator
-                    if ( substr( $arg, -1, 1 ) == YDPath::getDirectorySeparator() ) {
-                        $arg = substr( $arg, 0, -1 );
-                    }
-
-                    // Add it to the path
-                    if ( strlen( $path ) > 0 ) {
-                        if ( substr( $arg, 0, 1 ) != YDPath::getDirectorySeparator() ) {
-                            $path .= YDPath::getDirectorySeparator() . $arg;
-                        } else {
-                            $path .= $arg;
-                        }
-                    } else {
-                        $path .= $arg;
-                    }
-
-                }
-
-            }
-
-            // Return the joined path
-            return $path;
-
-        }
-
-        /**
-         *	Function to determine if the file is an image or not. This function will read the header of the file to
-         *	find out if it's an image or not.
-         *
-         *	@returns	Boolean indicating if the file is an image or not.
-         */
-        function isImage( $path ) {
-
-            // Return false if path doesn't exist
-            if ( ! realpath( $path ) ) {
-                return false;
-            }
-
-            // Check if we have an extension
-            $extension = strtolower( YDPath::getExtension( $path ) );
-            if ( $extension && $extension != 'tmn' ) {
-                if ( in_array( $extension, array( 'jpg', 'png', 'gif', 'jpeg' ) ) ) {
-                    return $extension;
-                }
-            }
-
-            // No extension, read the file
-            $fp = fopen( $path, 'rb' );
-            $header = fread( $fp, 8 );
-            fclose( $fp );
-            if ( substr( $header, 0, 6 ) == 'GIF87a' || substr( $header, 0, 6 ) == 'GIF89a' ) {
-                return 'gif';
-            }
-            if ( substr( $header, 6, 4 ) == 'JFIF' ) {
-                return 'jpeg';
-            }
-            if ( substr( $header, 0, 8 ) == "\211PNG\r\n\032\n" ) {
-                return 'png';
-            }
-            if ( substr( $header, 0, 2 ) == "BM" ) {
-                return 'bmp';
-            }
-
-            // Not an image
-            return false;
-
-        }
-
-    }
-
-    /**
-     *  This class defines a filesystem file.
-     *
-     *  @ingroup YDFramework
-     */
-    class YDFSFile extends YDBase {
-
-        /**
-         *  The class constructor of the YDFSFile class takes the path to the file as it's first argument.
-         *  It will then provide you with a number of functions to get the properties of the file.
-         *
-         *  @param $path    Path of the file.
-         *  @param $create  (optional) Force the creation of the file if it doesn't exist. Default: false.
-         */
-        function YDFSFile( $path, $create=false ) {
-
-            // Initialize YDBase
-            $this->YDBase();
-
-            // Check if the path if the file exists
-            if ( ! is_file( $path ) ) {
-
-                // Check if the file should be created
-                if ( $create ) {
-
-                    // Create a new YDFSDirectory object
-                    $dir = new YDFSDirectory( dirname( $path ) );
-
-                    // Create the file
-                    $dir->createFile( basename( $path ), ' ' );
-
-                } else {
-                    trigger_error( 'The file with path "' . $path . '" does not exist.', YD_ERROR );
-                }
-            }
-
-            // Save the path
-            $this->_path = realpath( $path );
-
-        }
-
-        /**
-         *	Function to get the filename of the object. This does not include the path information.
-         *
-         *	@returns	String containing the name of the object.
-         */
-        function getBasename() {
-            return YDPath::getFileName( $this->getAbsolutePath() );
-        }
-
-        /**
-         *	Function to get the filename of the object without the extension. This does not include the path information.
-         *
-         *	@returns	String containing the name of the object.
-         */
-        function getBasenameNoExt() {
-            return substr( YDPath::getFilePathWithoutExtension( $this->getBasename() ), 2 );
-        }
-
-        /**
-         *	Function to get the extension of the file.
-         *
-         *	@returns	String containing the extension of the file.
-         */
-        function getExtension() {
-            return YDPath::getExtension( $this->getAbsolutePath() );
-        }
-
-        /**
-         *	Function to get the full path of the object.
-         *
-         *	@returns	String containing the full path of the object.
-         */
-        function getPath() {
-            return YDPath::getDirectoryName( $this->getAbsolutePath() );
-        }
-
-        /**
-         *	Function to get the full absolute path of the object.
-         *
-         *	@returns	String containing the full absolute path of the object.
-         */
-        function getAbsolutePath() {
-            return YDPath::getFullPath( $this->_path );
-        }
-
-        /**
-         *	Function to get the last modification date of the object.
-         *
-         *  @param  $format (optional) The date format to use to format the date.
-         *  @param  $locale (optional) The locale to use for formatting the date.
-         *
-         *	@returns	String containing the last modification date of the object.
-         */
-        function getLastModified( $format = 'timestamp', $locale=null ) {
-            if ( $format == 'timestamp' ) {
-                return filemtime( $this->getAbsolutePath() );
-            }
-            return YDStringUtil::formatDate( filemtime( $this->getAbsolutePath() ), $format, $locale );
-        }
-
-        /**
-         *	Function to get the size of the file.
-         *
-         *  @param  $formatted  (optional) If set to true, the filesize will be returned in a human readable format.
-         *  @param  $decimals   (optional) The number of decimals to use for formatting the filesize.
-         *
-         *	@returns	Double containing the length of the file.
-         */
-        function getSize( $formatted = false, $decimals = 1 ) {
-            if ( ! $formatted ) {
-                return filesize( $this->getAbsolutePath() );
-            }
-            return YDStringUtil::formatFilesize( filesize( $this->getAbsolutePath() ), $decimals );
-        }
-
-        /**
-         *  Returns the total free space on the partition where this file lives
-         *
-         *	@param $format	 (Optional) Boolean that defines if free space should be returned as bytes or formated
-         *	@param $decimals (Optional) Decimals to use when free space is formated
-         *
-         *	@returns	The number of bytes available
-         *
-         *	@static
-         */
-        function getFreeSpace( $format = false, $decimals = 1 ) {
-            return YDPath::getFreeSpace( $this->_path, $format, $decimals );
-        }
-
-        /**
-         *	Function to get the contents of the file. Depending on the file contents, this will be returned as binary or
-         *	textual data.
-         *
-         *	@param $start	(optional) Byte to start reading from.
-         *	@param $length	(optional) Number of bytes to read.
-         *
-         *	@returns	String containing the contents of the file.
-         */
-        function getContents( $start=null, $length=null ) {
-
-            // Clear the stat cache
-            clearstatcache();
-
-            // Check the start byte
-            if ( $start == null ) {
-                $start = 0;
-            }
-
-            // No length given
-            if ( $length == null ) {
-                $length = filesize( $this->getAbsolutePath() ) - $start;
-            }
-
-            // Check that length is a positive integer
-            if ( $length < 1 ) {
-                trigger_error( 'getContents: Length should be a positive integer.', YD_ERROR );
-            }
-
-            // Variable to hold the return data
-            $result = '';
-
-            // Open the file in read binary mode
-            $file = fopen( $this->getAbsolutePath(), 'rb' );
-
-            // Check if we were able to open the file
-            if ( $file == false ) {
-                trigger_error( 'The file with path "' . $path . '" could not be read.', YD_ERROR );
-            }
-
-            // Find the start position
-            fseek( $file, $start );
-
-            // Get the contents of the file
-            $result = fread( $file, $length );
-
-            // Close the file handle
-            fclose( $file );
-
-            // Return the result
-            return $result;
-
-        }
-
-        /**
-         *	This function will create a new file in the current directory, and will write the specified contents to the
-         *	file. Once finished, it will return a new YDFSFile object pointing to the file. All directory paths are
-         *	relative to the current directory.
-         *
-         *	@param $contents	The contents of the new file.
-         *	@param $append		Boolean indicating if the content should be appended to the file or if the file contents
-         *						should be replaced.
-         */
-        function setContents( $contents, $append=false ) {
-
-            // Set the mode
-            $mode = ( $append === true ) ? 'ab' : 'wb';
-
-            // Open the file
-            $fp = fopen( $this->getAbsolutePath(), $mode );
-
-            // Save the contents to the file
-            $result = fwrite( $fp, $contents );
-
-            // Check for errors
-            if ( $result == false ) {
-                trigger_error(
-                    'Failed writing to the file "' . $this->getAbsolutePath() . '" in the directory called "' . $this->getPath() . '".',
-                    YD_ERROR
-                );
-            }
-
-            // Close the file
-            fclose( $fp );
-
-            // Clear the stat cache
-            clearstatcache();
-
-        }
-
-        /**
-         *	Function to determine if the file is an image or not. This function will read the header of the file to
-         *	find out if it's an image or not.
-         *
-         *	@returns	Boolean indicating if the file is an image or not.
-         */
-        function isImage() {
-            return YDPath::isImage( $this->getAbsolutePath() );
-        }
-
-        /**
-         *  This function returns true if the file is readable.
-         *
-         *  @returns    Returns true if the file is readable.
-         */
-        function isReadable(){
-            return is_readable( $this->getAbsolutePath() );
-        }
-
-        /**
-         *	This function will return true if the directory is writeable, otherwise, it will return false.
-         *
-         *	@remarks
-         *		This only works correctly on Unix based systems.
-         *
-         *	@returns	Boolean indicating if the directory is writeable or not.
-         */
-        function isWriteable() {
-            return is_writable( $this->getAbsolutePath() );
-        }
-
-        /**
-         *	This function will force the browser to download the file.
-         *
-         *	@param $name	(optional) The name of the file download should show in the browser. By default, this is the
-         *					same as the filename.
-         *  @param $inline  (optional) If set to true, the download is inline, otherwise, a download will be forced by
-         *                  the browser. Default is false.
-         */
-        function download( $name=null, $inline=false ) {
-
-            // Get the name of the file
-            if ( is_null( $name ) ) {
-                $name = $this->getBasename();
-            }
-
-            // Force download or do inline
-            if ( ! $inline ) {
-                header( 'Content-Type: application/force-download; name="' . $name . '"');
-                header( 'Content-Disposition: attachment; filename="' . $name . ' "');
-            } else {
-                header( 'Content-Type: ' . $this->getMimeType() );
-                header( 'Content-Disposition: inline; filename="' . $name . ' "');
-            }
-
-            // Add the rest of the headers
-            header( 'Cache-Control: public' );
-            header( 'Content-Transfer-Encoding: binary' );
-            header( 'Content-length: ' . $this->getSize() );
-
-            // Send the file contents
-            readfile( $this->getAbsolutePath() );
-
-            // Stop the execution
-            die();
-
-        }
-
-        /**
-         *	This function will delete a file from the current directory.
-         *
-         *	@param $failOnError	(optional) Indicate if a fatal error needs to be raised if deleting the file failed.
-         *
-         *	@return	There are three possible return values for this function. True indicates that the file exists and
-         *			is deleted successfully. False indicates the file exists but could not be deleted. Null indicates
-         *			the file didn't exist and therefor could not be deleted.
-         */
-        function delete( $failOnError=false ) {
-
-            // Set the filename
-            $filename = $this->getAbsolutePath();
-
-            // Set the directory of this object as the working directory
-            chdir( $this->getPath() );
-
-            // Check if the file exists
-            if ( file_exists( $filename ) ) {
-
-                // Try to delete the file
-                $result = unlink( $filename );
-
-                // Check for errors
-                if ( $result == false ) {
-
-                    // Check if we need to raise an error
-                    if ( $failOnError == true ) {
-                        trigger_error(
-                            'Failed deleting the file "' . $filename . '" from the directory "' . $this->getPath() . '".',
-                            YD_ERROR
-                        );
-                    }
-
-                }
-
-                // Return if the file was deleted or not
-                return $result;
-
-            }
-
-            // Return null if the file doesn't exist
-            return null;
-
-        }
-
-        /**
-         *  This function will rename the file to the specified file path.
-         *
-         *  @param  $new_path   The new path of the file.
-         *
-         *  @returns    True on success, false on failure.
-         */
-        function rename( $new_path ) {
-            @unlink( $new_path );
-            $result = rename( $this->getAbsolutePath(), $new_path );
-            if ( $result === true ) {
-                $this->_path = realpath( $new_path );
-            }
-            return $result;
-        }
-
-        /**
-         *	This function will return true if the filesystem object is a directory. In all other cases, it will return
-         *	false.
-         *
-         *	@returns	Boolean indicating if the object is a directory or not.
-         */
-        function isDirectory() {
-            return false;
-        }
-
-        /**
-         *  This function returns the mime type for the file object.
-         *
-         *  @returns    The mime type for the document. If the mime type is not known, it will use the
-         *              application/octet-stream mime type.
-         */
-        function getMimeType() {
-            $extension = strtolower( $this->getExtension() );
-            if ( isset( $GLOBALS['YD_FS_MIME_MAPPING'][$extension] ) ) {
-                return $GLOBALS['YD_FS_MIME_MAPPING'][$extension];
-            } else {
-                return 'application/octet-stream';
-            }
-        }
-
-        /**
-         *	@internal
-         */
-        function _getImageType() {
-            return YDPath::isImage( $this->getAbsolutePath() );
-        }
-
-        /**
-         *	This function will move the file to the specified path and update the object accordingly.
-         *
-         *	@param	$path	Target path.
-         *
-         *	@returns	False on a failure, true on success.
-         */
-        function move( $path ) {
-            $result = rename( $this->getAbsolutePath(), $path );
-            if ( $result ) {
-                $this->_path = realpath( $path );
-            }
-            return $result;
-        }
-
-    }
-
-    /**
-     *	This class defines an image file.
-     *
-     *  @ingroup YDFramework
-     */
-    class YDFSImage extends YDFSFile {
-
-        /**
-         *	The class constructor of the YDImage class takes the path to the image as it's only argument. It will then
-         *	provide you with a number of functions to get the properties of the image and also provides some actions
-         *	like generating thumbnails.
-         *
-         *	@param $path	Path of the image.
-         *  @param $create  (optional) Force the creation of the file if it doesn't exist. Default: false.
-         */
-        function YDFSImage( $path, $create=false ) {
-
-            // Initialize the parent
-            $this->YDFSFile( $path, $create );
-
-            // Get the image size
-            $this->image_size = null;
-
-        }
-
-        /**
-         *  Function determine the image size. This is just a helper function for the other ones.
-         *
-         *  @internal
-         */
-        function _initImageSize() {
-
-            // Check for the getimagesize function
-            if ( ! function_exists( 'getimagesize' ) ) {
-                trigger_error(
-                    'The "getimagesize" function does not exists. Make sure that the GD libraries are loaded before '
-                    . 'using the YDFSImage::getImageSize function.', YD_ERROR
-                );
-            }
-
-            if ( is_null( $this->image_size ) ) {
-                $this->image_size = getimagesize( $this->getAbsolutePath() );
-            }
-       }
-
-        /**
-         *	Function to output the thumbnail of an image. The function directly outputs the thumbnail to the client
-         *	including the right headers needed to display the image.
-         *
-         *	This function can cache the thumbnails and regenerate them on the fly if needed. The cached thumbnails are
-         *	stored in the temp directory of the Yellow Duck framework and have the extension "tmn". You can delete these
-         *	automatically as they will be recreated on the fly if needed.
-         *
-         *	@param $width	The maximum width of the thumbnail.
-         *	@param $height	The maximum height of the thumbnail.
-         *	@param $cache	(optional) Indicate if the thumbnail should be cached. By default, caching is turned on.
-         *	@param $crop	(optional) Indicate if the thumbnail should be cropped to the exact size. By default, false.
-         */
-        function outputThumbnail( $width, $height, $cache=true, $crop=false ) {
-
-            // Output right headers
-            $content_type = $this->getMimeType();
-            header( 'Content-type: ' . $content_type );
-
-            // Output the thumbnail
-            die( $this->_createThumbnail( $width, $height, $cache, $crop ) );
-
-        }
-
-        /**
-         *	This function will create a thumbnail and save the thumbnail to disk.
-         *
-         *	@param $width	The maximum width of the thumbnail.
-         *	@param $height	The maximum height of the thumbnail.
-         *	@param $file	The filename to save the thumbnail to.
-         *	@param $crop	(optional) Indicate if the thumbnail should be cropped to the exact size. By default, false.
-         *
-         *  @returns    A new YDFSImage object for the thumbnail.
-         */
-        function saveThumbnail( $width, $height, $file, $crop=false ) {
-
-            // Create the thumbnail
-            $thumb = $this->_createThumbnail( $width, $height, false, $crop );
-
-            // Save it to a file
-            $f = new YDFSImage( $file, true );
-            $f->setContents( $thumb );
-
-            // Return the thumbnail
-            return $f;
-
-        }
-
-        /**
-         *	This function will return the size of the image in pixels.
-         *
-         *	@returns	The imagesize in pixels. This is returned as an array of which the first element is the width,
-         *				the second element is the height in pixels.
-         */
-        function getImageSize() {
-
-            // Init image_size
-            $this->_initImageSize();
-
-            // Get the first two elements
-            $imgSize = array_slice( $this->image_size, 0, 2 );
-
-            // Return the image size
-            return $imgSize;
-
-        }
-
-        /**
-         *	This function will return the width of the image in pixels.
-         *
-         *	@returns	The width in pixels.
-         */
-        function getWidth() {
-            $this->_initImageSize();
-            return $this->image_size[0];
-        }
-
-        /**
-         *	This function will return the height of the image in pixels.
-         *
-         *	@returns	The height in pixels.
-         */
-        function getHeight() {
-            $this->_initImageSize();
-            return $this->image_size[1];
-        }
-
-        /**
-         *	Function that returns the type of the image. Currently, it supports GIF, JPG and PNG.
-         *
-         *	@returns	The type of the image, which is either jpg, png or gif.
-         */
-        function getImageType() {
-
-            // Get the image type
-            $type = $this->_getImageType();
-
-            // Raise error about unsupported image type
-            if ( $type === false ) {
-                trigger_error(
-                    'The getImageType function does not support the file format of the file "'
-                    . $this->getAbsolutePath() . '".', YD_ERROR
-                );
-            } else {
-                return $type;
-            }
-
-         }
-
-        /**
-         *	This function is used to output an error image.
-         *
-         *	@param $name	(optional) Name of the error image. Default image that is shown is the generic
-         *					"YD_ydfsimage_fatal_error".
-         *
-         *	@internal
-         */
-        function _error( $name='YD_ydfsimage_fatal_error' ) {
-            $img = new YDFSImage( YD_DIR_HOME . '/images/' . $name . '.gif' );
-            header( 'Content-type: ' . $img->getMimeType() );
-            echo( $img->getContents() );
-            die();
-        }
-
-        /**
-         *	This function will do the actual work of creating a thumbnail image.
-         *
-         *	@param $width	The maximum width of the thumbnail.
-         *	@param $height	The maximum height of the thumbnail.
-         *	@param $cache	(optional) Indicate if the thumbnails should be cached. By default, caching is turned off.
-         *	@param $crop	(optional) Indicate if the thumbnails should be cropped to the exact size. By default, false.
-         *
-         *	@internal
-         */
-        function & _createThumbnail( $width, $height, $cache=true, $crop=false ) {
-
-            // Check if the GD library is loaded.
-            if ( ! extension_loaded( 'gd' ) ) {
-                $this->_error( 'YD_gd_not_installed' );
-            }
-
-            // Width and height should be positive integer
-            if ( $width < 1 || $height < 1 ) {
-                $this->_error();
-            }
-
-            // Get the cache filename
-            $cacheFName = YD_DIR_TEMP . '/' . $this->_createThumbnailName( $width, $height, $crop );
-
-            // Check if caching is enabled
-            if ( $cache === true ) {
-
-                // Output the cached version if any
-                if ( is_file( $cacheFName ) ) {
-                    readfile( $cacheFName );
-                    die();
-                }
-
-            }
-
-            // Check the extension
-            $img_type = $this->isImage();
-
-            // Open the source image
-            if ( $img_type == 'gif' ) {
-                if ( ! function_exists( 'imagecreatefromgif' ) ) {
-                    $this->_error();
-                }
-                $src_img = imagecreatefromgif( $this->getAbsolutePath() );
-            } elseif ( $img_type == 'png' ) {
-                $src_img = imagecreatefrompng( $this->getAbsolutePath() );
-            } elseif ( $img_type == 'bmp' ) {
-                $src_img = imagecreatefrombmp( $this->getAbsolutePath() );
-            } else {
-                $src_img = imagecreatefromjpeg( $this->getAbsolutePath() );
-            }
-
-            // Get the current image size
-            $ori_width  = imageSX( $src_img );
-            $ori_height = imageSY( $src_img );
-
-            // Calculate the new image size
-            if ( $crop ) {
-
-                if ( $ori_width > $ori_height ) {
-                    $thumb_w = ceil( $ori_width * ( $height / $ori_height ) );
-                    $thumb_h = $height;
-                }
-                if ( $ori_width < $ori_height ) {
-                    $thumb_w = $width;
-                    $thumb_h = ceil( $ori_height * ( $width / $ori_width ) );
-                }
-
-            } else {
-
-                if ( $ori_width > $ori_height ) {
-                    $thumb_w = $width;
-                    $thumb_h = ceil( $ori_height * ( $width / $ori_width ) );
-                }
-                if ( $ori_width < $ori_height ) {
-                    $thumb_w = ceil( $ori_width * ( $height / $ori_height ) );
-                    $thumb_h = $height;
-                }
-
-            }
-
-            if ( $ori_width == $ori_height ) {
-                $thumb_w = $width;
-                $thumb_h = $height;
-            }
-
-            if ( ( $width >= $ori_width || $height >= $ori_height ) && ( ! $crop || ( $crop && YDConfig::get( 'YD_FS_CROP' ) != YD_FS_CROP_ENLARGED ) ) ) {
-
-                if ( $width >= $ori_width && $height < $ori_height ) {
-                    $thumb_w = ceil( $ori_width * ( $height / $ori_height ) );
-                    $thumb_h = $height;
-                } else if ( $width < $ori_width && $height >= $ori_height ) {
-                    $thumb_w = $width;
-                    $thumb_h = ceil( $ori_height * ( $width / $ori_width ) );
-                } else {
-                    $thumb_w = $ori_width;
-                    $thumb_h = $ori_height;
-                }
-
-            }
-
-            // Resample the image
-            $dst_img = imagecreatetruecolor( $thumb_w, $thumb_h );
-            if ( $img_type == 'png' ) {
-                imagecopyresized( $dst_img, $src_img, 0, 0, 0, 0, $thumb_w, $thumb_h, $ori_width, $ori_height );
-            } else {
-                imagecopyresampled( $dst_img, $src_img, 0, 0, 0, 0, $thumb_w, $thumb_h, $ori_width, $ori_height );
-            }
-
-            if ( $crop && ( $width != $thumb_w || $height != $thumb_h ) ) {
-
-                $x = ceil( abs( $thumb_w-$width  ) / 2 );
-                $y = ceil( abs( $thumb_h-$height ) / 2 );
-
-                $default = true;
-
-                if ( $ori_width < $width || $ori_height < $height ) {
-
-                    switch ( YDConfig::get( 'YD_FS_CROP', YD_FS_CROP_ENLARGED ) ) {
-
-                        case YD_FS_CROP_UNCHANGED:
-
-                            if ( $ori_width < $width && $ori_height < $height ) {
-                                $crp_img = $dst_img;
-                                $default = false;
-                            } else if ( $ori_width < $width ) {
-                                $x = 0;
-                                $width = $ori_width;
-                            } else if ( $ori_height < $height ) {
-                                $y = 0;
-                                $height = $ori_height;
-                            }
-                            break;
-
-                        case YD_FS_CROP_ENLARGED:
-                        case YD_FS_CROP_BORDERED:
-                            break;
-
-                    }
-
-                }
-
-                if ( $default ) {
-
-                    $crp_img = imagecreatetruecolor( $width, $height );
-
-                    if ( $img_type == 'png' ) {
-                        imagecopyresized( $crp_img, $dst_img, 0, 0, $x, $y, $width, $height, $width, $height );
-                    } else {
-                        imagecopyresampled( $crp_img, $dst_img, 0, 0, $x, $y, $width, $height, $width, $height );
-                    }
-
-                }
-
-                $dst_img = $crp_img;
-
-            }
-
-            // Get the resulting image
-            ob_start();
-            if ( $img_type == 'gif' ) {
-                if ( ! function_exists( 'imagegif' ) ) {
-                    imagepng( $dst_img );
-                } else {
-                    imagegif( $dst_img );
-                }
-            } elseif ( $img_type == 'png' ) {
-                imagepng( $dst_img );
-            } else {
-                imagejpeg( $dst_img );
-            }
-            $image_data = ob_get_contents();
-            ob_end_clean();
-
-            // Destroy the images
-            imagedestroy( $dst_img );
-            imagedestroy( $src_img );
-
-            // Save the cache if needed
-            if ( $cache == true ) {
-                $f = new YDFSFile( $cacheFName, true );
-                $f->setContents( $image_data );
-            }
-
-            // Return the image data
-            return $image_data;
-
-        }
-
-        /**
-         *  This function creates the cache name for thumbnails.
-         *
-         *	@param $width	The maximum width of the thumbnail.
-         *	@param $height	The maximum height of the thumbnail.
-         *	@param $crop	Indicate if is the cropped version.
-         */
-        function _createThumbnailName( $width, $height, $crop ) {
-            $cacheFName = $this->getAbsolutePath() . '/' . $width . '/' . $height . '/' . strval( $crop ) . $this->getLastModified();
-            $cacheFName = YD_TMP_PRE . 'N_' . md5( $cacheFName ) . '.' . strtolower( $this->getExtension() );
-            return $cacheFName;
-        }
-
-    }
-
-    /**
-     *  This class defines a filesystem directory.
-     *
-     *  @ingroup YDFramework
-     */
-    class YDFSDirectory extends YDBase {
-
-        /**
-         *	This is the class constructor of the YDDirectory class.
-         *
-         *	@param $path	(optional) Path of the directory. Default is the current directory.
-         */
-        function YDFSDirectory( $path='.' ) {
-
-            // Initialize YDBase
-            $this->YDBase();
-
-            // Fail if directory
-            if ( ! is_dir( $path ) ) {
-                trigger_error( 'The directory with path "' . $path . '" does not exist.', YD_ERROR );
-            }
-
-            // Save the path
-            $this->_path = realpath( $path );
-
-        }
-
-        /**
-         *	Function to get the basename of the directory. This does not include the path information.
-         *
-         *	@returns	String containing the name of the object.
-         */
-        function getBasename() {
-            return YDPath::getFileName( $this->getAbsolutePath() );
-        }
-
-        /**
-         *	Function to get the full absolute path of the object.
-         *
-         *	@returns	String containing the full absolute path of the object.
-         */
-        function getAbsolutePath() {
-            return $this->getPath();
-        }
-
-        /**
-         *  This function return the number of files that are in the directory.
-         *
-         *  @returns    The number of files in the directory.
-         */
-        function getFileCount(){
-            $total = 0;
-            $dirHandle = opendir( $this->getPath() );
-            while ( false !== ( $file = readdir( $dirHandle ) ) ) {
-                if ( $file != '.' && $file != '..' && is_file( $this->getPath() .'/'. $file ) ) {
-                   $total++;
-                }
-            }
-            closedir( $dirHandle );
-            return $total;
-        }
-
-        /**
-         *  This function return the number of directories that are in the directory.
-         *
-         *  @returns    The number of directories in the directory.
-         */
-        function getDirectoryCount(){
-            $total = 0;
-            $dirHandle = opendir( $this->getPath() );
-            while ( false !== ( $file = readdir( $dirHandle ) ) ) {
-            if ( $file != '.' && $file != '..' && is_dir( $this->getPath() .'/'. $file ) ) {
-                    $total++;
-                }
-            }
-            closedir( $dirHandle );
-            return $total;
-        }
-
-        /**
-         *  Returns the total size of the directory.
-         *
-         *  @param  $recursive  (optional) Recurse into the subdirectories. Default is false.
-         *  @param  $formatted  (optional) If set to true, the filesize will be returned in a human readable format.
-         *  @param  $decimals   (optional) The number of decimals to use for formatting the filesize.
-         *
-         *  @returns    The total size of the directory.
-         */
-        function getSize( $recursive = false, $formatted = false, $decimals = 1 ) {
-            $total = 0;
-            $dirHandle = opendir( $this->getPath() );
-            while ( false !== ( $file = readdir( $dirHandle ) ) ) {
-                if ( $file == '.' || $file == '..') {
-                    continue;
-                }
-                if ( is_file( $this->getPath() .'/'. $file ) ) {
-                    $total += filesize( $this->getPath() .'/'. $file );
-                } else if ( $recursive && is_dir( $this->getPath() .'/'. $file ) ) {
-                    $subdir = new YDFSDirectory( $this->getPath() .'/'. $file );
-                    $total += $subdir->getSize(true, false, $decimals);
-                }
-            }
-            closedir( $dirHandle );
-            if ( ! $formatted ) {
-                return $total;
-            }
-            return YDStringUtil::formatFilesize( $total, $decimals );
-        }
-
-        /**
-         *  Returns the total free space on the partition where this directory lives
-         *
-         *	@param $format	 (Optional) Boolean that defines if free space should be returned as bytes or formated
-         *	@param $decimals (Optional) Decimals to use when free space is formated
-         *
-         *	@returns	The number of bytes available
-         *
-         *	@static
-         */
-        function getFreeSpace( $format = false, $decimals = 1 ) {
-            return YDPath::getFreeSpace( $this->_path, $format, $decimals );
-        }
-
-        /**
-         *	This function will get a file list using a pattern. You can compare this function with the dir command from
-         *	DOS or the ls command from Unix. The pattern syntax is the same as well.
-         *
-         *	@remarks
-         *		This will not work recursively on the subdirectories.
-         *
-         *	@param $pattern	(optional) Pattern to which the files should match. If you want multiple items, you can also
-         *					pass them as an array. If the pattern is prefixed with an exclamation mark, the files that
-         *					match this pattern will not be included in the result.
-         *	@param $class	(optional) If you specify a not null value for this option, this function will return the
-         *					items in the directory as the indicated class. If an empty string is given, it will return
-         *					the list of filenames instead of objects. If a string 'fullpath' is given, it will return
-         *					the list of filenames using the fullpath. If a string 'hash' is given, it will return a list 
-         *					of filenames as a associative array with filename basename has key and filename fullpath has value.
-         *	@param $classes	(optional) An array with the classes to include. Standard, it includes YDFSImage, YDFSFile
-         *					and YDFSDirectory classes. If you only need a single class, you can also specify it as a
-         *					string.
-         *  @param $sort_by_date (optional) Sorts the items by date. Default is false.
-         *  @param $sort_order    (optional) Whether the sort direction is ascending or descending. Default is "ASC".
-         *
-         *	@returns	Array of YDFile objects for the files that match the pattern.
-         */
-        function getContents( $pattern='', $class=null, $classes=array( 'YDFSFile', 'YDFSImage', 'YDFSDirectory' ), $sort_by_date=false, $sort_order='asc' ) {
-
-            // Start with an empty list
-            $fileList = array();
-            $fileListMatch = array();
-
-            // Get the list of patterns
-            if ( ! is_array( $pattern ) ) {
-                $pattern = array( $pattern );
-            }
-
-            // Check if there other patterns than exceptions
-            $hasMoreThanExceptions = false;
-            foreach ( $pattern as $patternitem ) {
-                if ( ! empty( $patternitem ) && substr( $patternitem, 0, 1 ) != '!' ) {
-                    $hasMoreThanExceptions = true;
-                    break;
-                }
-            }
-
-            // Get the files that match
-            if ( $hasMoreThanExceptions == true ) {
-                foreach ( $pattern as $patternitem ) {
-                    if ( ! empty( $patternitem ) && substr( $patternitem, 0, 1 ) != '!' ) {
-                        $glob_files = glob( $this->getAbsolutePath() . '/' . $patternitem );
-                        if ( $glob_files !== false ) {
-                            foreach ( $glob_files as $file ) {
-                                $file = basename( $file );
-                                $fileListMatch[ $file ] = $file;
-                            }
-                        }
-                    } else if ( empty( $patternitem ) ) {
-                        $glob_files = glob( $this->getAbsolutePath() . '/*' );
-                        if ( $glob_files !== false ) {
-                            foreach ( glob( $this->getAbsolutePath() . '/*' ) as $file ) {
-                                $file = basename( $file );
-                                $fileListMatch[ $file ] = $file;
-                            }
-                        }
-                    }
-                }
-            } else {
-                $glob_files = glob( $this->getAbsolutePath() . '/' . '*' );
-                if ( $glob_files !== false ) {
-                    foreach ( $glob_files as $file ) {
-                        $file = basename( $file );
-                        $fileListMatch[ $file ] = $file;
-                    }
-                }
-            }
-            $fileList = & $fileListMatch;
-
-            // Remove the files that don't match
-            foreach ( $pattern as $patternitem ) {
-                if ( ! empty( $patternitem ) && substr( $patternitem, 0, 1 ) == '!' ) {
-                    $glob_files = glob( $this->getAbsolutePath() . '/' . substr( $patternitem, 1 ) );
-                    if ( $glob_files !== false ) {
-                        foreach ( $glob_files as $file ) {
-                            $file = basename( $file );
-                            unset( $fileList[ $file ] );
-                        }
-                    }
-                }
-            }
-
-            // Get the values
-            $fileList = array_values( $fileList );
-
-            // Convert the list of a list of YDFile objects
-            $fileList2 = array();
-            foreach ( $fileList as $file ) {
-                $file = $this->getPath() . '/' . $file;
-                if ( ! is_null( $class ) && $class != '' && $class != 'fullpath' && $class != 'hash' ) {
-                    $fileObj = new $class( $file );
-                } else {
-                    if ( is_dir( $file ) ) {
-                        $fileObj = new YDFSDirectory( $file );
-                    } else {
-                        if ( YDPath::isImage( $file ) ) {
-                            $fileObj = new YDFSImage( $file );
-                        } else {
-                            $fileObj = new YDFSFile( $file );
-                        }
-                    }
-                }
-                if ( $sort_by_date === true ) {
-                    $fileList2[ filectime( $file ) . strtolower( $file ) ] = $fileObj;
-                } else {
-                    $fileList2[ strtolower( $file ) ] = $fileObj;
-                }
-            }
-
-            // Sort the list of files
-            if ( strtolower( $sort_order ) != 'desc' ) {
-                ksort( $fileList2 );
-            } else {
-                krsort( $fileList2 );
-            }
-            $fileList2 = array_values( $fileList2 );
-
-            // Remove the unsupported classes
-            if ( ! is_array( $classes ) ) {
-                $classes = array( $classes );
-            }
-            if ( sizeof( $classes ) == 0 ) {
-                return array();
-            }
-            foreach ( $classes as $key => $val ) {
-                $classes[ $key ] = strtolower( $val );
-            }
-            foreach ( $fileList2 as $key=>$val ) {
-                if ( ! in_array( strtolower( get_class( $val ) ), $classes ) ) {
-                    unset( $fileList2[ $key ] );
-                }
-            }
-
-            // Return a simple list if needed
-            if ( is_string( $class ) ) {
-
-                // Initialize a list for the files only
-                $fileOnlyList = array();
-
-                // Add the files
-                foreach ( $fileList2 as $file ) {
-                    $filename = $class === '' ? basename( $file->_path ) : realpath( $file->_path );
-
-                    if ( $class === 'hash' ){
-                        $fileOnlyList[ basename( $file->_path ) ] = $filename;
-                    }else{
-                        $fileOnlyList[] = $filename;
-                    }
-                }
-
-                // Return the fileOnlyList array
-                return $fileOnlyList;
-
-            }
-
-            // Return the file list
-            return $fileList2;
-
-        }
-
-        /**
-         *  This function will list all the files in this directory, but will also recurse into the subdirectories.
-         *
-         *	@param $pattern	(optional) Pattern to which the files should match. If you want multiple items, you can also
-         *					pass them as an array. If the pattern is prefixed with an exclamation mark, the files that
-         *					match this pattern will not be included in the result.
-         *	@param $class	(optional) If you specify a not null value for this option, this function will return the
-         *					items in the directory as the indicated class. If an empty string is given, it will return
-         *					the list of filenames instead of objects. If a string 'fullpath' is given, it will return
-         *					the list of filenames using the fullpath. If a string 'hash' is given, it will return a list 
-         *					of filenames as a associative array with filename basename has key and filename fullpath has value.
-         *	@param $classes	(optional) An array with the classes to include. Standard, it includes YDFSImage and
-         *					YDFSFile classes. If you only need a single class, you can also specify it as a string.
-         *  @param $sort_by_date (optional) Sorts the items by date. Default is false.
-         *  @param $sort_order    (optional) Whether the sort direction is ascending or descending. Default is "ASC".
-         *  @param $levels        (optional) Integer that defines how deep should the cycle go. Default: -1 (infinite).
-         *
-         *	@returns	Array of YDFile objects for the files that match the pattern.
-         */
-        function getFilesRecursively( $pattern='', $class=null, $classes=array( 'YDFSFile', 'YDFSImage' ), $sort_by_date=false, $sort_order='asc', $levels = -1 ) {
-            $files = array();
-            foreach ( $this->_getSubdirectories( $this->_path, $levels ) as $dir ) {
-                $dir = new YDFSDirectory( $dir );
-                $files = array_merge( $files, $dir->getContents( $pattern, $class, $classes, $sort_by_date, $sort_order ) );
-            }
-            return $files;
-        }
-
-        /**
-         *	Helper function to get the contents of a directory recursively.
-         *
-         *  @param  $path   The path to get the subdirectories from.
-         *  @param  $levels (optional) Integer that defines how deep should the cycle go. Default: -1 (infinite).
-         *
-         *  @returns    The list of subdirectories of the given path.
-         *
-         *  @internal
-         */
-        function _getSubdirectories( $path, $levels = -1 ) {
-            $dirlist = array( $path );
-            if ( $levels == 0 ) return $dirlist;
-            $dirHandle = opendir( $path );
-            while ( false !== ( $file = readdir( $dirHandle ) ) ) {
-                if ( $file != '.' && $file != '..' ) {
-                    if ( is_dir( $path . '/' . $file ) ) {
-                        array_push( $dirlist, $path . '/' . $file );
-                        $dirlist = array_merge( $dirlist, $this->_getSubdirectories( $path . '/' . $file, $levels - 1 ) );
-                    }
-                }
-            }
-            sort( $dirlist );
-            return array_unique( $dirlist );
-        }
-
-        /**
-         *	Function to get the full path of the directory.
-         *
-         *	@returns	String containing the full path of the directory.
-         */
-        function getPath() {
-            return YDPath::getFullPath( $this->_path );
-        }
-
-        /**
-         *  This function returns true if the directory is readable.
-         *
-         *  @returns    Returns true if the directory is readable.
-         */
-        function isReadable(){
-            return is_readable( $this->getPath() );
-        }
-
-        /**
-         *	This function will return true if the directory is writeable, otherwise, it will return false.
-         *
-         *	@remarks
-         *		This only works correctly on Unix based systems.
-         *
-         *	@returns	Boolean indicating if the directory is writeable or not.
-         */
-        function isWriteable() {
-            return is_writable( $this->getPath() );
-        }
-
-        /**
-         *	This function will create a new file in the current directory, and will write the specified contents to the
-         *	file. Once finished, it will return a new YDFSFile object pointing to the file. All directory paths are
-         *	relative to the current directory.
-         *
-         *	@param $filename	The filename of the new file.
-         *	@param $contents	The contents of the new file.
-         *
-         *	@returns	YDFSFile or YDFSImage object pointing to the new file.
-         */
-        function createFile( $filename, $contents ) {
-
-            // Set the directory of this object as the working directory
-            chdir( $this->getPath() );
-
-            // Create the new file
-            $fp = fopen( $filename, 'wb' );
-
-            // Save the contents to the file
-            $result = fwrite( $fp, $contents );
-
-            // Check for errors
-            if ( $result == false ) {
-                trigger_error(
-                    'Failed writing to the file "' . $filename . '" in the directory called "' . $this->getPath() . '".',
-                    YD_ERROR
-                );
-            }
-
-            // Close the file
-            fclose( $fp );
-
-            // Create the YDFSFile object
-            $obj = new YDFSFile( $filename );
-
-            // Check if it's an image
-            if ( $obj->isImage() ) {
-                $obj = new YDFSImage( $filename );
-            }
-
-            // Return the file object
-            return $obj;
-
-        }
-
-        /**
-         *	This function will delete a file from the current directory.
-         *
-         *	@param $filename	The file you want to delete.
-         *	@param $failOnError	(optional) Indicate if a fatal error needs to be raised if deleting the file failed.
-         *
-         *	@return	There are three possible return values for this function. True indicates that the file exists and
-         *			is deleted successfully. False indicates the file exists but could not be deleted. Null indicates
-         *			the file didn't exist and therefor could not be deleted.
-         */
-        function deleteFile( $filename, $failOnError=false ) {
-
-            // Set the directory of this object as the working directory
-            chdir( $this->getPath() );
-
-            // Check if the file exists
-            if ( file_exists( $filename ) ) {
-
-                // Try to delete the file
-                $result = unlink( $filename );
-
-                // Check for errors
-                if ( $result == false ) {
-
-                    // Check if we need to raise an error
-                    if ( $failOnError == true ) {
-                        trigger_error(
-                            'Failed deleting the file "' . $file . '" from the directory "' . $this->getPath() . '".',
-                            YD_ERROR
-                        );
-                    }
-
-                }
-
-
-                // Return if the file was deleted or not
-                return $result;
-
-            }
-
-            // Return null if the file doesn't exist
-            return null;
-
-        }
-
-        /**
-         *	This function will create a new subdirectory in the given directory.
-         *
-         *	@param $directory	Directory to create.
-         *	@param $mode		(optional) The mode for the directory. By default, this is 0700.
-         *
-         *	@returns	False on failure, otherwise, it will return a YDFSDirectory object for the new directory.
-         */
-        function createDirectory( $directory, $mode=0700 ) {
-            $directory = YDPath::join( $this->getAbsolutePath(), $directory );
-            if ( is_dir( $directory ) || mkdir( $directory, $mode ) ) {
-                return new YDFSDirectory( $directory );
-            } else {
-                return false;
-            }
-        }
-
-
-        /**
-         *  This function will recursively create the directories
-         *	@param $directory	Directory to create.
-         *	@param $mode		(optional) The mode for the directory. By default, this is 0700.
-         *
-         *	@returns	False on failure, otherwise, it will return a YDFSDirectory object for the new directory.
-         *
-         *  @static
-         */
-        function createDirectories( $directory, $mode=0700 ) {
-            if ( is_null( $directory ) || $directory === '' ) {
-                return false;
-            }
-            if ( is_dir( $directory ) || $directory === '/' ) {
-                return true;
-            }
-            if ( YDFSDirectory::createDirectories( dirname( $directory ), $mode ) ) {
-                return mkdir( $directory, $mode );
-            }
-            return false;
-        }
-
-        /**
-         *	This function will recursively delete a directory. It will delete the directory and the complete
-         *	contents of that directory! Be careful I would say!
-         *
-         *	@param $directory	Directory to be removed.
-         *
-         *	@return	Boolean indicating if the directory could be deleted or not.
-         */
-        function deleteDirectory( $directory ) {
-            $directory = YDPath::join( $this->getAbsolutePath(), $directory );
-            if ( ! is_dir( $directory ) ) {
-                return false;
-            }
-            return YDFSDirectory::_delete( $directory );
-        }
-
-        /**
-         *	This function will return true if the filesystem object is a directory. In all other cases, it will return
-         *	false.
-         *
-         *	@returns	Boolean indicating if the object is a directory or not.
-         */
-        function isDirectory() {
-            return true;
-        }
-
-        /**
-         *	This function will return true if the filesystem object is an image. In all other cases, it will return
-         *	false.
-         *
-         *	@returns	Boolean indicating if the object is an image or not.
-         */
-        function isImage() {
-            return false;
-        }
-
-        /**
-         *	This function will move the directory to the specified path and update the object accordingly.
-         *
-         *	@param	$path	Target path.
-         *
-         *	@returns	False on a failure, true on success.
-         */
-        function moveDirectory( $path ) {
-            $result = rename( $this->getAbsolutePath(), $path );
-            if ( $result ) {
-                $this->_path = realpath( $path );
-            }
-            return $result;
-        }
-
-        /**
-         *  This function will check if the specified file/or directory exists in the current path.
-         *
-         *  @param $obj     The file or directory you are looking for.
-         *	@param $classes	(optional) An array with the classes to include. Standard, it includes YDFSImage, YDFSFile
-         *					and YDFSDirectory classes. If you only need a single class, you can also specify it as a
-         *					string.
-         *
-         *	@returns	Array of YDFile objects for the files that match the pattern.
-         */
-        function has( $obj, $classes=array( 'YDFSFile', 'YDFSImage', 'YDFSDirectory' ) ) {
-
-            // Get the contents
-            $contents = $this->getContents( $obj, '', $classes );
-
-            // Return the result
-            return ( sizeof( $contents ) == 0 ) ? false : true;
-
-        }
-
-        /**
-         *	Function to recursively delete a directory.
-         *
-         *	@param $dirname	Directory to be removed.
-         *
-         *	@return	Boolean indicating if the directory could be deleted or not.
-         *
-         *	@internal
-         */
-        function _delete( $dirname ) {
-
-            // Simple delete for a file
-            if ( is_file( $dirname ) ) {
-                return unlink( $dirname );
-            }
-
-            // Loop through the folder
-            $dir = dir( $dirname );
-            while ( false !== $entry = $dir->read() ) {
-
-                // Skip pointers
-                if ( $entry == '.' || $entry == '..' ) {
-                    continue;
-                }
-
-                // Deep delete directories
-                if ( is_dir( "$dirname/$entry" ) ) {
-                    YDFSDirectory::_delete( "$dirname/$entry" );
-                } else {
-                    unlink( "$dirname/$entry" );
-                }
-            }
-
-            // Clean up
-            $dir->close();
-            return rmdir( $dirname );
-
-        }
-
-    }
-
+<?php
+
+    /*
+
+        Yellow Duck Framework version 2.1
+        (c) Copyright 2002-2007 Pieter Claerhout
+
+        This library is free software; you can redistribute it and/or
+        modify it under the terms of the GNU Lesser General Public
+        License as published by the Free Software Foundation; either
+        version 2.1 of the License, or (at your option) any later version.
+
+        This library is distributed in the hope that it will be useful,
+        but WITHOUT ANY WARRANTY; without even the implied warranty of
+        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+        Lesser General Public License for more details.
+
+        You should have received a copy of the GNU Lesser General Public
+        License along with this library; if not, write to the Free Software
+        Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+
+    */
+
+    /**
+     *  @addtogroup YDFramework Core
+     */
+
+    // Check if the framework is loaded
+    if ( ! defined( 'YD_FW_NAME' ) ) {
+        die( 'Yellow Duck Framework is not loaded.' );
+    }
+
+    // Includes
+    include_once( YD_DIR_HOME_CLS . '/YDUtil.php');
+    include_once( YD_DIR_HOME . '/3rdparty/bmp.php' );
+
+    // YDFSImage cropping specific constants
+    define( 'YD_FS_CROP_UNCHANGED', 1 );
+    define( 'YD_FS_CROP_ENLARGED',  2 );
+    define( 'YD_FS_CROP_BORDERED',  3 );
+
+    // Config when cropping smaller images
+    YDConfig::set( 'YD_FS_CROP', YD_FS_CROP_ENLARGED, false );
+
+    // The mime types mapping
+    $GLOBALS['YD_FS_MIME_MAPPING'] = array(
+        'ez' => 'application/andrew-inset',
+        'hqx' => 'application/mac-binhex40',
+        'cpt' => 'application/mac-compactpro',
+        'mathml' => 'application/mathml+xml',
+        'doc' => 'application/msword',
+        'oda' => 'application/oda',
+        'ogg' => 'application/ogg',
+        'pdf' => 'application/pdf',
+        'rdf' => 'application/rdf+xml',
+        'gram' => 'application/srgs',
+        'grxml' => 'application/srgs+xml',
+        'mif' => 'application/vnd.mif',
+        'xul' => 'application/vnd.mozilla.xul+xml',
+        'xls' => 'application/vnd.ms-excel',
+        'ppt' => 'application/vnd.ms-powerpoint',
+        'wbxml' => 'application/vnd.wap.wbxml',
+        'wmlc' => 'application/vnd.wap.wmlc',
+        'wmlsc' => 'application/vnd.wap.wmlscriptc',
+        'vxml' => 'application/voicexml+xml',
+        'bcpio' => 'application/x-bcpio',
+        'vcd' => 'application/x-cdlink',
+        'pgn' => 'application/x-chess-pgn',
+        'cpio' => 'application/x-cpio',
+        'csh' => 'application/x-csh',
+        'dvi' => 'application/x-dvi',
+        'spl' => 'application/x-futuresplash',
+        'gtar' => 'application/x-gtar',
+        'hdf' => 'application/x-hdf',
+        'js' => 'application/x-javascript',
+        'latex' => 'application/x-latex',
+        'sh' => 'application/x-sh',
+        'shar' => 'application/x-shar',
+        'swf' => 'application/x-shockwave-flash',
+        'sit' => 'application/x-stuffit',
+        'sv4cpio' => 'application/x-sv4cpio',
+        'sv4crc' => 'application/x-sv4crc',
+        'tar' => 'application/x-tar',
+        'tcl' => 'application/x-tcl',
+        'tex' => 'application/x-tex',
+        'man' => 'application/x-troff-man',
+        'me' => 'application/x-troff-me',
+        'ms' => 'application/x-troff-ms',
+        'ustar' => 'application/x-ustar',
+        'src' => 'application/x-wais-source',
+        'xslt' => 'application/xslt+xml',
+        'dtd' => 'application/xml-dtd',
+        'zip' => 'application/zip',
+        'm3u' => 'audio/x-mpegurl',
+        'rpm' => 'audio/x-pn-realaudio-plugin',
+        'ra' => 'audio/x-realaudio',
+        'wav' => 'audio/x-wav',
+        'pdb' => 'chemical/x-pdb',
+        'xyz' => 'chemical/x-xyz',
+        'bmp' => 'image/bmp',
+        'cgm' => 'image/cgm',
+        'gif' => 'image/gif',
+        'ief' => 'image/ief',
+        'png' => 'image/png',
+        'jpg' => 'image/jpeg',
+        'svg' => 'image/svg+xml',
+        'wbmp' => 'image/vnd.wap.wbmp',
+        'ras' => 'image/x-cmu-raster',
+        'ico' => 'image/x-icon',
+        'pnm' => 'image/x-portable-anymap',
+        'pbm' => 'image/x-portable-bitmap',
+        'pgm' => 'image/x-portable-graymap',
+        'ppm' => 'image/x-portable-pixmap',
+        'rgb' => 'image/x-rgb',
+        'xbm' => 'image/x-xbitmap',
+        'xpm' => 'image/x-xpixmap',
+        'xwd' => 'image/x-xwindowdump',
+        'css' => 'text/css',
+        'rtx' => 'text/richtext',
+        'rtf' => 'text/rtf',
+        'tsv' => 'text/tab-separated-values',
+        'wml' => 'text/vnd.wap.wml',
+        'wmls' => 'text/vnd.wap.wmlscript',
+        'etx' => 'text/x-setext',
+        'avi' => 'video/x-msvideo',
+        'movie' => 'video/x-sgi-movie',
+        'ice' => 'x-conference/x-cooltalk',
+        'php' => 'text/plain',
+    );
+
+    /**
+     *	This class houses all different path related functions.
+     *
+     *  @ingroup YDFramework
+     */
+    class YDPath extends YDBase {
+
+        /**
+         *	Provides a platform-specific character used to separate directory levels in a path string that reflects a
+         *	hierarchical file system organization.
+         *
+         *	@returns	String containing the directory separator
+         *
+         *	@static
+         */
+        function getDirectorySeparator() {
+            return ( YD_PATHDELIM == ':' ) ? '/' : '\\';
+        }
+
+        /**
+         *	A platform-specific separator character used to separate path strings in environment variables.
+         *
+         *	@returns	String containing the path separator
+         *
+         *	@static
+         */
+        function getPathSeparator() {
+            return YD_PATHDELIM;
+        }
+
+        /**
+         *	Provides a platform-specific volume separator character.
+         *
+         *	@returns	String containing the volume separator
+         *
+         *	@static
+         */
+        function getVolumeSeparator() {
+            if ( strtoupper( substr( PHP_OS, 0, 3 ) ) == 'WIN' || strtoupper( PHP_OS ) == 'DARWIN' ) {
+                return ':';
+            } else {
+                return '/';
+            }
+        }
+
+        /**
+         *	Changes the extension of a path string.
+         *
+         *	@param $path	Path of the file or directory.
+         *	@param $ext	The new extension.
+         *
+         *	@returns	String with the changed extension
+         *
+         *	@static
+         */
+        function changeExtension( $path, $ext ) {
+            if ( ! empty( $ext ) && substr( $ext, 0, 1 ) != '.' ) {
+                $ext = '.' . $ext;
+            }
+            return YDPath::getFilePathWithoutExtension( $path ) . $ext;
+        }
+
+        /**
+         *	@param $path	Path of the file or directory.
+         *
+         *	@returns	The directory information for the specified path string
+         *
+         *	@static
+         */
+        function getDirectoryName( $path ) {
+            return dirname( $path );
+        }
+
+        /**
+         *	@param $path	Path of the file or directory.
+         *
+         *	@param $format	(Optional) Boolean that defines if free space should be returned as bytes or formated
+         *
+         *	@param $decimals (Optional) Decimals to use when free space is formated
+         *
+         *	@returns	The number of bytes available on the specified path
+         *
+         *	@static
+         */
+        function getFreeSpace( $path, $format = false, $decimals = 1 ) {
+
+            // get free disk space on the path
+            $space = disk_free_space( $path );
+
+            // return number of bytes if we don't want to format
+            if ( $format == false ) return $space;
+
+            // include util lib
+            YDInclude( 'YDUtil.php' );
+
+            // return formated string
+            return YDStringUtil::formatFilesize( $space, $decimals );
+        }
+
+        /**
+         *	@param $path	Path of the file or directory.
+         *
+         *	@returns	The extension of the specified path string
+         *
+         *	@static
+         */
+        function getExtension( $path ) {
+            if ( strrchr( $path, '.' ) ) {
+                return substr( strrchr( $path, '.' ), 1 );
+            } else {
+                return '';
+            }
+        }
+
+        /**
+         *	@param $path	Path of the file or directory.
+         *
+         *	@returns	The file name and extension of the specified path string
+         *
+         *	@static
+         */
+        function getFileName( $path ) {
+            return basename( $path );
+        }
+
+        /**
+         *	@param $path	Path of the file or directory.
+         *
+         *	@returns	The file name of the specified path string without the extension
+         *
+         *	@static
+         */
+        function getFileNameWithoutExtension( $path ) {
+            return basename( $path, '.' . YDPath::getExtension( $path ) );
+        }
+
+        /**
+         *	@param $path	Path of the file or directory.
+         *
+         *	@returns	The file path and extension of the specified path string
+         *
+         *	@static
+         */
+        function getFilePath( $path ) {
+            return realpath( $path );
+        }
+
+        /**
+         *	@param $path	Path of the file or directory.
+         *
+         *	@returns	The file path of the specified path string without the extension
+         *
+         *	@static
+         */
+        function getFilePathWithoutExtension( $path ) {
+            return YDPath::getDirectoryName( $path ) . YDPath::getDirectorySeparator() . YDPath::getFileNameWithoutExtension( $path );
+        }
+
+        /**
+         *	@param $path	Path of the file or directory.
+         *
+         *	@returns	The absolute path for the specified path string
+         *
+         *	@static
+         */
+        function getFullPath( $path ) {
+            return realpath( $path );
+        }
+
+        /**
+         *	@returns	A uniquely named temporary file on disk and returns the full path to that file
+         *
+         *	@static
+         */
+        function getTempFileName() {
+            $tmpName = '';
+            for ($i=0;$i<rand(0,50);$i++) {
+                $tmpName .= "&#" . rand(33,255) . ";";
+            }
+            return YDPath::getTempPath() . YDPath::getDirectorySeparator() . md5( $tmpName ) . '.temp';
+        }
+
+        /**
+         *	@returns	The path of the current system's temporary folder.
+         *
+         *	@static
+         */
+        function getTempPath() {
+            return YD_DIR_TEMP;
+        }
+
+        /**
+         *	@param $path	Path of the file or directory.
+         *
+         *	@returns	Determines whether a path includes a file name extension
+         *
+         *	@static
+         */
+        function hasExtension( $path ) {
+            $ext = YDPath::getExtension( $path );
+            return empty( $ext ) ? false : true;
+        }
+
+        /**
+         *	This function will check if the path is an absolute path or not.
+         *
+         *	@param	$path	The path to check
+         *
+         *	@returns	Boolean indicating if the path is absolute or not.
+         *
+         *	@static
+         */
+        function isAbsolute( $path ) {
+            if ( strtoupper( substr( PHP_OS, 0, 3 ) ) == 'WIN' ) {
+                if ( strlen( $path ) > 3 && substr( $path, 1, 2 ) == ':\\' ) {
+                    return true;
+                } else {
+                    return false;
+                }
+            } else {
+                return ( substr( $path, 0, 1 ) == '/' );
+            }
+        }
+
+        /**
+         *	This function combines different file path elements to each other.
+         *
+         *	@code
+         *	join( 'C:\temp', 'subdir', 'file.html' )
+         *	@endcode
+         *
+         *	results in the following path:
+         *
+         *	@code
+         *	C:\temp\subdir\file.html
+         *	@endcode
+         *
+         *	@returns	The joined path.
+         *
+         *	@static
+         */
+        function join() {
+
+            // Get the arguments for this function
+            $args = func_get_args();
+
+            // Start with an empty path
+            $path = '';
+
+            // Loop over the different elements
+            foreach ( $args as $arg ) {
+
+                if ( ! strlen( $arg ) ) {
+                    continue;
+                }
+
+                // Normalize the path elements
+                $arg = str_replace( '/', YDPath::getDirectorySeparator(), $arg );
+                $arg = str_replace( '\\', YDPath::getDirectorySeparator(), $arg );
+
+                // Check for an absolute path
+                if ( YDPath::isAbsolute( $arg ) ) {
+                    $path = $arg;
+                } else {
+
+                    // Remove the trailing directory separator
+                    if ( substr( $arg, -1, 1 ) == YDPath::getDirectorySeparator() ) {
+                        $arg = substr( $arg, 0, -1 );
+                    }
+
+                    // Add it to the path
+                    if ( strlen( $path ) > 0 ) {
+                        if ( substr( $arg, 0, 1 ) != YDPath::getDirectorySeparator() ) {
+                            $path .= YDPath::getDirectorySeparator() . $arg;
+                        } else {
+                            $path .= $arg;
+                        }
+                    } else {
+                        $path .= $arg;
+                    }
+
+                }
+
+            }
+
+            // Return the joined path
+            return $path;
+
+        }
+
+        /**
+         *	Function to determine if the file is an image or not. This function will read the header of the file to
+         *	find out if it's an image or not.
+         *
+         *	@returns	Boolean indicating if the file is an image or not.
+         */
+        function isImage( $path ) {
+
+            // Return false if path doesn't exist
+            if ( ! realpath( $path ) ) {
+                return false;
+            }
+
+            // Check if we have an extension
+            $extension = strtolower( YDPath::getExtension( $path ) );
+            if ( $extension && $extension != 'tmn' ) {
+                if ( in_array( $extension, array( 'jpg', 'png', 'gif', 'jpeg' ) ) ) {
+                    return $extension;
+                }
+            }
+
+            // No extension, read the file
+            $fp = fopen( $path, 'rb' );
+            $header = fread( $fp, 8 );
+            fclose( $fp );
+            if ( substr( $header, 0, 6 ) == 'GIF87a' || substr( $header, 0, 6 ) == 'GIF89a' ) {
+                return 'gif';
+            }
+            if ( substr( $header, 6, 4 ) == 'JFIF' ) {
+                return 'jpeg';
+            }
+            if ( substr( $header, 0, 8 ) == "\211PNG\r\n\032\n" ) {
+                return 'png';
+            }
+            if ( substr( $header, 0, 2 ) == "BM" ) {
+                return 'bmp';
+            }
+
+            // Not an image
+            return false;
+
+        }
+
+    }
+
+    /**
+     *  This class defines a filesystem file.
+     *
+     *  @ingroup YDFramework
+     */
+    class YDFSFile extends YDBase {
+
+        /**
+         *  The class constructor of the YDFSFile class takes the path to the file as it's first argument.
+         *  It will then provide you with a number of functions to get the properties of the file.
+         *
+         *  @param $path    Path of the file.
+         *  @param $create  (optional) Force the creation of the file if it doesn't exist. Default: false.
+         */
+        function YDFSFile( $path, $create=false ) {
+
+            // Initialize YDBase
+            $this->YDBase();
+
+            // Check if the path if the file exists
+            if ( ! is_file( $path ) ) {
+
+                // Check if the file should be created
+                if ( $create ) {
+
+                    // Create a new YDFSDirectory object
+                    $dir = new YDFSDirectory( dirname( $path ) );
+
+                    // Create the file
+                    $dir->createFile( basename( $path ), ' ' );
+
+                } else {
+                    trigger_error( 'The file with path "' . $path . '" does not exist.', YD_ERROR );
+                }
+            }
+
+            // Save the path
+            $this->_path = realpath( $path );
+
+        }
+
+        /**
+         *	Function to get the filename of the object. This does not include the path information.
+         *
+         *	@returns	String containing the name of the object.
+         */
+        function getBasename() {
+            return YDPath::getFileName( $this->getAbsolutePath() );
+        }
+
+        /**
+         *	Function to get the filename of the object without the extension. This does not include the path information.
+         *
+         *	@returns	String containing the name of the object.
+         */
+        function getBasenameNoExt() {
+            return substr( YDPath::getFilePathWithoutExtension( $this->getBasename() ), 2 );
+        }
+
+        /**
+         *	Function to get the extension of the file.
+         *
+         *	@returns	String containing the extension of the file.
+         */
+        function getExtension() {
+            return YDPath::getExtension( $this->getAbsolutePath() );
+        }
+
+        /**
+         *	Function to get the full path of the object.
+         *
+         *	@returns	String containing the full path of the object.
+         */
+        function getPath() {
+            return YDPath::getDirectoryName( $this->getAbsolutePath() );
+        }
+
+        /**
+         *	Function to get the full absolute path of the object.
+         *
+         *	@returns	String containing the full absolute path of the object.
+         */
+        function getAbsolutePath() {
+            return YDPath::getFullPath( $this->_path );
+        }
+
+        /**
+         *	Function to get the last modification date of the object.
+         *
+         *  @param  $format (optional) The date format to use to format the date.
+         *  @param  $locale (optional) The locale to use for formatting the date.
+         *
+         *	@returns	String containing the last modification date of the object.
+         */
+        function getLastModified( $format = 'timestamp', $locale=null ) {
+            if ( $format == 'timestamp' ) {
+                return filemtime( $this->getAbsolutePath() );
+            }
+            return YDStringUtil::formatDate( filemtime( $this->getAbsolutePath() ), $format, $locale );
+        }
+
+        /**
+         *	Function to get the size of the file.
+         *
+         *  @param  $formatted  (optional) If set to true, the filesize will be returned in a human readable format.
+         *  @param  $decimals   (optional) The number of decimals to use for formatting the filesize.
+         *
+         *	@returns	Double containing the length of the file.
+         */
+        function getSize( $formatted = false, $decimals = 1 ) {
+            if ( ! $formatted ) {
+                return filesize( $this->getAbsolutePath() );
+            }
+            return YDStringUtil::formatFilesize( filesize( $this->getAbsolutePath() ), $decimals );
+        }
+
+        /**
+         *  Returns the total free space on the partition where this file lives
+         *
+         *	@param $format	 (Optional) Boolean that defines if free space should be returned as bytes or formated
+         *	@param $decimals (Optional) Decimals to use when free space is formated
+         *
+         *	@returns	The number of bytes available
+         *
+         *	@static
+         */
+        function getFreeSpace( $format = false, $decimals = 1 ) {
+            return YDPath::getFreeSpace( $this->_path, $format, $decimals );
+        }
+
+        /**
+         *	Function to get the contents of the file. Depending on the file contents, this will be returned as binary or
+         *	textual data.
+         *
+         *	@param $start	(optional) Byte to start reading from.
+         *	@param $length	(optional) Number of bytes to read.
+         *
+         *	@returns	String containing the contents of the file.
+         */
+        function getContents( $start=null, $length=null ) {
+
+            // Clear the stat cache
+            clearstatcache();
+
+            // Check the start byte
+            if ( $start == null ) {
+                $start = 0;
+            }
+
+            // No length given
+            if ( $length == null ) {
+                $length = filesize( $this->getAbsolutePath() ) - $start;
+            }
+
+            // Check that length is a positive integer
+            if ( $length < 1 ) {
+                trigger_error( 'getContents: Length should be a positive integer.', YD_ERROR );
+            }
+
+            // Variable to hold the return data
+            $result = '';
+
+            // Open the file in read binary mode
+            $file = fopen( $this->getAbsolutePath(), 'rb' );
+
+            // Check if we were able to open the file
+            if ( $file == false ) {
+                trigger_error( 'The file with path "' . $path . '" could not be read.', YD_ERROR );
+            }
+
+            // Find the start position
+            fseek( $file, $start );
+
+            // Get the contents of the file
+            $result = fread( $file, $length );
+
+            // Close the file handle
+            fclose( $file );
+
+            // Return the result
+            return $result;
+
+        }
+
+        /**
+         *	This function will create a new file in the current directory, and will write the specified contents to the
+         *	file. Once finished, it will return a new YDFSFile object pointing to the file. All directory paths are
+         *	relative to the current directory.
+         *
+         *	@param $contents	The contents of the new file.
+         *	@param $append		Boolean indicating if the content should be appended to the file or if the file contents
+         *						should be replaced.
+         */
+        function setContents( $contents, $append=false ) {
+
+            // Set the mode
+            $mode = ( $append === true ) ? 'ab' : 'wb';
+
+            // Open the file
+            $fp = fopen( $this->getAbsolutePath(), $mode );
+
+            // Save the contents to the file
+            $result = fwrite( $fp, $contents );
+
+            // Check for errors
+            if ( $result == false ) {
+                trigger_error(
+                    'Failed writing to the file "' . $this->getAbsolutePath() . '" in the directory called "' . $this->getPath() . '".',
+                    YD_ERROR
+                );
+            }
+
+            // Close the file
+            fclose( $fp );
+
+            // Clear the stat cache
+            clearstatcache();
+
+            return true;
+        }
+
+        /**
+         *	Function to determine if the file is an image or not. This function will read the header of the file to
+         *	find out if it's an image or not.
+         *
+         *	@returns	Boolean indicating if the file is an image or not.
+         */
+        function isImage() {
+            return YDPath::isImage( $this->getAbsolutePath() );
+        }
+
+        /**
+         *  This function returns true if the file is readable.
+         *
+         *  @returns    Returns true if the file is readable.
+         */
+        function isReadable(){
+            return is_readable( $this->getAbsolutePath() );
+        }
+
+        /**
+         *	This function will return true if the directory is writeable, otherwise, it will return false.
+         *
+         *	@remarks
+         *		This only works correctly on Unix based systems.
+         *
+         *	@returns	Boolean indicating if the directory is writeable or not.
+         */
+        function isWriteable() {
+            return is_writable( $this->getAbsolutePath() );
+        }
+
+        /**
+         *	This function will force the browser to download the file.
+         *
+         *	@param $name	(optional) The name of the file download should show in the browser. By default, this is the
+         *					same as the filename.
+         *  @param $inline  (optional) If set to true, the download is inline, otherwise, a download will be forced by
+         *                  the browser. Default is false.
+         */
+        function download( $name=null, $inline=false ) {
+
+            // Get the name of the file
+            if ( is_null( $name ) ) {
+                $name = $this->getBasename();
+            }
+
+            // Force download or do inline
+            if ( ! $inline ) {
+                header( 'Content-Type: application/force-download; name="' . $name . '"');
+                header( 'Content-Disposition: attachment; filename="' . $name . ' "');
+            } else {
+                header( 'Content-Type: ' . $this->getMimeType() );
+                header( 'Content-Disposition: inline; filename="' . $name . ' "');
+            }
+
+            // Add the rest of the headers
+            header( 'Cache-Control: public' );
+            header( 'Content-Transfer-Encoding: binary' );
+            header( 'Content-length: ' . $this->getSize() );
+
+            // Send the file contents
+            readfile( $this->getAbsolutePath() );
+
+            // Stop the execution
+            die();
+
+        }
+
+        /**
+         *	This function will delete a file from the current directory.
+         *
+         *	@param $failOnError	(optional) Indicate if a fatal error needs to be raised if deleting the file failed.
+         *
+         *	@return	There are three possible return values for this function. True indicates that the file exists and
+         *			is deleted successfully. False indicates the file exists but could not be deleted. Null indicates
+         *			the file didn't exist and therefor could not be deleted.
+         */
+        function delete( $failOnError=false ) {
+
+            // Set the filename
+            $filename = $this->getAbsolutePath();
+
+            // Set the directory of this object as the working directory
+            chdir( $this->getPath() );
+
+            // Check if the file exists
+            if ( file_exists( $filename ) ) {
+
+                // Try to delete the file
+                $result = unlink( $filename );
+
+                // Check for errors
+                if ( $result == false ) {
+
+                    // Check if we need to raise an error
+                    if ( $failOnError == true ) {
+                        trigger_error(
+                            'Failed deleting the file "' . $filename . '" from the directory "' . $this->getPath() . '".',
+                            YD_ERROR
+                        );
+                    }
+
+                }
+
+                // Return if the file was deleted or not
+                return $result;
+
+            }
+
+            // Return null if the file doesn't exist
+            return null;
+
+        }
+
+        /**
+         *  This function will rename the file to the specified file path.
+         *
+         *  @param  $new_path   The new path of the file.
+         *
+         *  @returns    True on success, false on failure.
+         */
+        function rename( $new_path ) {
+            @unlink( $new_path );
+            $result = rename( $this->getAbsolutePath(), $new_path );
+            if ( $result === true ) {
+                $this->_path = realpath( $new_path );
+            }
+            return $result;
+        }
+
+        /**
+         *	This function will return true if the filesystem object is a directory. In all other cases, it will return
+         *	false.
+         *
+         *	@returns	Boolean indicating if the object is a directory or not.
+         */
+        function isDirectory() {
+            return false;
+        }
+
+        /**
+         *  This function returns the mime type for the file object.
+         *
+         *  @returns    The mime type for the document. If the mime type is not known, it will use the
+         *              application/octet-stream mime type.
+         */
+        function getMimeType() {
+            $extension = strtolower( $this->getExtension() );
+            if ( isset( $GLOBALS['YD_FS_MIME_MAPPING'][$extension] ) ) {
+                return $GLOBALS['YD_FS_MIME_MAPPING'][$extension];
+            } else {
+                return 'application/octet-stream';
+            }
+        }
+
+        /**
+         *	@internal
+         */
+        function _getImageType() {
+            return YDPath::isImage( $this->getAbsolutePath() );
+        }
+
+        /**
+         *	This function will move the file to the specified path and update the object accordingly.
+         *
+         *	@param	$path	Target path.
+         *
+         *	@returns	False on a failure, true on success.
+         */
+        function move( $path ) {
+            $result = rename( $this->getAbsolutePath(), $path );
+            if ( $result ) {
+                $this->_path = realpath( $path );
+            }
+            return $result;
+        }
+
+    }
+
+    /**
+     *	This class defines an image file.
+     *
+     *  @ingroup YDFramework
+     */
+    class YDFSImage extends YDFSFile {
+
+        /**
+         *	The class constructor of the YDImage class takes the path to the image as it's only argument. It will then
+         *	provide you with a number of functions to get the properties of the image and also provides some actions
+         *	like generating thumbnails.
+         *
+         *	@param $path	Path of the image.
+         *  @param $create  (optional) Force the creation of the file if it doesn't exist. Default: false.
+         */
+        function YDFSImage( $path, $create=false ) {
+
+            // Initialize the parent
+            $this->YDFSFile( $path, $create );
+
+            // Get the image size
+            $this->image_size = null;
+
+        }
+
+        /**
+         *  Function determine the image size. This is just a helper function for the other ones.
+         *
+         *  @internal
+         */
+        function _initImageSize() {
+
+            // Check for the getimagesize function
+            if ( ! function_exists( 'getimagesize' ) ) {
+                trigger_error(
+                    'The "getimagesize" function does not exists. Make sure that the GD libraries are loaded before '
+                    . 'using the YDFSImage::getImageSize function.', YD_ERROR
+                );
+            }
+
+            if ( is_null( $this->image_size ) ) {
+                $this->image_size = getimagesize( $this->getAbsolutePath() );
+            }
+       }
+
+        /**
+         *	Function to output the thumbnail of an image. The function directly outputs the thumbnail to the client
+         *	including the right headers needed to display the image.
+         *
+         *	This function can cache the thumbnails and regenerate them on the fly if needed. The cached thumbnails are
+         *	stored in the temp directory of the Yellow Duck framework and have the extension "tmn". You can delete these
+         *	automatically as they will be recreated on the fly if needed.
+         *
+         *	@param $width	The maximum width of the thumbnail.
+         *	@param $height	The maximum height of the thumbnail.
+         *	@param $cache	(optional) Indicate if the thumbnail should be cached. By default, caching is turned on.
+         *	@param $crop	(optional) Indicate if the thumbnail should be cropped to the exact size. By default, false.
+         */
+        function outputThumbnail( $width, $height, $cache=true, $crop=false ) {
+
+            // Output right headers
+            $content_type = $this->getMimeType();
+            header( 'Content-type: ' . $content_type );
+
+            // Output the thumbnail
+            die( $this->_createThumbnail( $width, $height, $cache, $crop ) );
+
+        }
+
+        /**
+         *	This function will create a thumbnail and save the thumbnail to disk.
+         *
+         *	@param $width	The maximum width of the thumbnail.
+         *	@param $height	The maximum height of the thumbnail.
+         *	@param $file	The filename to save the thumbnail to.
+         *	@param $crop	(optional) Indicate if the thumbnail should be cropped to the exact size. By default, false.
+         *
+         *  @returns    A new YDFSImage object for the thumbnail.
+         */
+        function saveThumbnail( $width, $height, $file, $crop=false ) {
+
+            // Create the thumbnail
+            $thumb = $this->_createThumbnail( $width, $height, false, $crop );
+
+            // Save it to a file
+            $f = new YDFSImage( $file, true );
+            $f->setContents( $thumb );
+
+            // Return the thumbnail
+            return $f;
+
+        }
+
+        /**
+         *	This function will return the size of the image in pixels.
+         *
+         *	@returns	The imagesize in pixels. This is returned as an array of which the first element is the width,
+         *				the second element is the height in pixels.
+         */
+        function getImageSize() {
+
+            // Init image_size
+            $this->_initImageSize();
+
+            // Get the first two elements
+            $imgSize = array_slice( $this->image_size, 0, 2 );
+
+            // Return the image size
+            return $imgSize;
+
+        }
+
+        /**
+         *	This function will return the width of the image in pixels.
+         *
+         *	@returns	The width in pixels.
+         */
+        function getWidth() {
+            $this->_initImageSize();
+            return $this->image_size[0];
+        }
+
+        /**
+         *	This function will return the height of the image in pixels.
+         *
+         *	@returns	The height in pixels.
+         */
+        function getHeight() {
+            $this->_initImageSize();
+            return $this->image_size[1];
+        }
+
+        /**
+         *	Function that returns the type of the image. Currently, it supports GIF, JPG and PNG.
+         *
+         *	@returns	The type of the image, which is either jpg, png or gif.
+         */
+        function getImageType() {
+
+            // Get the image type
+            $type = $this->_getImageType();
+
+            // Raise error about unsupported image type
+            if ( $type === false ) {
+                trigger_error(
+                    'The getImageType function does not support the file format of the file "'
+                    . $this->getAbsolutePath() . '".', YD_ERROR
+                );
+            } else {
+                return $type;
+            }
+
+         }
+
+        /**
+         *	This function is used to output an error image.
+         *
+         *	@param $name	(optional) Name of the error image. Default image that is shown is the generic
+         *					"YD_ydfsimage_fatal_error".
+         *
+         *	@internal
+         */
+        function _error( $name='YD_ydfsimage_fatal_error' ) {
+            $img = new YDFSImage( YD_DIR_HOME . '/images/' . $name . '.gif' );
+            header( 'Content-type: ' . $img->getMimeType() );
+            echo( $img->getContents() );
+            die();
+        }
+
+        /**
+         *	This function will do the actual work of creating a thumbnail image.
+         *
+         *	@param $width	The maximum width of the thumbnail.
+         *	@param $height	The maximum height of the thumbnail.
+         *	@param $cache	(optional) Indicate if the thumbnails should be cached. By default, caching is turned off.
+         *	@param $crop	(optional) Indicate if the thumbnails should be cropped to the exact size. By default, false.
+         *
+         *	@internal
+         */
+        function & _createThumbnail( $width, $height, $cache=true, $crop=false ) {
+
+            // Check if the GD library is loaded.
+            if ( ! extension_loaded( 'gd' ) ) {
+                $this->_error( 'YD_gd_not_installed' );
+            }
+
+            // Width and height should be positive integer
+            if ( $width < 1 || $height < 1 ) {
+                $this->_error();
+            }
+
+            // Get the cache filename
+            $cacheFName = YD_DIR_TEMP . '/' . $this->_createThumbnailName( $width, $height, $crop );
+
+            // Check if caching is enabled
+            if ( $cache === true ) {
+
+                // Output the cached version if any
+                if ( is_file( $cacheFName ) ) {
+                    readfile( $cacheFName );
+                    die();
+                }
+
+            }
+
+            // Check the extension
+            $img_type = $this->isImage();
+
+            // Open the source image
+            if ( $img_type == 'gif' ) {
+                if ( ! function_exists( 'imagecreatefromgif' ) ) {
+                    $this->_error();
+                }
+                $src_img = imagecreatefromgif( $this->getAbsolutePath() );
+            } elseif ( $img_type == 'png' ) {
+                $src_img = imagecreatefrompng( $this->getAbsolutePath() );
+            } elseif ( $img_type == 'bmp' ) {
+                $src_img = imagecreatefrombmp( $this->getAbsolutePath() );
+            } else {
+                $src_img = imagecreatefromjpeg( $this->getAbsolutePath() );
+            }
+
+            // Get the current image size
+            $ori_width  = imageSX( $src_img );
+            $ori_height = imageSY( $src_img );
+
+            // Calculate the new image size
+            if ( $crop ) {
+
+                if ( $ori_width > $ori_height ) {
+                    $thumb_w = ceil( $ori_width * ( $height / $ori_height ) );
+                    $thumb_h = $height;
+                }
+                if ( $ori_width < $ori_height ) {
+                    $thumb_w = $width;
+                    $thumb_h = ceil( $ori_height * ( $width / $ori_width ) );
+                }
+
+            } else {
+
+                if ( $ori_width > $ori_height ) {
+                    $thumb_w = $width;
+                    $thumb_h = ceil( $ori_height * ( $width / $ori_width ) );
+                }
+                if ( $ori_width < $ori_height ) {
+                    $thumb_w = ceil( $ori_width * ( $height / $ori_height ) );
+                    $thumb_h = $height;
+                }
+
+            }
+
+            if ( $ori_width == $ori_height ) {
+                $thumb_w = $width;
+                $thumb_h = $height;
+            }
+
+            if ( ( $width >= $ori_width || $height >= $ori_height ) && ( ! $crop || ( $crop && YDConfig::get( 'YD_FS_CROP' ) != YD_FS_CROP_ENLARGED ) ) ) {
+
+                if ( $width >= $ori_width && $height < $ori_height ) {
+                    $thumb_w = ceil( $ori_width * ( $height / $ori_height ) );
+                    $thumb_h = $height;
+                } else if ( $width < $ori_width && $height >= $ori_height ) {
+                    $thumb_w = $width;
+                    $thumb_h = ceil( $ori_height * ( $width / $ori_width ) );
+                } else {
+                    $thumb_w = $ori_width;
+                    $thumb_h = $ori_height;
+                }
+
+            }
+
+            // Resample the image
+            $dst_img = imagecreatetruecolor( $thumb_w, $thumb_h );
+            if ( $img_type == 'png' ) {
+                imagecopyresized( $dst_img, $src_img, 0, 0, 0, 0, $thumb_w, $thumb_h, $ori_width, $ori_height );
+            } else {
+                imagecopyresampled( $dst_img, $src_img, 0, 0, 0, 0, $thumb_w, $thumb_h, $ori_width, $ori_height );
+            }
+
+            if ( $crop && ( $width != $thumb_w || $height != $thumb_h ) ) {
+
+                $x = ceil( abs( $thumb_w-$width  ) / 2 );
+                $y = ceil( abs( $thumb_h-$height ) / 2 );
+
+                $default = true;
+
+                if ( $ori_width < $width || $ori_height < $height ) {
+
+                    switch ( YDConfig::get( 'YD_FS_CROP', YD_FS_CROP_ENLARGED ) ) {
+
+                        case YD_FS_CROP_UNCHANGED:
+
+                            if ( $ori_width < $width && $ori_height < $height ) {
+                                $crp_img = $dst_img;
+                                $default = false;
+                            } else if ( $ori_width < $width ) {
+                                $x = 0;
+                                $width = $ori_width;
+                            } else if ( $ori_height < $height ) {
+                                $y = 0;
+                                $height = $ori_height;
+                            }
+                            break;
+
+                        case YD_FS_CROP_ENLARGED:
+                        case YD_FS_CROP_BORDERED:
+                            break;
+
+                    }
+
+                }
+
+                if ( $default ) {
+
+                    $crp_img = imagecreatetruecolor( $width, $height );
+
+                    if ( $img_type == 'png' ) {
+                        imagecopyresized( $crp_img, $dst_img, 0, 0, $x, $y, $width, $height, $width, $height );
+                    } else {
+                        imagecopyresampled( $crp_img, $dst_img, 0, 0, $x, $y, $width, $height, $width, $height );
+                    }
+
+                }
+
+                $dst_img = $crp_img;
+
+            }
+
+            // Get the resulting image
+            ob_start();
+            if ( $img_type == 'gif' ) {
+                if ( ! function_exists( 'imagegif' ) ) {
+                    imagepng( $dst_img );
+                } else {
+                    imagegif( $dst_img );
+                }
+            } elseif ( $img_type == 'png' ) {
+                imagepng( $dst_img );
+            } else {
+                imagejpeg( $dst_img );
+            }
+            $image_data = ob_get_contents();
+            ob_end_clean();
+
+            // Destroy the images
+            imagedestroy( $dst_img );
+            imagedestroy( $src_img );
+
+            // Save the cache if needed
+            if ( $cache == true ) {
+                $f = new YDFSFile( $cacheFName, true );
+                $f->setContents( $image_data );
+            }
+
+            // Return the image data
+            return $image_data;
+
+        }
+
+        /**
+         *  This function creates the cache name for thumbnails.
+         *
+         *	@param $width	The maximum width of the thumbnail.
+         *	@param $height	The maximum height of the thumbnail.
+         *	@param $crop	Indicate if is the cropped version.
+         */
+        function _createThumbnailName( $width, $height, $crop ) {
+            $cacheFName = $this->getAbsolutePath() . '/' . $width . '/' . $height . '/' . strval( $crop ) . $this->getLastModified();
+            $cacheFName = YD_TMP_PRE . 'N_' . md5( $cacheFName ) . '.' . strtolower( $this->getExtension() );
+            return $cacheFName;
+        }
+
+    }
+
+    /**
+     *  This class defines a filesystem directory.
+     *
+     *  @ingroup YDFramework
+     */
+    class YDFSDirectory extends YDBase {
+
+        /**
+         *	This is the class constructor of the YDDirectory class.
+         *
+         *	@param $path	(optional) Path of the directory. Default is the current directory.
+         */
+        function YDFSDirectory( $path='.' ) {
+
+            // Initialize YDBase
+            $this->YDBase();
+
+            // Fail if directory
+            if ( ! is_dir( $path ) ) {
+                trigger_error( 'The directory with path "' . $path . '" does not exist.', YD_ERROR );
+            }
+
+            // Save the path
+            $this->_path = realpath( $path );
+
+        }
+
+        /**
+         *	Function to get the basename of the directory. This does not include the path information.
+         *
+         *	@returns	String containing the name of the object.
+         */
+        function getBasename() {
+            return YDPath::getFileName( $this->getAbsolutePath() );
+        }
+
+        /**
+         *	Function to get the full absolute path of the object.
+         *
+         *	@returns	String containing the full absolute path of the object.
+         */
+        function getAbsolutePath() {
+            return $this->getPath();
+        }
+
+        /**
+         *  This function return the number of files that are in the directory.
+         *
+         *  @returns    The number of files in the directory.
+         */
+        function getFileCount(){
+            $total = 0;
+            $dirHandle = opendir( $this->getPath() );
+            while ( false !== ( $file = readdir( $dirHandle ) ) ) {
+                if ( $file != '.' && $file != '..' && is_file( $this->getPath() .'/'. $file ) ) {
+                   $total++;
+                }
+            }
+            closedir( $dirHandle );
+            return $total;
+        }
+
+        /**
+         *  This function return the number of directories that are in the directory.
+         *
+         *  @returns    The number of directories in the directory.
+         */
+        function getDirectoryCount(){
+            $total = 0;
+            $dirHandle = opendir( $this->getPath() );
+            while ( false !== ( $file = readdir( $dirHandle ) ) ) {
+            if ( $file != '.' && $file != '..' && is_dir( $this->getPath() .'/'. $file ) ) {
+                    $total++;
+                }
+            }
+            closedir( $dirHandle );
+            return $total;
+        }
+
+        /**
+         *  Returns the total size of the directory.
+         *
+         *  @param  $recursive  (optional) Recurse into the subdirectories. Default is false.
+         *  @param  $formatted  (optional) If set to true, the filesize will be returned in a human readable format.
+         *  @param  $decimals   (optional) The number of decimals to use for formatting the filesize.
+         *
+         *  @returns    The total size of the directory.
+         */
+        function getSize( $recursive = false, $formatted = false, $decimals = 1 ) {
+            $total = 0;
+            $dirHandle = opendir( $this->getPath() );
+            while ( false !== ( $file = readdir( $dirHandle ) ) ) {
+                if ( $file == '.' || $file == '..') {
+                    continue;
+                }
+                if ( is_file( $this->getPath() .'/'. $file ) ) {
+                    $total += filesize( $this->getPath() .'/'. $file );
+                } else if ( $recursive && is_dir( $this->getPath() .'/'. $file ) ) {
+                    $subdir = new YDFSDirectory( $this->getPath() .'/'. $file );
+                    $total += $subdir->getSize(true, false, $decimals);
+                }
+            }
+            closedir( $dirHandle );
+            if ( ! $formatted ) {
+                return $total;
+            }
+            return YDStringUtil::formatFilesize( $total, $decimals );
+        }
+
+        /**
+         *  Returns the total free space on the partition where this directory lives
+         *
+         *	@param $format	 (Optional) Boolean that defines if free space should be returned as bytes or formated
+         *	@param $decimals (Optional) Decimals to use when free space is formated
+         *
+         *	@returns	The number of bytes available
+         *
+         *	@static
+         */
+        function getFreeSpace( $format = false, $decimals = 1 ) {
+            return YDPath::getFreeSpace( $this->_path, $format, $decimals );
+        }
+
+        /**
+         *	This function will get a file list using a pattern. You can compare this function with the dir command from
+         *	DOS or the ls command from Unix. The pattern syntax is the same as well.
+         *
+         *	@remarks
+         *		This will not work recursively on the subdirectories.
+         *
+         *	@param $pattern	(optional) Pattern to which the files should match. If you want multiple items, you can also
+         *					pass them as an array. If the pattern is prefixed with an exclamation mark, the files that
+         *					match this pattern will not be included in the result.
+         *	@param $class	(optional) If you specify a not null value for this option, this function will return the
+         *					items in the directory as the indicated class. If an empty string is given, it will return
+         *					the list of filenames instead of objects. If a string 'fullpath' is given, it will return
+         *					the list of filenames using the fullpath. If a string 'hash' is given, it will return a list 
+         *					of filenames as a associative array with filename basename has key and filename fullpath has value.
+         *	@param $classes	(optional) An array with the classes to include. Standard, it includes YDFSImage, YDFSFile
+         *					and YDFSDirectory classes. If you only need a single class, you can also specify it as a
+         *					string.
+         *  @param $sort_by_date (optional) Sorts the items by date. Default is false.
+         *  @param $sort_order    (optional) Whether the sort direction is ascending or descending. Default is "ASC".
+         *
+         *	@returns	Array of YDFile objects for the files that match the pattern.
+         */
+        function getContents( $pattern='', $class=null, $classes=array( 'YDFSFile', 'YDFSImage', 'YDFSDirectory' ), $sort_by_date=false, $sort_order='asc' ) {
+
+            // Start with an empty list
+            $fileList = array();
+            $fileListMatch = array();
+
+            // Get the list of patterns
+            if ( ! is_array( $pattern ) ) {
+                $pattern = array( $pattern );
+            }
+
+            // Check if there other patterns than exceptions
+            $hasMoreThanExceptions = false;
+            foreach ( $pattern as $patternitem ) {
+                if ( ! empty( $patternitem ) && substr( $patternitem, 0, 1 ) != '!' ) {
+                    $hasMoreThanExceptions = true;
+                    break;
+                }
+            }
+
+            // Get the files that match
+            if ( $hasMoreThanExceptions == true ) {
+                foreach ( $pattern as $patternitem ) {
+                    if ( ! empty( $patternitem ) && substr( $patternitem, 0, 1 ) != '!' ) {
+                        $glob_files = glob( $this->getAbsolutePath() . '/' . $patternitem );
+                        if ( $glob_files !== false ) {
+                            foreach ( $glob_files as $file ) {
+                                $file = basename( $file );
+                                $fileListMatch[ $file ] = $file;
+                            }
+                        }
+                    } else if ( empty( $patternitem ) ) {
+                        $glob_files = glob( $this->getAbsolutePath() . '/*' );
+                        if ( $glob_files !== false ) {
+                            foreach ( glob( $this->getAbsolutePath() . '/*' ) as $file ) {
+                                $file = basename( $file );
+                                $fileListMatch[ $file ] = $file;
+                            }
+                        }
+                    }
+                }
+            } else {
+                $glob_files = glob( $this->getAbsolutePath() . '/' . '*' );
+                if ( $glob_files !== false ) {
+                    foreach ( $glob_files as $file ) {
+                        $file = basename( $file );
+                        $fileListMatch[ $file ] = $file;
+                    }
+                }
+            }
+            $fileList = & $fileListMatch;
+
+            // Remove the files that don't match
+            foreach ( $pattern as $patternitem ) {
+                if ( ! empty( $patternitem ) && substr( $patternitem, 0, 1 ) == '!' ) {
+                    $glob_files = glob( $this->getAbsolutePath() . '/' . substr( $patternitem, 1 ) );
+                    if ( $glob_files !== false ) {
+                        foreach ( $glob_files as $file ) {
+                            $file = basename( $file );
+                            unset( $fileList[ $file ] );
+                        }
+                    }
+                }
+            }
+
+            // Get the values
+            $fileList = array_values( $fileList );
+
+            // Convert the list of a list of YDFile objects
+            $fileList2 = array();
+            foreach ( $fileList as $file ) {
+                $file = $this->getPath() . '/' . $file;
+                if ( ! is_null( $class ) && $class != '' && $class != 'fullpath' && $class != 'hash' ) {
+                    $fileObj = new $class( $file );
+                } else {
+                    if ( is_dir( $file ) ) {
+                        $fileObj = new YDFSDirectory( $file );
+                    } else {
+                        if ( YDPath::isImage( $file ) ) {
+                            $fileObj = new YDFSImage( $file );
+                        } else {
+                            $fileObj = new YDFSFile( $file );
+                        }
+                    }
+                }
+                if ( $sort_by_date === true ) {
+                    $fileList2[ filectime( $file ) . strtolower( $file ) ] = $fileObj;
+                } else {
+                    $fileList2[ strtolower( $file ) ] = $fileObj;
+                }
+            }
+
+            // Sort the list of files
+            if ( strtolower( $sort_order ) != 'desc' ) {
+                ksort( $fileList2 );
+            } else {
+                krsort( $fileList2 );
+            }
+            $fileList2 = array_values( $fileList2 );
+
+            // Remove the unsupported classes
+            if ( ! is_array( $classes ) ) {
+                $classes = array( $classes );
+            }
+            if ( sizeof( $classes ) == 0 ) {
+                return array();
+            }
+            foreach ( $classes as $key => $val ) {
+                $classes[ $key ] = strtolower( $val );
+            }
+            foreach ( $fileList2 as $key=>$val ) {
+                if ( ! in_array( strtolower( get_class( $val ) ), $classes ) ) {
+                    unset( $fileList2[ $key ] );
+                }
+            }
+
+            // Return a simple list if needed
+            if ( is_string( $class ) ) {
+
+                // Initialize a list for the files only
+                $fileOnlyList = array();
+
+                // Add the files
+                foreach ( $fileList2 as $file ) {
+                    $filename = $class === '' ? basename( $file->_path ) : realpath( $file->_path );
+
+                    if ( $class === 'hash' ){
+                        $fileOnlyList[ basename( $file->_path ) ] = $filename;
+                    }else{
+                        $fileOnlyList[] = $filename;
+                    }
+                }
+
+                // Return the fileOnlyList array
+                return $fileOnlyList;
+
+            }
+
+            // Return the file list
+            return $fileList2;
+
+        }
+
+        /**
+         *  This function will list all the files in this directory, but will also recurse into the subdirectories.
+         *
+         *	@param $pattern	(optional) Pattern to which the files should match. If you want multiple items, you can also
+         *					pass them as an array. If the pattern is prefixed with an exclamation mark, the files that
+         *					match this pattern will not be included in the result.
+         *	@param $class	(optional) If you specify a not null value for this option, this function will return the
+         *					items in the directory as the indicated class. If an empty string is given, it will return
+         *					the list of filenames instead of objects. If a string 'fullpath' is given, it will return
+         *					the list of filenames using the fullpath. If a string 'hash' is given, it will return a list 
+         *					of filenames as a associative array with filename basename has key and filename fullpath has value.
+         *	@param $classes	(optional) An array with the classes to include. Standard, it includes YDFSImage and
+         *					YDFSFile classes. If you only need a single class, you can also specify it as a string.
+         *  @param $sort_by_date (optional) Sorts the items by date. Default is false.
+         *  @param $sort_order    (optional) Whether the sort direction is ascending or descending. Default is "ASC".
+         *  @param $levels        (optional) Integer that defines how deep should the cycle go. Default: -1 (infinite).
+         *
+         *	@returns	Array of YDFile objects for the files that match the pattern.
+         */
+        function getFilesRecursively( $pattern='', $class=null, $classes=array( 'YDFSFile', 'YDFSImage' ), $sort_by_date=false, $sort_order='asc', $levels = -1 ) {
+            $files = array();
+            foreach ( $this->_getSubdirectories( $this->_path, $levels ) as $dir ) {
+                $dir = new YDFSDirectory( $dir );
+                $files = array_merge( $files, $dir->getContents( $pattern, $class, $classes, $sort_by_date, $sort_order ) );
+            }
+            return $files;
+        }
+
+        /**
+         *	Helper function to get the contents of a directory recursively.
+         *
+         *  @param  $path   The path to get the subdirectories from.
+         *  @param  $levels (optional) Integer that defines how deep should the cycle go. Default: -1 (infinite).
+         *
+         *  @returns    The list of subdirectories of the given path.
+         *
+         *  @internal
+         */
+        function _getSubdirectories( $path, $levels = -1 ) {
+            $dirlist = array( $path );
+            if ( $levels == 0 ) return $dirlist;
+            $dirHandle = opendir( $path );
+            while ( false !== ( $file = readdir( $dirHandle ) ) ) {
+                if ( $file != '.' && $file != '..' ) {
+                    if ( is_dir( $path . '/' . $file ) ) {
+                        array_push( $dirlist, $path . '/' . $file );
+                        $dirlist = array_merge( $dirlist, $this->_getSubdirectories( $path . '/' . $file, $levels - 1 ) );
+                    }
+                }
+            }
+            sort( $dirlist );
+            return array_unique( $dirlist );
+        }
+
+        /**
+         *	Function to get the full path of the directory.
+         *
+         *	@returns	String containing the full path of the directory.
+         */
+        function getPath() {
+            return YDPath::getFullPath( $this->_path );
+        }
+
+        /**
+         *  This function returns true if the directory is readable.
+         *
+         *  @returns    Returns true if the directory is readable.
+         */
+        function isReadable(){
+            return is_readable( $this->getPath() );
+        }
+
+        /**
+         *	This function will return true if the directory is writeable, otherwise, it will return false.
+         *
+         *	@remarks
+         *		This only works correctly on Unix based systems.
+         *
+         *	@returns	Boolean indicating if the directory is writeable or not.
+         */
+        function isWriteable() {
+            return is_writable( $this->getPath() );
+        }
+
+        /**
+         *	This function will create a new file in the current directory, and will write the specified contents to the
+         *	file. Once finished, it will return a new YDFSFile object pointing to the file. All directory paths are
+         *	relative to the current directory.
+         *
+         *	@param $filename	The filename of the new file.
+         *	@param $contents	The contents of the new file.
+         *
+         *	@returns	YDFSFile or YDFSImage object pointing to the new file.
+         */
+        function createFile( $filename, $contents ) {
+
+            // Set the directory of this object as the working directory
+            chdir( $this->getPath() );
+
+            // Create the new file
+            $fp = fopen( $filename, 'wb' );
+
+            // Save the contents to the file
+            $result = fwrite( $fp, $contents );
+
+            // Check for errors
+            if ( $result == false ) {
+                trigger_error(
+                    'Failed writing to the file "' . $filename . '" in the directory called "' . $this->getPath() . '".',
+                    YD_ERROR
+                );
+            }
+
+            // Close the file
+            fclose( $fp );
+
+            // Create the YDFSFile object
+            $obj = new YDFSFile( $filename );
+
+            // Check if it's an image
+            if ( $obj->isImage() ) {
+                $obj = new YDFSImage( $filename );
+            }
+
+            // Return the file object
+            return $obj;
+
+        }
+
+        /**
+         *	This function will delete a file from the current directory.
+         *
+         *	@param $filename	The file you want to delete.
+         *	@param $failOnError	(optional) Indicate if a fatal error needs to be raised if deleting the file failed.
+         *
+         *	@return	There are three possible return values for this function. True indicates that the file exists and
+         *			is deleted successfully. False indicates the file exists but could not be deleted. Null indicates
+         *			the file didn't exist and therefor could not be deleted.
+         */
+        function deleteFile( $filename, $failOnError=false ) {
+
+            // Set the directory of this object as the working directory
+            chdir( $this->getPath() );
+
+            // Check if the file exists
+            if ( file_exists( $filename ) ) {
+
+                // Try to delete the file
+                $result = unlink( $filename );
+
+                // Check for errors
+                if ( $result == false ) {
+
+                    // Check if we need to raise an error
+                    if ( $failOnError == true ) {
+                        trigger_error(
+                            'Failed deleting the file "' . $file . '" from the directory "' . $this->getPath() . '".',
+                            YD_ERROR
+                        );
+                    }
+
+                }
+
+
+                // Return if the file was deleted or not
+                return $result;
+
+            }
+
+            // Return null if the file doesn't exist
+            return null;
+
+        }
+
+        /**
+         *	This function will create a new subdirectory in the given directory.
+         *
+         *	@param $directory	Directory to create.
+         *	@param $mode		(optional) The mode for the directory. By default, this is 0700.
+         *
+         *	@returns	False on failure, otherwise, it will return a YDFSDirectory object for the new directory.
+         */
+        function createDirectory( $directory, $mode=0700 ) {
+            $directory = YDPath::join( $this->getAbsolutePath(), $directory );
+            if ( is_dir( $directory ) || mkdir( $directory, $mode ) ) {
+                return new YDFSDirectory( $directory );
+            } else {
+                return false;
+            }
+        }
+
+
+        /**
+         *  This function will recursively create the directories
+         *	@param $directory	Directory to create.
+         *	@param $mode		(optional) The mode for the directory. By default, this is 0700.
+         *
+         *	@returns	False on failure, otherwise, it will return a YDFSDirectory object for the new directory.
+         *
+         *  @static
+         */
+        function createDirectories( $directory, $mode=0700 ) {
+            if ( is_null( $directory ) || $directory === '' ) {
+                return false;
+            }
+            if ( is_dir( $directory ) || $directory === '/' ) {
+                return true;
+            }
+            if ( YDFSDirectory::createDirectories( dirname( $directory ), $mode ) ) {
+                return mkdir( $directory, $mode );
+            }
+            return false;
+        }
+
+        /**
+         *	This function will recursively delete a directory. It will delete the directory and the complete
+         *	contents of that directory! Be careful I would say!
+         *
+         *	@param $directory	Directory to be removed.
+         *
+         *	@return	Boolean indicating if the directory could be deleted or not.
+         */
+        function deleteDirectory( $directory ) {
+            $directory = YDPath::join( $this->getAbsolutePath(), $directory );
+            if ( ! is_dir( $directory ) ) {
+                return false;
+            }
+            return YDFSDirectory::_delete( $directory );
+        }
+
+        /**
+         *	This function will return true if the filesystem object is a directory. In all other cases, it will return
+         *	false.
+         *
+         *	@returns	Boolean indicating if the object is a directory or not.
+         */
+        function isDirectory() {
+            return true;
+        }
+
+        /**
+         *	This function will return true if the filesystem object is an image. In all other cases, it will return
+         *	false.
+         *
+         *	@returns	Boolean indicating if the object is an image or not.
+         */
+        function isImage() {
+            return false;
+        }
+
+        /**
+         *	This function will move the directory to the specified path and update the object accordingly.
+         *
+         *	@param	$path	Target path.
+         *
+         *	@returns	False on a failure, true on success.
+         */
+        function moveDirectory( $path ) {
+            $result = rename( $this->getAbsolutePath(), $path );
+            if ( $result ) {
+                $this->_path = realpath( $path );
+            }
+            return $result;
+        }
+
+        /**
+         *  This function will check if the specified file/or directory exists in the current path.
+         *
+         *  @param $obj     The file or directory you are looking for.
+         *	@param $classes	(optional) An array with the classes to include. Standard, it includes YDFSImage, YDFSFile
+         *					and YDFSDirectory classes. If you only need a single class, you can also specify it as a
+         *					string.
+         *
+         *	@returns	Array of YDFile objects for the files that match the pattern.
+         */
+        function has( $obj, $classes=array( 'YDFSFile', 'YDFSImage', 'YDFSDirectory' ) ) {
+
+            // Get the contents
+            $contents = $this->getContents( $obj, '', $classes );
+
+            // Return the result
+            return ( sizeof( $contents ) == 0 ) ? false : true;
+
+        }
+
+        /**
+         *	Function to recursively delete a directory.
+         *
+         *	@param $dirname	Directory to be removed.
+         *
+         *	@return	Boolean indicating if the directory could be deleted or not.
+         *
+         *	@internal
+         */
+        function _delete( $dirname ) {
+
+            // Simple delete for a file
+            if ( is_file( $dirname ) ) {
+                return unlink( $dirname );
+            }
+
+            // Loop through the folder
+            $dir = dir( $dirname );
+            while ( false !== $entry = $dir->read() ) {
+
+                // Skip pointers
+                if ( $entry == '.' || $entry == '..' ) {
+                    continue;
+                }
+
+                // Deep delete directories
+                if ( is_dir( "$dirname/$entry" ) ) {
+                    YDFSDirectory::_delete( "$dirname/$entry" );
+                } else {
+                    unlink( "$dirname/$entry" );
+                }
+            }
+
+            // Clean up
+            $dir->close();
+            return rmdir( $dirname );
+
+        }
+
+    }
+
 ?>
\ No newline at end of file



From ximian at mail.berlios.de  Mon Sep 10 18:31:33 2007
From: ximian at mail.berlios.de (ximian at mail.berlios.de)
Date: Mon, 10 Sep 2007 18:31:33 +0200
Subject: [ydf-devel] r2478 - YDFramework2.0/trunk/YDFramework2/YDClasses
Message-ID: <200709101631.l8AGVXqt017629@sheep.berlios.de>

Author: ximian
Date: 2007-09-10 18:31:12 +0200 (Mon, 10 Sep 2007)
New Revision: 2478

Modified:
   YDFramework2.0/trunk/YDFramework2/YDClasses/YDValidateRules.php
Log:
on validate rules:
 - FIXED: required for checkboxes
 - NEW: rule alphanumericstrict [a-zA-Z0-9]
 - NEW: rule checkboxgroupvalues to be used in checkboxgroups (to check is elements are valid)
 - NEW: rule not that returns true if elements are not equal
 - NEW: rule isarray to check is a variable is an array

Modified: YDFramework2.0/trunk/YDFramework2/YDClasses/YDValidateRules.php
===================================================================
--- YDFramework2.0/trunk/YDFramework2/YDClasses/YDValidateRules.php	2007-09-10 16:23:31 UTC (rev 2477)
+++ YDFramework2.0/trunk/YDFramework2/YDClasses/YDValidateRules.php	2007-09-10 16:31:12 UTC (rev 2478)
@@ -71,6 +71,11 @@
                 return false;
             }
 
+            // check if is int
+            if ( is_int( $val ) && $val == 0 ){
+                return false;
+            }
+
             // value is ok
             return true;
         }
@@ -256,17 +261,39 @@
             return $result;
         }
 
+
         /**
+         *	This function returns true if the variable contains only letters and numbers
+         *  Strict version - special characters are invalid.
+         *
+         *	@param $val		The value to test.
+         *	@param $opts	(not required)
+         */
+        function alphanumericstrict( $val, $opts='' ) {
+            return YDValidateRules::regex( $val, '/^([a-zA-Z0-9]+)$/' );
+        }
+
+        /**
          *	This function returns true if the variable contains only numbers.
          *
          *	@param $val		The value to test.
          *	@param $opts	(not required)
          */
         function numeric( $val, $opts='' ) {
-            return YDValidateRules::regex( $val, '/(^-?\d\d*\.\d*$)|(^-?\d\d*$)|(^-?\.\d\d*$)/' );
+            return YDValidateRules::regex( strval( $val ), '/(^-?\d\d*\.\d*$)|(^-?\d\d*$)|(^-?\.\d\d*$)/' );
         }
 
         /**
+         *	This function returns true if the variable is an array.
+         *
+         *	@param $val		The value to test.
+         *	@param $opts	(not required)
+         */
+        function isarray( $val, $opts='' ) {
+            return is_array( $val );
+        }
+
+        /**
          *	This function returns true if the variable contains only contains one digit (0-9).
          *
          *	@param $val		The value to test.
@@ -313,7 +340,19 @@
             return $val === $opts;
         }
 
+
         /**
+         *	This function returns true if the variable is not exactly as specified in the options.
+         *
+         *	@param $val		The value to test.
+         *	@param $opts	The value to compare with.
+         */
+        function not( $val, $opts ) {
+            return strval( $val ) != strval( $opts );
+        }
+
+
+        /**
          *	This function returns true if the variable is in the array specified in the options.
          *
          *	@param $val		The value to test.
@@ -815,6 +854,27 @@
         }
 
 
+        /**
+         *	This function returns true if the variable is an array and each element is in opts.
+         *
+         *	@param $val		The value to test.
+         *	@param $opts	The array in which the value should be.
+         */
+        function checkboxgroupvalues( $val, $opts ) {
+
+            if( ! is_array( $val ) || ! is_array( $opts ) ){
+                return false;
+            }
+
+            foreach( $val as $value => $enable ){
+                if( ! in_array( $value, $opts ) || $enable != 'on' ){
+                    return false;
+                }
+            }
+
+            return true;
+        }
+
     }
 
 ?>
\ No newline at end of file



From ximian at mail.berlios.de  Mon Sep 10 18:33:21 2007
From: ximian at mail.berlios.de (ximian at mail.berlios.de)
Date: Mon, 10 Sep 2007 18:33:21 +0200
Subject: [ydf-devel] r2479 - YDFramework2.0/trunk/YDFramework2/YDClasses
Message-ID: <200709101633.l8AGXLW1022943@sheep.berlios.de>

Author: ximian
Date: 2007-09-10 18:33:04 +0200 (Mon, 10 Sep 2007)
New Revision: 2479

Modified:
   YDFramework2.0/trunk/YDFramework2/YDClasses/YDForm.php
Log:
- NEW: added checkboxgroupvalues rule to form object

Modified: YDFramework2.0/trunk/YDFramework2/YDClasses/YDForm.php
===================================================================
--- YDFramework2.0/trunk/YDFramework2/YDClasses/YDForm.php	2007-09-10 16:31:12 UTC (rev 2478)
+++ YDFramework2.0/trunk/YDFramework2/YDClasses/YDForm.php	2007-09-10 16:33:04 UTC (rev 2479)
@@ -194,6 +194,7 @@
             $this->registerRule( 'timezone', array( 'YDValidateRules', 'timezone' ), 'YDValidateRules.php' );
             $this->registerRule( 'country', array( 'YDValidateRules', 'country' ), 'YDValidateRules.php' );
             $this->registerRule( 'state', array( 'YDValidateRules', 'state' ), 'YDValidateRules.php' );
+            $this->registerRule( 'checkboxgroupvalues', array( 'YDValidateRules', 'checkboxgroupvalues' ), 'YDValidateRules.php' );
 
             // Add the filters
             $this->registerFilter( 'trim', 'trim' );



From ximian at mail.berlios.de  Mon Sep 10 18:36:50 2007
From: ximian at mail.berlios.de (ximian at mail.berlios.de)
Date: Mon, 10 Sep 2007 18:36:50 +0200
Subject: [ydf-devel] r2480 -
	YDFramework2.0/trunk/YDFramework2/YDClasses/YDFormElements
Message-ID: <200709101636.l8AGaoqO000057@sheep.berlios.de>

Author: ximian
Date: 2007-09-10 18:36:36 +0200 (Mon, 10 Sep 2007)
New Revision: 2480

Modified:
   YDFramework2.0/trunk/YDFramework2/YDClasses/YDFormElements/YDFormElement_CheckboxGroup.php
Log:
on checkboxgroup:
 - NEW: 'select all' string can be translated
 - NEW: it's possible to use a string in setValue() (usefull when you use strings as options keys)

Modified: YDFramework2.0/trunk/YDFramework2/YDClasses/YDFormElements/YDFormElement_CheckboxGroup.php
===================================================================
--- YDFramework2.0/trunk/YDFramework2/YDClasses/YDFormElements/YDFormElement_CheckboxGroup.php	2007-09-10 16:33:04 UTC (rev 2479)
+++ YDFramework2.0/trunk/YDFramework2/YDClasses/YDFormElements/YDFormElement_CheckboxGroup.php	2007-09-10 16:36:36 UTC (rev 2480)
@@ -34,6 +34,9 @@
     include_once( YD_DIR_HOME_CLS . '/YDForm.php');
     include_once( YD_DIR_HOME_CLS . '/YDFormElements/YDFormElement_Checkbox.php');
 
+    // Custom selectall name
+    YDConfig::set( 'YD_FORMELEMENT_CHKGROUP_SELALL', null, false ); 
+
     /**
      *	This is the class that define a checkbox form element.
      *
@@ -142,7 +145,9 @@
                         $this->_items[$k]->setValue( $v );
                     }
                 }
-            }
+            }elseif( isset( $this->_items[ strval( $val ) ] ) ){
+				$this->_items[ strval( $val ) ]->setValue( 1 );
+			}
         }
 
 
@@ -273,12 +278,15 @@
 				foreach( $this->getValue() as $elem => $value )
 					if ( $value != 1 ){ $selall->setValue(0); break; }
 
-				// check default translation
-				if( !isset( $GLOBALS['t']['select all'] ) ) $GLOBALS['t']['select all'] = 'select all';
-
+				// get global 'select all' parameter
+				$selall_label = YDConfig::get( 'YD_FORMELEMENT_CHKGROUP_SELALL' );
+				if( is_null( $selall_label ) ){
+					$selall_label = t( 'select all' );
+				}
+	
 				// compute button label
-				if ( $this->_position == 'right' ) $selall_html = '<span ' . YDForm::_convertToHtmlAttrib( $this->_addSelectAll_chk_attributes ) . '>' . $selall->toHTML() . '&nbsp;<label for="' . $selall->getAttribute( 'id' ) . '">' . t( 'select all' ) . '</label></span>';
-				else                               $selall_html = '<span ' . YDForm::_convertToHtmlAttrib( $this->_addSelectAll_chk_attributes ) . '><label for="' . $selall->getAttribute( 'id' ) . '">' . t( 'select all' ) . '</label>&nbsp;' . $selall->toHTML() . '</span>';
+				if ( $this->_position == 'right' ) $selall_html = '<span ' . YDForm::_convertToHtmlAttrib( $this->_addSelectAll_chk_attributes ) . '>' . $selall->toHTML() . '&nbsp;<label for="' . $selall->getAttribute( 'id' ) . '">' . $selall_label . '</label></span>';
+				else                               $selall_html = '<span ' . YDForm::_convertToHtmlAttrib( $this->_addSelectAll_chk_attributes ) . '><label for="' . $selall->getAttribute( 'id' ) . '">' . $selall_label . '</label>&nbsp;' . $selall->toHTML() . '</span>';
 			}
 
 			// check if we don't want columns format



From ximian at mail.berlios.de  Mon Sep 10 18:39:44 2007
From: ximian at mail.berlios.de (ximian at mail.berlios.de)
Date: Mon, 10 Sep 2007 18:39:44 +0200
Subject: [ydf-devel] r2481 -
	YDFramework2.0/trunk/YDFramework2/addons/YDDatabaseObject
Message-ID: <200709101639.l8AGdiRH008166@sheep.berlios.de>

Author: ximian
Date: 2007-09-10 18:38:40 +0200 (Mon, 10 Sep 2007)
New Revision: 2481

Modified:
   YDFramework2.0/trunk/YDFramework2/addons/YDDatabaseObject/YDDatabaseObject.php
Log:
on YDDatabaseObject:
 - FIX: return variable as reference

Modified: YDFramework2.0/trunk/YDFramework2/addons/YDDatabaseObject/YDDatabaseObject.php
===================================================================
--- YDFramework2.0/trunk/YDFramework2/addons/YDDatabaseObject/YDDatabaseObject.php	2007-09-10 16:36:36 UTC (rev 2480)
+++ YDFramework2.0/trunk/YDFramework2/addons/YDDatabaseObject/YDDatabaseObject.php	2007-09-10 16:38:40 UTC (rev 2481)
@@ -304,8 +304,8 @@
             $rel_obj = new YDDatabaseObject_Relation( $name, $this->getClassName(), $manytomany,
                                                       $foreign_class, $cross_class );
 
-            return $this->_relations->set( $name, $rel_obj );
-
+            $this->_relations->set( $name, $rel_obj );
+            return $rel_obj;
         }
 
         /**



From ximian at mail.berlios.de  Mon Sep 10 18:44:22 2007
From: ximian at mail.berlios.de (ximian at mail.berlios.de)
Date: Mon, 10 Sep 2007 18:44:22 +0200
Subject: [ydf-devel] r2482 - in
	YDFramework2.0/trunk/YDFramework2/addons/YDAjax: . editors
Message-ID: <200709101644.l8AGiMAe013316@sheep.berlios.de>

Author: ximian
Date: 2007-09-10 18:44:03 +0200 (Mon, 10 Sep 2007)
New Revision: 2482

Modified:
   YDFramework2.0/trunk/YDFramework2/addons/YDAjax/YDAjax.php
   YDFramework2.0/trunk/YDFramework2/addons/YDAjax/editors/YDAjaxEditor.php
   YDFramework2.0/trunk/YDFramework2/addons/YDAjax/xajaxResponse.inc.php
Log:
on YDAjax:
 - simple fixes

Modified: YDFramework2.0/trunk/YDFramework2/addons/YDAjax/YDAjax.php
===================================================================
--- YDFramework2.0/trunk/YDFramework2/addons/YDAjax/YDAjax.php	2007-09-10 16:38:40 UTC (rev 2481)
+++ YDFramework2.0/trunk/YDFramework2/addons/YDAjax/YDAjax.php	2007-09-10 16:44:03 UTC (rev 2482)
@@ -128,6 +128,9 @@
 
 			// add default header to template
 			$this->template->addJavascript( $html, true, false );
+			
+			// array to store events already added
+			$this->_eventsAdded = array();
 		}
 
 
@@ -222,6 +225,23 @@
 		}
 
 
+        /**
+         *	This function sets YDAjax to use a custom js function when invoke/close an ajax connection
+         *
+         *	@param $onopen      Javascript function to invoke when opening the box
+         *	@param $onclose     Javascript function to invoke when closing the box
+         */
+		function useWaitingCode( $onopen, $onclose ){
+
+			// create js functions to show/hide div
+			$waitingMessageCodeFunction  = "xajax.loadingFunction     = " . $onopen  . ";\n";
+			$waitingMessageCodeFunction .= "xajax.doneLoadingFunction = " . $onclose . ";\n";
+
+			// add waiting message code (that invokes the load/done show/hide) to template 'onload' section
+			$this->template->addJavascript( $waitingMessageCodeFunction, false, false );
+		}
+
+
 		// internal method to get a form of an element
 		function & __getForm( $name ){
 
@@ -335,6 +355,17 @@
          */		
 		 function addEvent( $formElementName, $serverFunction, $arguments = null, $event = null, $options = null, $effects = null ){ 
 
+			// compute event signature
+			$sig = $formElementName . serialize( $serverFunction );
+
+			// check if event already added
+			if( in_array( $sig, $this->_eventsAdded ) ){
+				return;
+			}
+
+			// add signature to list
+			$this->_eventsAdded[] = $sig;
+
 			// if formElementName is "*" we want to define a default event (only before responses)
 			if ( $formElementName === "*" )
 				return $this->registerCatchAllFunction( array( $serverFunction[1], $serverFunction[0], $serverFunction[1] ) );
@@ -715,7 +746,7 @@
          *	@param $attribute			(Optional) Optional atribute to apply result (auto-detection by default when using null).
          *	@param $options				(Optional) Aditional options.
          */	
-		function addResult( $formElementName, $result, $attribute = null, $options = array() ){
+		function addResult( $formElementName, & $result, $attribute = null, $options = array() ){
 
 			// if result is a string we must parse it. Javascript strings cannot contain new lines
 			if ( is_string( $result ) ){
@@ -750,7 +781,7 @@
 			$result = 'document.getElementById("' . $formElementName . '").' . $attribute . ' = "' . $result . '";';
 			
 			// assign result to form element using the id
-			return $this->response->addScript( &$result  );
+			return $this->response->addScript( $result );
 		}
 
 

Modified: YDFramework2.0/trunk/YDFramework2/addons/YDAjax/editors/YDAjaxEditor.php
===================================================================
--- YDFramework2.0/trunk/YDFramework2/addons/YDAjax/editors/YDAjaxEditor.php	2007-09-10 16:38:40 UTC (rev 2481)
+++ YDFramework2.0/trunk/YDFramework2/addons/YDAjax/editors/YDAjaxEditor.php	2007-09-10 16:44:03 UTC (rev 2482)
@@ -75,7 +75,7 @@
 		
 			// start by creating an FCKeditor object
 			$js  = "oFCKeditor = new FCKeditor( '" . $htmlID ."' );";
-			
+
 			// set the editor path
 			$js .= "oFCKeditor.BasePath = '" . YDConfig::get( 'YD_AJAXEDITOR_FCKEDITOR_Url' ) . "';";
 			
@@ -89,15 +89,14 @@
 			$js .= 'oFCKeditor.ToolbarSet = "' . YDConfig::get( 'YD_AJAXEDITOR_FCKEDITOR_ToolbarSet' ) . '";';
 
 			// set size and language
-			$js .= "oFCKeditor.Height = 510;";
-			$js .= 'oFCKeditor.Width = "100%";';
+			$js .= "oFCKeditor.Height = 210;";
+			$js .= 'oFCKeditor.Width = "90%";';
 			$js .= 'oFCKeditor.Config["AutoDetectLanguage"] = false;';
 			$js .= 'oFCKeditor.Config["DefaultLanguage"] = "' . YDConfig::get( 'YD_AJAXEDITOR_FCKEDITOR_DefaultLanguage' ) . '";';
 
 
 			// on fckeditor we add a replace method (that will replace the textarea)
 			$js .= "oFCKeditor.ReplaceTextarea();";
-
 			return $js;
 		}
 

Modified: YDFramework2.0/trunk/YDFramework2/addons/YDAjax/xajaxResponse.inc.php
===================================================================
--- YDFramework2.0/trunk/YDFramework2/addons/YDAjax/xajaxResponse.inc.php	2007-09-10 16:38:40 UTC (rev 2481)
+++ YDFramework2.0/trunk/YDFramework2/addons/YDAjax/xajaxResponse.inc.php	2007-09-10 16:44:03 UTC (rev 2482)
@@ -1,360 +1,360 @@
-<?php
-///////////////////////////////////////////////////////////////////////////////
-// xajaxResponse.inc.php :: xajax XML response class
-//
-// xajax version 0.2.3
-// copyright (c) 2005 by Jared White & J. Max Wilson
-// http://www.xajaxproject.org
-//
-// xajax is an open source PHP class library for easily creating powerful
-// PHP-driven, web-based Ajax Applications. Using xajax, you can asynchronously
-// call PHP functions and update the content of your your webpage without
-// reloading the page.
-//
-// xajax is released under the terms of the LGPL license
-// http://www.gnu.org/copyleft/lesser.html#SEC3
-//
-// This library is free software; you can redistribute it and/or
-// modify it under the terms of the GNU Lesser General Public
-// License as published by the Free Software Foundation; either
-// version 2.1 of the License, or (at your option) any later version.
-//
-// This library is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-// Lesser General Public License for more details.
-// 
-// You should have received a copy of the GNU Lesser General Public
-// License along with this library; if not, write to the Free Software
-// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-///////////////////////////////////////////////////////////////////////////////
-
-/*
-   ----------------------------------------------------------------------------
-   | Online documentation for this class is available on the xajax wiki at:   |
-   | http://wiki.xajaxproject.org/Documentation:xajaxResponse.inc.php         |
-   ----------------------------------------------------------------------------
-*/
-
-// The xajaxResponse class is used to created responses to be sent back to your
-// webpage.  A response contains one or more command messages for updating your page.
-// Currently xajax supports 18 kinds of command messages, including some common ones such as:
-// * Assign - sets the specified attribute of an element in your page
-// * Append - appends data to the end of the specified attribute of an element in your page
-// * Prepend - prepends data to the beginning of the specified attribute of an element in your page
-// * Replace - searches for and replaces data in the specified attribute of an element in your page
-// * Script - runs the supplied JavaScript code
-// * Alert - shows an alert box with the supplied message text
-//
-// *Note: elements are identified by their HTML id, so if you don't see your browser HTML display changing from the request, make sure you're using the right id names in your response.
-
-class xajaxResponse
-{
-	var $xml;
-	var $sEncoding;
-	var $bOutputEntities;
-
-	// Constructor. Its main job is to set the character encoding for the response.
-	// $sEncoding is a string containing the character encoding string to use.
-	// $bOutputEntities lets you set if you want special characters in the output
-	//  converted to HTML entities
-	// * Note: to change the character encoding for all of the responses, set the
-	// XAJAX_DEFAULT_ENCODING constant near the beginning of the xajax.inc.php file
-	function xajaxResponse($sEncoding=XAJAX_DEFAULT_CHAR_ENCODING, $bOutputEntities=false)
-	{
-		$this->setCharEncoding($sEncoding);
-		$this->bOutputEntities = $bOutputEntities;
-	}
-	
-	// setCharEncoding() sets the character encoding for the response based on
-	// $sEncoding, which is a string containing the character encoding to use. You
-	// don't need to use this method normally, since the character encoding for the
-	// response gets set automatically based on the XAJAX_DEFAULT_CHAR_ENCODING
-	// constant.
-	function setCharEncoding($sEncoding)
-	{
-		$this->sEncoding = $sEncoding;
-	}
-	
-	// outputEntitiesOn() tells the response object to convert special characters to
-	// HTML entities automatically (only works if the mb_string extension is available).
-	function outputEntitiesOn()
-	{
-		$this->bOutputEntities = true;
-	}
-	
-	// outputEntitiesOff() tells the response object to output special characters
-	// intact. (default behavior)
-	function outputEntitiesOff()
-	{
-		$this->bOutputEntities = false;
-	}
-	
-	// addAssign() adds an assign command message to the XML response
-	// $sTarget is a string containing the id of an HTML element
-	// $sAttribute is the part of the element you wish to modify ("innerHTML", "value", etc.)
-	// $sData is the data you want to set the attribute to
-	// usage: $objResponse->addAssign("contentDiv", "innerHTML", "Some Text");
-	function addAssign($sTarget,$sAttribute,$sData)
-	{
-		$this->xml .= $this->_cmdXML(array("n"=>"as","t"=>$sTarget,"p"=>$sAttribute),$sData);
-	}
-	
-	// addAppend() adds an append command message to the XML response
-	// $sTarget is a string containing the id of an HTML element
-	// $sAttribute is the part of the element you wish to modify ("innerHTML", "value", etc.)
-	// $sData is the data you want to append to the end of the attribute
-	// usage: $objResponse->addAppend("contentDiv", "innerHTML", "Some New Text");
-	function addAppend($sTarget,$sAttribute,$sData)
-	{	
-		$this->xml .= $this->_cmdXML(array("n"=>"ap","t"=>$sTarget,"p"=>$sAttribute),$sData);
-	}
-	
-	// addPrepend() adds an prepend command message to the XML response
-	// $sTarget is a string containing the id of an HTML element
-	// $sAttribute is the part of the element you wish to modify ("innerHTML", "value", etc.)
-	// $sData is the data you want to prepend to the beginning of the attribute
-	// usage: $objResponse->addPrepend("contentDiv", "innerHTML", "Some Starting Text");
-	function addPrepend($sTarget,$sAttribute,$sData)
-	{
-		$this->xml .= $this->_cmdXML(array("n"=>"pp","t"=>$sTarget,"p"=>$sAttribute),$sData);
-	}
-	
-	// addReplace() adds an replace command message to the XML response
-	// $sTarget is a string containing the id of an HTML element
-	// $sAttribute is the part of the element you wish to modify ("innerHTML", "value", etc.)
-	// $sSearch is a string to search for
-	// $sData is a string to replace the search string when found in the attribute
-	// usage: $objResponse->addReplace("contentDiv", "innerHTML", "text", "<b>text</b>");
-	function addReplace($sTarget,$sAttribute,$sSearch,$sData)
-	{
-		$sDta = "<s><![CDATA[$sSearch]]></s><r><![CDATA[$sData]]></r>";
-		$this->xml .= $this->_cmdXML(array("n"=>"rp","t"=>$sTarget,"p"=>$sAttribute),$sDta);
-	}
-	
-	// addClear() adds an clear command message to the XML response
-	// $sTarget is a string containing the id of an HTML element
-	// $sAttribute is the part of the element you wish to clear ("innerHTML", "value", etc.)
-	// usage: $objResponse->addClear("contentDiv", "innerHTML");
-	function addClear($sTarget,$sAttribute)
-	{
-		$this->addAssign($sTarget,$sAttribute,'');
-	}
-	
-	// addAlert() adds an alert command message to the XML response
-	// $sMsg is the text to be displayed in the Javascript alert box
-	// usage: $objResponse->addAlert("This is important information");
-	function addAlert($sMsg)
-	{
-		$this->xml .= $this->_cmdXML(array("n"=>"al"),$sMsg);
-	}
-	
-	// addRedirect() uses the addScript() method to add a Javascript redirect to
-	// another URL
-	// $sURL is the URL to redirect the client browser to
-	// usage: $objResponse->addRedirect("http://www.xajaxproject.org");
-	function addRedirect($sURL)
-	{
-		//we need to parse the query part so that the values are rawurlencode()'ed
-		//can't just use parse_url() cos we could be dealing with a relative URL which
-		//  parse_url() can't deal with.
-		$queryStart = strpos($sURL, '?', strrpos($sURL, '/'));
-		if ($queryStart !== FALSE)
-		{
-			$queryStart++;
-			$queryEnd = strpos($sURL, '#', $queryStart);
-			if ($queryEnd === FALSE)
-				$queryEnd = strlen($sURL);
-			$queryPart = substr($sURL, $queryStart, $queryEnd-$queryStart);
-			parse_str($queryPart, $queryParts);
-			$newQueryPart = "";
-			foreach($queryParts as $key => $value)
-			{
-				$newQueryPart .= rawurlencode($key).'='.rawurlencode($value).ini_get('arg_separator.output');
-			}
-			$sURL = str_replace($queryPart, $newQueryPart, $sURL);
-		}
-		$this->addScript('window.location = "'.$sURL.'";');
-	}
-
-	// addScript() adds a Javascript command message to the XML response
-	// $sJS is a string containing Javascript code to be executed
-	// usage: $objResponse->addScript("var x = prompt('get some text');");
-	function addScript($sJS)
-	{
-		$this->xml .= $this->_cmdXML(array("n"=>"js"),$sJS);
-	}
-	
-	// addRemove() adds a remove element command message to the XML response
-	// $sTarget is a string containing the id of an HTML element to be removed
-	// from your page
-	// usage: $objResponse->addRemove("Div2");
-	function addRemove($sTarget)
-	{
-		$this->xml .= $this->_cmdXML(array("n"=>"rm","t"=>$sTarget),'');
-	}
-	
-	// addCreate() adds a create element command message to the XML response
-	// $sParent is a string containing the id of an HTML element to which the new
-	// element will be appended.
-	// $sTag is the tag to be added
-	// $sId is the id to be assigned to the new element
-	// $sType has been deprecated, use the addCreateInput() method instead
-	// usage: $objResponse->addCreate("parentDiv", "h3", "myid");
-	function addCreate($sParent, $sTag, $sId, $sType="")
-	{
-		if ($sType)
-		{
-			trigger_error("The \$sType parameter of addCreate has been deprecated.  Use the addCreateInput() method instead.", E_USER_WARNING);
-			return;
-		}
-		$this->xml .= $this->_cmdXML(array("n"=>"ce","t"=>$sParent,"p"=>$sId),$sTag);
-	}
-	
-	// addInsert() adds an insert element command message to the XML response
-	// $sBefore is a string containing the id of the child before which the new element
-	// will be inserted
-	// $sTag is the tag to be added
-	// $sId is the id to be assigned to the new element
-	// usage: $objResponse->addInsert("childDiv", "h3", "myid");
-	function addInsert($sBefore, $sTag, $sId)
-	{
-		$this->xml .= $this->_cmdXML(array("n"=>"ie","t"=>$sBefore,"p"=>$sId),$sTag);
-	}
-
-	// addInsertAfter() adds an insert element command message to the XML response
-	// $sAfter is a string containing the id of the child after which the new element
-	// will be inserted
-	// $sTag is the tag to be added
-	// $sId is the id to be assigned to the new element
-	// usage: $objResponse->addInsertAfter("childDiv", "h3", "myid");	
-	function addInsertAfter($sAfter, $sTag, $sId)
-	{
-		$this->xml .= $this->_cmdXML(array("n"=>"ia","t"=>$sAfter,"p"=>$sId),$sTag);
-	}
-	
-	// addCreateInput() adds a create input command message to the XML response
-	// $sParent is a string containing the id of an HTML element to which the new
-	// input will be appended
-	// $sType is the type of input to be created (text, radio, checkbox, etc.)
-	// $sName is the name to be assigned to the new input and the variable name when it is submitted
-	// $sId is the id to be assigned to the new input
-	// usage: $objResponse->addCreateInput("form1", "text", "username", "input1");
-	function addCreateInput($sParent, $sType, $sName, $sId)
-	{
-		$this->xml .= $this->_cmdXML(array("n"=>"ci","t"=>$sParent,"p"=>$sId,"c"=>$sType),$sName);
-	}
-	
-	// addInsertInput() adds an insert input command message to the XML response
-	// $sBefore is a string containing the id of the child before which the new element
-	// will be inserted
-	// $sType is the type of input to be created (text, radio, checkbox, etc.)
-	// $sName is the name to be assigned to the new input and the variable name when it is submitted
-	// $sId is the id to be assigned to the new input
-	// usage: $objResponse->addInsertInput("input5", "text", "username", "input1");
-	function addInsertInput($sBefore, $sType, $sName, $sId)
-	{
-		$this->xml .= $this->_cmdXML(array("n"=>"ii","t"=>$sBefore,"p"=>$sId,"c"=>$sType),$sName);
-	}
-	
-	// addEvent() adds an event command message to the XML response
-	// $sTarget is a string containing the id of an HTML element
-	// $sEvent is the event you wish to set ("click", "mouseover", etc.)
-	// $sScript is the Javascript string you want to the event to invoke
-	// usage: $objResponse->addEvent("contentDiv", "click", "alert(\'Hello World\');");
-	function addEvent($sTarget,$sEvent,$sScript)
-	{
-		$this->xml .= $this->_cmdXML(array("n"=>"ev","t"=>$sTarget,"p"=>$sEvent),$sScript);
-	}
-	
-	// addHandler() adds a handler command message to the XML response
-	// $sTarget is a string containing the id of an HTML element
-	// $sEvent is the event you wish to set ("click", "mouseover", etc.)
-	// $sHandler is a string containing the name of a Javascript function
-	// that will handle the event. Multiple handlers can be added for the same event
-	// usage: $objResponse->addHandler("contentDiv", "click", "content_click");
-	function addHandler($sTarget,$sEvent,$sHandler)
-	{	
-		$this->xml .= $this->_cmdXML(array("n"=>"ah","t"=>$sTarget,"p"=>$sEvent),$sHandler);
-	}
-	
-	// addRemoveHandler() adds a remove handler command message to the XML response
-	// $sTarget is a string containing the id of an HTML element
-	// $sEvent is the event you wish to remove ("click", "mouseover", etc.)
-	// $sHandler is a string containing the name of a Javascript handler function
-	// that you want to remove
-	// usage: $objResponse->addRemoveHandler("contentDiv", "click", "content_click");
-	function addRemoveHandler($sTarget,$sEvent,$sHandler)
-	{	
-		$this->xml .= $this->_cmdXML(array("n"=>"rh","t"=>$sTarget,"p"=>$sEvent),$sHandler);
-	}
-	
-	// addIncludeScript() adds an include script command message to the XML response
-	// $sFileName is a URL of the Javascript file to include
-	// usage: $objResponse->addIncludeScript("functions.js");
-	function addIncludeScript($sFileName)
-	{
-		$this->xml .= $this->_cmdXML(array("n"=>"in"),$sFileName);
-	}
-	
-	// getXML() returns the XML to be returned from your function to the xajax
-	// processor on your page. Since xajax 0.2, you can also return an xajaxResponse
-	// object from your function directly, and xajax will automatically request the
-	// XML using this method call.
-	// usage: return $objResponse->getXML();
-	function getXML()
-	{
-		$sXML = "<?xml version=\"1.0\"";
-		if ($this->sEncoding && strlen(trim($this->sEncoding)) > 0)
-			$sXML .= " encoding=\"".$this->sEncoding."\"";
-		$sXML .= " ?"."><xjx>" . $this->xml . "</xjx>";
-		
-		return $sXML;
-	}
-	
-	// loadXML() adds the commands of the provided response XML output to this
-	// response object
-	// $sXML is the response XML (returned from a getXML() method) to add to the
-	// end of this response object
-	// usage: $r1 = $objResponse1->getXML();
-	//        $objResponse2->loadXML($r1);
-	//        return $objResponse2->getXML();
-	function loadXML($mXML)
-	{
-		if (is_a($mXML, "xajaxResponse")) {
-			$mXML = $mXML->getXML();
-		}
-		$sNewXML = "";
-		$iStartPos = strpos($mXML, "<xjx>") + 5;
-		$sNewXML = substr($mXML, $iStartPos);
-		$iEndPos = strpos($sNewXML, "</xjx>");
-		$sNewXML = substr($sNewXML, 0, $iEndPos);
-		$this->xml .= $sNewXML;
-	}
-
-	// private method, used internally
-	function _cmdXML($aAttributes, $sData)
-	{
-		if ($this->bOutputEntities) {
-			if (function_exists('mb_convert_encoding')) {
-				$sData = call_user_func_array('mb_convert_encoding', array(&$sData, 'HTML-ENTITIES', $this->sEncoding));
-			}
-			else {
-				trigger_error("The xajax XML response output could not be converted to HTML entities because the mb_convert_encoding function is not available", E_USER_NOTICE);
-			}
-		}
-		$xml = "<cmd";
-		foreach($aAttributes as $sAttribute => $sValue)
-			$xml .= " $sAttribute=\"$sValue\"";
-		if ($sData !== null && !stristr($sData,'<![CDATA['))
-			$xml .= "><![CDATA[$sData]]></cmd>";
-		else if ($sData !== null)
-			$xml .= ">$sData</cmd>";
-		else
-			$xml .= "></cmd>";
-		
-		return $xml;
-	}
-	
-}// end class xajaxResponse
-?>
+<?php
+///////////////////////////////////////////////////////////////////////////////
+// xajaxResponse.inc.php :: xajax XML response class
+//
+// xajax version 0.2.3
+// copyright (c) 2005 by Jared White & J. Max Wilson
+// http://www.xajaxproject.org
+//
+// xajax is an open source PHP class library for easily creating powerful
+// PHP-driven, web-based Ajax Applications. Using xajax, you can asynchronously
+// call PHP functions and update the content of your your webpage without
+// reloading the page.
+//
+// xajax is released under the terms of the LGPL license
+// http://www.gnu.org/copyleft/lesser.html#SEC3
+//
+// This library is free software; you can redistribute it and/or
+// modify it under the terms of the GNU Lesser General Public
+// License as published by the Free Software Foundation; either
+// version 2.1 of the License, or (at your option) any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+// Lesser General Public License for more details.
+// 
+// You should have received a copy of the GNU Lesser General Public
+// License along with this library; if not, write to the Free Software
+// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+///////////////////////////////////////////////////////////////////////////////
+
+/*
+   ----------------------------------------------------------------------------
+   | Online documentation for this class is available on the xajax wiki at:   |
+   | http://wiki.xajaxproject.org/Documentation:xajaxResponse.inc.php         |
+   ----------------------------------------------------------------------------
+*/
+
+// The xajaxResponse class is used to created responses to be sent back to your
+// webpage.  A response contains one or more command messages for updating your page.
+// Currently xajax supports 18 kinds of command messages, including some common ones such as:
+// * Assign - sets the specified attribute of an element in your page
+// * Append - appends data to the end of the specified attribute of an element in your page
+// * Prepend - prepends data to the beginning of the specified attribute of an element in your page
+// * Replace - searches for and replaces data in the specified attribute of an element in your page
+// * Script - runs the supplied JavaScript code
+// * Alert - shows an alert box with the supplied message text
+//
+// *Note: elements are identified by their HTML id, so if you don't see your browser HTML display changing from the request, make sure you're using the right id names in your response.
+
+class xajaxResponse
+{
+	var $xml;
+	var $sEncoding;
+	var $bOutputEntities;
+
+	// Constructor. Its main job is to set the character encoding for the response.
+	// $sEncoding is a string containing the character encoding string to use.
+	// $bOutputEntities lets you set if you want special characters in the output
+	//  converted to HTML entities
+	// * Note: to change the character encoding for all of the responses, set the
+	// XAJAX_DEFAULT_ENCODING constant near the beginning of the xajax.inc.php file
+	function xajaxResponse($sEncoding=XAJAX_DEFAULT_CHAR_ENCODING, $bOutputEntities=false)
+	{
+		$this->setCharEncoding($sEncoding);
+		$this->bOutputEntities = $bOutputEntities;
+	}
+	
+	// setCharEncoding() sets the character encoding for the response based on
+	// $sEncoding, which is a string containing the character encoding to use. You
+	// don't need to use this method normally, since the character encoding for the
+	// response gets set automatically based on the XAJAX_DEFAULT_CHAR_ENCODING
+	// constant.
+	function setCharEncoding($sEncoding)
+	{
+		$this->sEncoding = $sEncoding;
+	}
+	
+	// outputEntitiesOn() tells the response object to convert special characters to
+	// HTML entities automatically (only works if the mb_string extension is available).
+	function outputEntitiesOn()
+	{
+		$this->bOutputEntities = true;
+	}
+	
+	// outputEntitiesOff() tells the response object to output special characters
+	// intact. (default behavior)
+	function outputEntitiesOff()
+	{
+		$this->bOutputEntities = false;
+	}
+	
+	// addAssign() adds an assign command message to the XML response
+	// $sTarget is a string containing the id of an HTML element
+	// $sAttribute is the part of the element you wish to modify ("innerHTML", "value", etc.)
+	// $sData is the data you want to set the attribute to
+	// usage: $objResponse->addAssign("contentDiv", "innerHTML", "Some Text");
+	function addAssign($sTarget,$sAttribute,$sData)
+	{
+		$this->xml .= $this->_cmdXML(array("n"=>"as","t"=>$sTarget,"p"=>$sAttribute),$sData);
+	}
+	
+	// addAppend() adds an append command message to the XML response
+	// $sTarget is a string containing the id of an HTML element
+	// $sAttribute is the part of the element you wish to modify ("innerHTML", "value", etc.)
+	// $sData is the data you want to append to the end of the attribute
+	// usage: $objResponse->addAppend("contentDiv", "innerHTML", "Some New Text");
+	function addAppend($sTarget,$sAttribute,$sData)
+	{	
+		$this->xml .= $this->_cmdXML(array("n"=>"ap","t"=>$sTarget,"p"=>$sAttribute),$sData);
+	}
+	
+	// addPrepend() adds an prepend command message to the XML response
+	// $sTarget is a string containing the id of an HTML element
+	// $sAttribute is the part of the element you wish to modify ("innerHTML", "value", etc.)
+	// $sData is the data you want to prepend to the beginning of the attribute
+	// usage: $objResponse->addPrepend("contentDiv", "innerHTML", "Some Starting Text");
+	function addPrepend($sTarget,$sAttribute,$sData)
+	{
+		$this->xml .= $this->_cmdXML(array("n"=>"pp","t"=>$sTarget,"p"=>$sAttribute),$sData);
+	}
+	
+	// addReplace() adds an replace command message to the XML response
+	// $sTarget is a string containing the id of an HTML element
+	// $sAttribute is the part of the element you wish to modify ("innerHTML", "value", etc.)
+	// $sSearch is a string to search for
+	// $sData is a string to replace the search string when found in the attribute
+	// usage: $objResponse->addReplace("contentDiv", "innerHTML", "text", "<b>text</b>");
+	function addReplace($sTarget,$sAttribute,$sSearch,$sData)
+	{
+		$sDta = "<s><![CDATA[$sSearch]]></s><r><![CDATA[$sData]]></r>";
+		$this->xml .= $this->_cmdXML(array("n"=>"rp","t"=>$sTarget,"p"=>$sAttribute),$sDta);
+	}
+	
+	// addClear() adds an clear command message to the XML response
+	// $sTarget is a string containing the id of an HTML element
+	// $sAttribute is the part of the element you wish to clear ("innerHTML", "value", etc.)
+	// usage: $objResponse->addClear("contentDiv", "innerHTML");
+	function addClear($sTarget,$sAttribute)
+	{
+		$this->addAssign($sTarget,$sAttribute,'');
+	}
+	
+	// addAlert() adds an alert command message to the XML response
+	// $sMsg is the text to be displayed in the Javascript alert box
+	// usage: $objResponse->addAlert("This is important information");
+	function addAlert($sMsg)
+	{
+		$this->xml .= $this->_cmdXML(array("n"=>"al"),$sMsg);
+	}
+	
+	// addRedirect() uses the addScript() method to add a Javascript redirect to
+	// another URL
+	// $sURL is the URL to redirect the client browser to
+	// usage: $objResponse->addRedirect("http://www.xajaxproject.org");
+	function addRedirect($sURL)
+	{
+		//we need to parse the query part so that the values are rawurlencode()'ed
+		//can't just use parse_url() cos we could be dealing with a relative URL which
+		//  parse_url() can't deal with.
+		$queryStart = strpos($sURL, '?', strrpos($sURL, '/'));
+		if ($queryStart !== FALSE)
+		{
+			$queryStart++;
+			$queryEnd = strpos($sURL, '#', $queryStart);
+			if ($queryEnd === FALSE)
+				$queryEnd = strlen($sURL);
+			$queryPart = substr($sURL, $queryStart, $queryEnd-$queryStart);
+			parse_str($queryPart, $queryParts);
+			$newQueryPart = "";
+			foreach($queryParts as $key => $value)
+			{
+				$newQueryPart .= rawurlencode($key).'='.rawurlencode($value).ini_get('arg_separator.output');
+			}
+			$sURL = str_replace($queryPart, $newQueryPart, $sURL);
+		}
+		$this->addScript('window.location = "'.$sURL.'";');
+	}
+
+	// addScript() adds a Javascript command message to the XML response
+	// $sJS is a string containing Javascript code to be executed
+	// usage: $objResponse->addScript("var x = prompt('get some text');");
+	function addScript(& $sJS)
+	{
+		$this->xml .= $this->_cmdXML(array("n"=>"js"),$sJS);
+	}
+	
+	// addRemove() adds a remove element command message to the XML response
+	// $sTarget is a string containing the id of an HTML element to be removed
+	// from your page
+	// usage: $objResponse->addRemove("Div2");
+	function addRemove($sTarget)
+	{
+		$this->xml .= $this->_cmdXML(array("n"=>"rm","t"=>$sTarget),'');
+	}
+	
+	// addCreate() adds a create element command message to the XML response
+	// $sParent is a string containing the id of an HTML element to which the new
+	// element will be appended.
+	// $sTag is the tag to be added
+	// $sId is the id to be assigned to the new element
+	// $sType has been deprecated, use the addCreateInput() method instead
+	// usage: $objResponse->addCreate("parentDiv", "h3", "myid");
+	function addCreate($sParent, $sTag, $sId, $sType="")
+	{
+		if ($sType)
+		{
+			trigger_error("The \$sType parameter of addCreate has been deprecated.  Use the addCreateInput() method instead.", E_USER_WARNING);
+			return;
+		}
+		$this->xml .= $this->_cmdXML(array("n"=>"ce","t"=>$sParent,"p"=>$sId),$sTag);
+	}
+	
+	// addInsert() adds an insert element command message to the XML response
+	// $sBefore is a string containing the id of the child before which the new element
+	// will be inserted
+	// $sTag is the tag to be added
+	// $sId is the id to be assigned to the new element
+	// usage: $objResponse->addInsert("childDiv", "h3", "myid");
+	function addInsert($sBefore, $sTag, $sId)
+	{
+		$this->xml .= $this->_cmdXML(array("n"=>"ie","t"=>$sBefore,"p"=>$sId),$sTag);
+	}
+
+	// addInsertAfter() adds an insert element command message to the XML response
+	// $sAfter is a string containing the id of the child after which the new element
+	// will be inserted
+	// $sTag is the tag to be added
+	// $sId is the id to be assigned to the new element
+	// usage: $objResponse->addInsertAfter("childDiv", "h3", "myid");	
+	function addInsertAfter($sAfter, $sTag, $sId)
+	{
+		$this->xml .= $this->_cmdXML(array("n"=>"ia","t"=>$sAfter,"p"=>$sId),$sTag);
+	}
+	
+	// addCreateInput() adds a create input command message to the XML response
+	// $sParent is a string containing the id of an HTML element to which the new
+	// input will be appended
+	// $sType is the type of input to be created (text, radio, checkbox, etc.)
+	// $sName is the name to be assigned to the new input and the variable name when it is submitted
+	// $sId is the id to be assigned to the new input
+	// usage: $objResponse->addCreateInput("form1", "text", "username", "input1");
+	function addCreateInput($sParent, $sType, $sName, $sId)
+	{
+		$this->xml .= $this->_cmdXML(array("n"=>"ci","t"=>$sParent,"p"=>$sId,"c"=>$sType),$sName);
+	}
+	
+	// addInsertInput() adds an insert input command message to the XML response
+	// $sBefore is a string containing the id of the child before which the new element
+	// will be inserted
+	// $sType is the type of input to be created (text, radio, checkbox, etc.)
+	// $sName is the name to be assigned to the new input and the variable name when it is submitted
+	// $sId is the id to be assigned to the new input
+	// usage: $objResponse->addInsertInput("input5", "text", "username", "input1");
+	function addInsertInput($sBefore, $sType, $sName, $sId)
+	{
+		$this->xml .= $this->_cmdXML(array("n"=>"ii","t"=>$sBefore,"p"=>$sId,"c"=>$sType),$sName);
+	}
+	
+	// addEvent() adds an event command message to the XML response
+	// $sTarget is a string containing the id of an HTML element
+	// $sEvent is the event you wish to set ("click", "mouseover", etc.)
+	// $sScript is the Javascript string you want to the event to invoke
+	// usage: $objResponse->addEvent("contentDiv", "click", "alert(\'Hello World\');");
+	function addEvent($sTarget,$sEvent,$sScript)
+	{
+		$this->xml .= $this->_cmdXML(array("n"=>"ev","t"=>$sTarget,"p"=>$sEvent),$sScript);
+	}
+	
+	// addHandler() adds a handler command message to the XML response
+	// $sTarget is a string containing the id of an HTML element
+	// $sEvent is the event you wish to set ("click", "mouseover", etc.)
+	// $sHandler is a string containing the name of a Javascript function
+	// that will handle the event. Multiple handlers can be added for the same event
+	// usage: $objResponse->addHandler("contentDiv", "click", "content_click");
+	function addHandler($sTarget,$sEvent,$sHandler)
+	{	
+		$this->xml .= $this->_cmdXML(array("n"=>"ah","t"=>$sTarget,"p"=>$sEvent),$sHandler);
+	}
+	
+	// addRemoveHandler() adds a remove handler command message to the XML response
+	// $sTarget is a string containing the id of an HTML element
+	// $sEvent is the event you wish to remove ("click", "mouseover", etc.)
+	// $sHandler is a string containing the name of a Javascript handler function
+	// that you want to remove
+	// usage: $objResponse->addRemoveHandler("contentDiv", "click", "content_click");
+	function addRemoveHandler($sTarget,$sEvent,$sHandler)
+	{	
+		$this->xml .= $this->_cmdXML(array("n"=>"rh","t"=>$sTarget,"p"=>$sEvent),$sHandler);
+	}
+	
+	// addIncludeScript() adds an include script command message to the XML response
+	// $sFileName is a URL of the Javascript file to include
+	// usage: $objResponse->addIncludeScript("functions.js");
+	function addIncludeScript($sFileName)
+	{
+		$this->xml .= $this->_cmdXML(array("n"=>"in"),$sFileName);
+	}
+	
+	// getXML() returns the XML to be returned from your function to the xajax
+	// processor on your page. Since xajax 0.2, you can also return an xajaxResponse
+	// object from your function directly, and xajax will automatically request the
+	// XML using this method call.
+	// usage: return $objResponse->getXML();
+	function getXML()
+	{
+		$sXML = "<?xml version=\"1.0\"";
+		if ($this->sEncoding && strlen(trim($this->sEncoding)) > 0)
+			$sXML .= " encoding=\"".$this->sEncoding."\"";
+		$sXML .= " ?"."><xjx>" . $this->xml . "</xjx>";
+		
+		return $sXML;
+	}
+	
+	// loadXML() adds the commands of the provided response XML output to this
+	// response object
+	// $sXML is the response XML (returned from a getXML() method) to add to the
+	// end of this response object
+	// usage: $r1 = $objResponse1->getXML();
+	//        $objResponse2->loadXML($r1);
+	//        return $objResponse2->getXML();
+	function loadXML($mXML)
+	{
+		if (is_a($mXML, "xajaxResponse")) {
+			$mXML = $mXML->getXML();
+		}
+		$sNewXML = "";
+		$iStartPos = strpos($mXML, "<xjx>") + 5;
+		$sNewXML = substr($mXML, $iStartPos);
+		$iEndPos = strpos($sNewXML, "</xjx>");
+		$sNewXML = substr($sNewXML, 0, $iEndPos);
+		$this->xml .= $sNewXML;
+	}
+
+	// private method, used internally
+	function _cmdXML($aAttributes, & $sData)
+	{
+		if ($this->bOutputEntities) {
+			if (function_exists('mb_convert_encoding')) {
+				$sData = call_user_func_array('mb_convert_encoding', array(&$sData, 'HTML-ENTITIES', $this->sEncoding));
+			}
+			else {
+				trigger_error("The xajax XML response output could not be converted to HTML entities because the mb_convert_encoding function is not available", E_USER_NOTICE);
+			}
+		}
+		$xml = "<cmd";
+		foreach($aAttributes as $sAttribute => $sValue)
+			$xml .= " $sAttribute=\"$sValue\"";
+		if ($sData !== null )//&& !strstr($sData,'<![CDATA['))
+			$xml .= "><![CDATA[$sData]]></cmd>";
+		else if ($sData !== null)
+			$xml .= ">$sData</cmd>";
+		else
+			$xml .= "></cmd>";
+		
+		return $xml;
+	}
+	
+}// end class xajaxResponse
+?>



From ximian at mail.berlios.de  Wed Sep 12 03:17:05 2007
From: ximian at mail.berlios.de (ximian at mail.berlios.de)
Date: Wed, 12 Sep 2007 03:17:05 +0200
Subject: [ydf-devel] r2483 -
	YDFramework2.0/trunk/YDFramework2/YDClasses/YDFormElements
Message-ID: <200709120117.l8C1H5Ln012403@sheep.berlios.de>

Author: ximian
Date: 2007-09-12 03:16:56 +0200 (Wed, 12 Sep 2007)
New Revision: 2483

Modified:
   YDFramework2.0/trunk/YDFramework2/YDClasses/YDFormElements/YDFormElement_Select.php
Log:
on select form element:
 - FIX: generic form element already converts options

Modified: YDFramework2.0/trunk/YDFramework2/YDClasses/YDFormElements/YDFormElement_Select.php
===================================================================
--- YDFramework2.0/trunk/YDFramework2/YDClasses/YDFormElements/YDFormElement_Select.php	2007-09-10 16:44:03 UTC (rev 2482)
+++ YDFramework2.0/trunk/YDFramework2/YDClasses/YDFormElements/YDFormElement_Select.php	2007-09-12 01:16:56 UTC (rev 2483)
@@ -59,9 +59,6 @@
 
             // Indicate if filters need to be applied
             $this->_applyFilters = false;
-
-            // If options is just an element we should add create an array with it
-            if( !is_array( $options ) ) $this->_options = array( $options );
         }
 
         /**



From ximian at mail.berlios.de  Wed Sep 12 03:18:33 2007
From: ximian at mail.berlios.de (ximian at mail.berlios.de)
Date: Wed, 12 Sep 2007 03:18:33 +0200
Subject: [ydf-devel] r2484 - YDFramework2.0/trunk/YDFramework2/YDClasses
Message-ID: <200709120118.l8C1IXX2013263@sheep.berlios.de>

Author: ximian
Date: 2007-09-12 03:18:22 +0200 (Wed, 12 Sep 2007)
New Revision: 2484

Modified:
   YDFramework2.0/trunk/YDFramework2/YDClasses/YDForm.php
Log:
on YDForm:
 - NEW: rule 'alphanumericstrict' available

Modified: YDFramework2.0/trunk/YDFramework2/YDClasses/YDForm.php
===================================================================
--- YDFramework2.0/trunk/YDFramework2/YDClasses/YDForm.php	2007-09-12 01:16:56 UTC (rev 2483)
+++ YDFramework2.0/trunk/YDFramework2/YDClasses/YDForm.php	2007-09-12 01:18:22 UTC (rev 2484)
@@ -165,6 +165,7 @@
             $this->registerRule( 'lettersonly', array( 'YDValidateRules', 'lettersonly' ), 'YDValidateRules.php' );
             $this->registerRule( 'character', array( 'YDValidateRules', 'character' ), 'YDValidateRules.php' );
             $this->registerRule( 'alphanumeric', array( 'YDValidateRules', 'alphanumeric' ), 'YDValidateRules.php' );
+            $this->registerRule( 'alphanumericstrict', array( 'YDValidateRules', 'alphanumericstrict' ), 'YDValidateRules.php' );
             $this->registerRule( 'numeric', array( 'YDValidateRules', 'numeric' ), 'YDValidateRules.php' );
             $this->registerRule( 'digit', array( 'YDValidateRules', 'digit' ), 'YDValidateRules.php' );
             $this->registerRule( 'nopunctuation', array( 'YDValidateRules', 'nopunctuation' ), 'YDValidateRules.php' );



From ximian at mail.berlios.de  Sat Sep 29 00:26:06 2007
From: ximian at mail.berlios.de (ximian at mail.berlios.de)
Date: Sat, 29 Sep 2007 00:26:06 +0200
Subject: [ydf-devel] r2485 - YDFramework2.0/trunk/YDFramework2
Message-ID: <200709282226.l8SMQ6WS029801@sheep.berlios.de>

Author: ximian
Date: 2007-09-29 00:25:13 +0200 (Sat, 29 Sep 2007)
New Revision: 2485

Modified:
   YDFramework2.0/trunk/YDFramework2/YDF2_init.php
Log:
- added comment about putenv ( this env var in not used in php4 )

Modified: YDFramework2.0/trunk/YDFramework2/YDF2_init.php
===================================================================
--- YDFramework2.0/trunk/YDFramework2/YDF2_init.php	2007-09-12 01:18:22 UTC (rev 2484)
+++ YDFramework2.0/trunk/YDFramework2/YDF2_init.php	2007-09-28 22:25:13 UTC (rev 2485)
@@ -556,7 +556,7 @@
                 $_ENV["LC_ALL"]     = $locale;
 
                 // added php5 environment flag
-                putenv( "LANGUAGE=" . $locale );
+                @putenv( "LANGUAGE=" . $locale );
 
                 // set gettext domain
                 bindtextdomain( $domain, $directory );



From ximian at mail.berlios.de  Sat Sep 29 00:28:14 2007
From: ximian at mail.berlios.de (ximian at mail.berlios.de)
Date: Sat, 29 Sep 2007 00:28:14 +0200
Subject: [ydf-devel] r2486 - YDFramework2.0/trunk/YDFramework2/YDClasses
Message-ID: <200709282228.l8SMSEqi029860@sheep.berlios.de>

Author: ximian
Date: 2007-09-29 00:27:56 +0200 (Sat, 29 Sep 2007)
New Revision: 2486

Modified:
   YDFramework2.0/trunk/YDFramework2/YDClasses/YDFileSystem.php
Log:
- FIX: getFreeSpace should use a directory as argument ( on some php env files can throw errors ).

Modified: YDFramework2.0/trunk/YDFramework2/YDClasses/YDFileSystem.php
===================================================================
--- YDFramework2.0/trunk/YDFramework2/YDClasses/YDFileSystem.php	2007-09-28 22:25:13 UTC (rev 2485)
+++ YDFramework2.0/trunk/YDFramework2/YDClasses/YDFileSystem.php	2007-09-28 22:27:56 UTC (rev 2486)
@@ -215,7 +215,7 @@
         function getFreeSpace( $path, $format = false, $decimals = 1 ) {
 
             // get free disk space on the path
-            $space = disk_free_space( $path );
+            $space = disk_free_space( dirname( $path ) );
 
             // return number of bytes if we don't want to format
             if ( $format == false ) return $space;



From ximian at mail.berlios.de  Sat Sep 29 00:30:00 2007
From: ximian at mail.berlios.de (ximian at mail.berlios.de)
Date: Sat, 29 Sep 2007 00:30:00 +0200
Subject: [ydf-devel] r2487 - YDFramework2.0/trunk/YDFramework2/YDClasses
Message-ID: <200709282230.l8SMU0pA029890@sheep.berlios.de>

Author: ximian
Date: 2007-09-29 00:29:50 +0200 (Sat, 29 Sep 2007)
New Revision: 2487

Modified:
   YDFramework2.0/trunk/YDFramework2/YDClasses/YDValidateRules.php
Log:
- NEW: rule 'rangevalue' to check if a numeric variable value is between two (min and max) values.

Modified: YDFramework2.0/trunk/YDFramework2/YDClasses/YDValidateRules.php
===================================================================
--- YDFramework2.0/trunk/YDFramework2/YDClasses/YDValidateRules.php	2007-09-28 22:27:56 UTC (rev 2486)
+++ YDFramework2.0/trunk/YDFramework2/YDClasses/YDValidateRules.php	2007-09-28 22:29:50 UTC (rev 2487)
@@ -875,6 +875,21 @@
             return true;
         }
 
+
+        /**
+         *	This function returns true if the variable value is contained in the indicated range.
+         *
+         *	@param $val		The value to test.
+         *	@param $opts	Array containing the minimum and maximum values.
+         */
+        function rangevalue( $val, $opts ) {
+            if ( ( floatval( $val ) >= floatval( $opts[0] ) ) && ( floatval( $val ) <= floatval( $opts[1] ) ) ) {
+                return true;
+            } else {
+                return false;
+            }
+        }
+
     }
 
 ?>
\ No newline at end of file



From ximian at mail.berlios.de  Sat Sep 29 00:34:30 2007
From: ximian at mail.berlios.de (ximian at mail.berlios.de)
Date: Sat, 29 Sep 2007 00:34:30 +0200
Subject: [ydf-devel] r2488 -
	YDFramework2.0/trunk/YDFramework2/addons/YDDatabaseObjectTree
Message-ID: <200709282234.l8SMYUTT011413@sheep.berlios.de>

Author: ximian
Date: 2007-09-29 00:34:16 +0200 (Sat, 29 Sep 2007)
New Revision: 2488

Modified:
   YDFramework2.0/trunk/YDFramework2/addons/YDDatabaseObjectTree/YDDatabaseObjectTree.php
Log:
- ENH: on YDDatabaseObjectTree, if a node moves to a undefined parent, the parent id will be defined (instead of null).
       This is an exception that should be checked before move. Anyway, YDDatabaseObjectTree will not set empty values anymore.

Modified: YDFramework2.0/trunk/YDFramework2/addons/YDDatabaseObjectTree/YDDatabaseObjectTree.php
===================================================================
--- YDFramework2.0/trunk/YDFramework2/addons/YDDatabaseObjectTree/YDDatabaseObjectTree.php	2007-09-28 22:29:50 UTC (rev 2487)
+++ YDFramework2.0/trunk/YDFramework2/addons/YDDatabaseObjectTree/YDDatabaseObjectTree.php	2007-09-28 22:34:16 UTC (rev 2488)
@@ -151,7 +151,7 @@
          *  @param $class   (optional) Relation name
          *  @param $prefix  (optional) Adds the relation's vars as prefixes to the keys. Default: false.
          *
-         *  @returns An object containing the node's data, or false if node not found
+         *  @returns An array containing the node's data, or false if node not found
          */
         function getNode( $id, $field = null, $class = null, $prefix = false ) {
 
@@ -171,7 +171,7 @@
          *  @param $class   (optional) Relation name
          *  @param $prefix  (optional) Adds the relation's vars as prefixes to the keys. Default: true.
          *
-         *  @returns An object containing the node's data, or false if node not found
+         *  @returns An array containing the node's data, or false if node not found
          */
         function _getNode( $id, $field = null, $class = null, $prefix = true ) {
 
@@ -785,9 +785,14 @@
 				$this->update( array(), $this->__position );
 			}
 
-			// compute lineage
-			if ( $new_parent_id == 1 ) $new_lineage = '//';
-			else                       $new_lineage = $new_parent_node[ $this->__lineage ] . $new_parent_id . '/';
+			// compute lineage. check if new parent id is root, if new parent is defined but node don't exist in db, or normal
+			if ( $new_parent_id == 1 ){
+				$new_lineage = '//';
+			}elseif( $new_parent_node == false ){
+				$new_lineage = '//' . $new_parent_id . '/';
+			}else{
+				$new_lineage = $new_parent_node[ $this->__lineage ] . $new_parent_id . '/';
+			}
 
 			// update node
 			$this->resetAll();



From ximian at mail.berlios.de  Sat Sep 29 20:32:32 2007
From: ximian at mail.berlios.de (ximian at mail.berlios.de)
Date: Sat, 29 Sep 2007 20:32:32 +0200
Subject: [ydf-devel] r2489 - YDFramework2.0/trunk/YDFramework2/YDClasses
Message-ID: <200709291832.l8TIWW7I023766@sheep.berlios.de>

Author: ximian
Date: 2007-09-29 20:32:15 +0200 (Sat, 29 Sep 2007)
New Revision: 2489

Modified:
   YDFramework2.0/trunk/YDFramework2/YDClasses/YDUtil.php
Log:
on YDStringUtil:
 - new feature: YDStringUtil::generatePassword accepts a optional max length for password generation

Modified: YDFramework2.0/trunk/YDFramework2/YDClasses/YDUtil.php
===================================================================
--- YDFramework2.0/trunk/YDFramework2/YDClasses/YDUtil.php	2007-09-28 22:34:16 UTC (rev 2488)
+++ YDFramework2.0/trunk/YDFramework2/YDClasses/YDUtil.php	2007-09-29 18:32:15 UTC (rev 2489)
@@ -1008,12 +1008,18 @@
         /**
          *  Creates a random password string
          *
-         *  @param  $length   Password length. By default 6
+         *  @param  $length		Password length. By default 6
+         *  @param  $lengthmax	(Optional) Password max length. If defined, a password length between $length and $maxlength will be generated.
          *
          *  @returns    String
          */
-        function generatePassword( $length = 6 ) {
+        function generatePassword( $length = 6, $lengthmax = null ) {
 
+            // check length
+            if( ! is_null( $lengthmax ) ){
+                $length = rand( $length, $lengthmax );
+            }
+
             $chrs = "abcdefg12345hijklmnpABCDEFGHIJKLMNPqrstuvwxyzQRSTUVWXYZ6789";
 
             // init generator ( used when php version is smaller than 4.2.0 )



