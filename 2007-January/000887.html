<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [ydf-devel] r2295 - in YDFramework2.0/trunk/examples: . adobe_spry
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/ydframework-devel/2007-January/index.html" >
   <LINK REL="made" HREF="mailto:ydframework-devel%40lists.berlios.de?Subject=Re%3A%20%5Bydf-devel%5D%20r2295%20-%20in%20YDFramework2.0/trunk/examples%3A%20.%20adobe_spry&In-Reply-To=%3C200701031251.l03CpN1F015065%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000886.html">
   <LINK REL="Next"  HREF="000888.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[ydf-devel] r2295 - in YDFramework2.0/trunk/examples: . adobe_spry</H1>
    <B>pclaerhout at BerliOS</B> 
    <A HREF="mailto:ydframework-devel%40lists.berlios.de?Subject=Re%3A%20%5Bydf-devel%5D%20r2295%20-%20in%20YDFramework2.0/trunk/examples%3A%20.%20adobe_spry&In-Reply-To=%3C200701031251.l03CpN1F015065%40sheep.berlios.de%3E"
       TITLE="[ydf-devel] r2295 - in YDFramework2.0/trunk/examples: . adobe_spry">pclaerhout at mail.berlios.de
       </A><BR>
    <I>Wed Jan  3 13:51:23 CET 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000886.html">[ydf-devel] r2294 - YDFramework2.0/trunk/YDFramework2/YDClasses
</A></li>
        <LI>Next message: <A HREF="000888.html">[ydf-devel] r2296 - in YDFramework2.0/trunk/YDFramework2: .	YDClasses YDClasses/YDDatabaseDrivers
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#887">[ date ]</a>
              <a href="thread.html#887">[ thread ]</a>
              <a href="subject.html#887">[ subject ]</a>
              <a href="author.html#887">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: pclaerhout
Date: 2007-01-03 13:51:22 +0100 (Wed, 03 Jan 2007)
New Revision: 2295

Added:
   YDFramework2.0/trunk/examples/adobe_spry/
   YDFramework2.0/trunk/examples/adobe_spry/SpryData.js
   YDFramework2.0/trunk/examples/adobe_spry/index.php
   YDFramework2.0/trunk/examples/adobe_spry/index.tpl
   YDFramework2.0/trunk/examples/adobe_spry/xpath.js
Modified:
   YDFramework2.0/trunk/examples/index.tpl
Log:
Added an example on how to use Adobe Spry with the Yellow Duck Framework.

Added: YDFramework2.0/trunk/examples/adobe_spry/SpryData.js
===================================================================
--- YDFramework2.0/trunk/examples/adobe_spry/SpryData.js	2007-01-03 12:50:04 UTC (rev 2294)
+++ YDFramework2.0/trunk/examples/adobe_spry/SpryData.js	2007-01-03 12:51:22 UTC (rev 2295)
@@ -0,0 +1,3832 @@
+/* SpryData.js - Revision: Spry Preview Release 1.4 */
+
+// Copyright (c) 2006. Adobe Systems Incorporated.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are met:
+//
+//   * Redistributions of source code must retain the above copyright notice,
+//     this list of conditions and the following disclaimer.
+//   * Redistributions in binary form must reproduce the above copyright notice,
+//     this list of conditions and the following disclaimer in the documentation
+//     and/or other materials provided with the distribution.
+//   * Neither the name of Adobe Systems Incorporated nor the names of its
+//     contributors may be used to endorse or promote products derived from this
+//     software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
+// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+// POSSIBILITY OF SUCH DAMAGE.
+
+var Spry; if (!Spry) Spry = {};
+
+//////////////////////////////////////////////////////////////////////
+//
+// Spry.Utils
+//
+//////////////////////////////////////////////////////////////////////
+
+if (!Spry.Utils) Spry.Utils = {};
+
+Spry.Utils.msProgIDs = [&quot;MSXML2.XMLHTTP.5.0&quot;, &quot;MSXML2.XMLHTTP.4.0&quot;, &quot;MSXML2.XMLHTTP.3.0&quot;, &quot;MSXML2.XMLHTTP&quot;, &quot;Microsoft.XMLHTTP&quot;];
+
+Spry.Utils.createXMLHttpRequest = function()
+{
+	var req = null;
+	try
+	{
+		if (window.XMLHttpRequest)
+			req = new XMLHttpRequest();
+		else if (window.ActiveXObject)
+		{
+			while (!req &amp;&amp; Spry.Utils.msProgIDs.length)
+			{
+				try { req = new ActiveXObject(Spry.Utils.msProgIDs[0]); } catch (e) { req = null; }
+				if (!req)
+					Spry.Utils.msProgIDs.splice(0, 1);
+			}
+		}
+	}
+	catch (e) { req = null;	}
+
+	if (!req)
+		Spry.Debug.reportError(&quot;Failed to create an XMLHttpRequest object!&quot; );
+
+	return req;
+};
+
+Spry.Utils.loadURL = function(method, url, async, callback, opts)
+{
+	var req = new Spry.Utils.loadURL.Request();
+	req.method = method;
+	req.url = url;
+	req.async = async;
+	req.successCallback = callback;
+	Spry.Utils.setOptions(req, opts);
+	
+	try
+	{
+		req.xhRequest = Spry.Utils.createXMLHttpRequest();
+		if (!req.xhRequest)
+			return null;
+
+		if (req.async)
+			req.xhRequest.onreadystatechange = function() { Spry.Utils.loadURL.callback(req); };
+
+		req.xhRequest.open(req.method, req.url, req.async, req.username, req.password);
+		
+		if (req.headers)
+		{
+			for (var name in req.headers)
+				req.xhRequest.setRequestHeader(name, req.headers[name]);
+		}
+
+		req.xhRequest.send(req.postData);
+
+		if (!req.async)
+			Spry.Utils.loadURL.callback(req);
+	}
+	catch(e) { req = null; Spry.Debug.reportError(&quot;Exception caught while loading &quot; + url + &quot;: &quot; + e); }
+
+	return req;
+};
+
+Spry.Utils.loadURL.callback = function(req)
+{
+	if (!req || req.xhRequest.readyState != 4)
+		return;
+	if (req.successCallback &amp;&amp; (req.xhRequest.status == 200 || req.xhRequest.status == 0))
+		req.successCallback(req);
+	else if (req.errorCallback)
+		req.errorCallback(req);
+};
+
+Spry.Utils.loadURL.Request = function()
+{
+	var props = Spry.Utils.loadURL.Request.props;
+	var numProps = props.length;
+
+	for (var i = 0; i &lt; numProps; i++)
+		this[props[i]] = null;
+
+	this.method = &quot;GET&quot;;
+	this.async = true;
+	this.headers = {};
+};
+
+Spry.Utils.loadURL.Request.props = [ &quot;method&quot;, &quot;url&quot;, &quot;async&quot;, &quot;username&quot;, &quot;password&quot;, &quot;postData&quot;, &quot;successCallback&quot;, &quot;errorCallback&quot;, &quot;headers&quot;, &quot;userData&quot;, &quot;xhRequest&quot; ];
+
+Spry.Utils.loadURL.Request.prototype.extractRequestOptions = function(opts, undefineRequestProps)
+{
+	if (!opts)
+		return;
+
+	var props = Spry.Utils.loadURL.Request.props;
+	var numProps = props.length;
+
+	for (var i = 0; i &lt; numProps; i++)
+	{
+		var prop = props[i];
+		if (opts[prop] != undefined)
+		{
+			this[prop] = opts[prop];
+			if (undefineRequestProps)
+				opts[prop] = undefined;
+		}
+	}
+};
+
+Spry.Utils.loadURL.Request.prototype.clone = function()
+{
+	var props = Spry.Utils.loadURL.Request.props;
+	var numProps = props.length;
+	var req = new Spry.Utils.loadURL.Request;
+	for (var i = 0; i &lt; numProps; i++)
+		req[props[i]] = this[props[i]];
+	if (this.headers)
+	{
+		req.headers = {};
+		Spry.Utils.setOptions(req.headers, this.headers);
+	}
+	return req;
+};
+
+Spry.Utils.setInnerHTML = function(ele, str, preventScripts)
+{
+	if (!ele)
+		return;
+	ele = $(ele);
+	var scriptExpr = &quot;&lt;script[^&gt;]*&gt;(.|\s|\n|\r)*?&lt;/script&gt;&quot;;
+	ele.innerHTML = str.replace(new RegExp(scriptExpr, &quot;img&quot;), &quot;&quot;);
+
+	if (preventScripts)
+		return;
+		
+	var matches = str.match(new RegExp(scriptExpr, &quot;img&quot;));
+	if (matches)
+	{
+		var numMatches = matches.length;
+		for (var i = 0; i &lt; numMatches; i++)
+		{
+			var s = matches[i].replace(/&lt;script[^&gt;]*&gt;[\s\r\n]*(&lt;\!--)?|(--&gt;)?[\s\r\n]*&lt;\/script&gt;/img, &quot;&quot;);
+			Spry.Utils.eval(s);
+		}
+	}
+};
+
+Spry.Utils.updateContent = function (ele, url, finishFunc, opts)
+{
+	var method = (opts &amp;&amp; opts.method) ? opts.method : &quot;GET&quot;;
+	Spry.Utils.loadURL(method, url, false, function(req)
+	{
+		Spry.Utils.setInnerHTML(ele, req.xhRequest.responseText);
+		if (finishFunc)
+			finishFunc(ele, url);
+	}, opts);
+};
+
+Spry.Utils.addEventListener = function(element, eventType, handler, capture)
+{
+	try
+	{
+		element = $(element);
+		if (element.addEventListener)
+			element.addEventListener(eventType, handler, capture);
+		else if (element.attachEvent)
+			element.attachEvent(&quot;on&quot; + eventType, handler);
+	}
+	catch (e) {}
+};
+
+Spry.Utils.removeEventListener = function(element, eventType, handler, capture)
+{
+	try
+	{
+		element = $(element);
+		if (element.removeEventListener)
+			element.removeEventListener(eventType, handler, capture);
+		else if (element.detachEvent)
+			element.detachEvent(&quot;on&quot; + eventType, handler);
+	}
+	catch (e) {}
+};
+
+Spry.Utils.addLoadListener = function(handler)
+{
+	if (typeof window.addEventListener != 'undefined')
+		window.addEventListener('load', handler, false);
+	else if (typeof document.addEventListener != 'undefined')
+		document.addEventListener('load', handler, false);
+	else if (typeof window.attachEvent != 'undefined')
+		window.attachEvent('onload', handler);
+};
+
+Spry.Utils.eval = function(str)
+{
+	// Call this method from your JS function when
+	// you don't want the JS expression to access or
+	// interfere with any local variables in your JS
+	// function.
+
+	return eval(str);
+};
+
+Spry.Utils.escapeQuotesAndLineBreaks = function(str)
+{
+	if (str)
+	{
+		str = str.replace(/\\/g, &quot;\\\\&quot;);
+		str = str.replace(/[&quot;']/g, &quot;\\$&amp;&quot;);
+		str = str.replace(/\n/g, &quot;\\n&quot;);
+		str = str.replace(/\r/g, &quot;\\r&quot;);
+	}
+	return str;
+};
+
+Spry.Utils.encodeEntities = function(str)
+{
+	if (str &amp;&amp; str.search(/[&amp;&lt;&gt;&quot;]/) != -1)
+	{
+		str = str.replace(/&amp;/g, &quot;&amp;&quot;);
+		str = str.replace(/&lt;/g, &quot;&lt;&quot;);
+		str = str.replace(/&gt;/g, &quot;&gt;&quot;);
+		str = str.replace(/&quot;/g, &quot;&quot;&quot;);
+	}
+	return str
+};
+
+Spry.Utils.decodeEntities = function(str)
+{
+	var d = Spry.Utils.decodeEntities.div;
+	if (!d)
+	{
+		d = document.createElement('div');
+		Spry.Utils.decodeEntities.div = d;
+		if (!d) return str;
+	}
+	d.innerHTML = str;
+	if (d.childNodes.length == 1 &amp;&amp; d.firstChild.nodeType == 3 /* Node.TEXT_NODE */ &amp;&amp; d.firstChild.nextSibling == null)
+		str = d.firstChild.data;
+	else
+	{
+		// Hmmm, innerHTML processing of str produced content
+		// we weren't expecting, so just replace entities we
+		// expect folks will use in node attributes that contain
+		// JavaScript.
+		str = str.replace(/&lt;/, &quot;&lt;&quot;);
+		str = str.replace(/&gt;/, &quot;&gt;&quot;);
+		str = str.replace(/&quot;/, &quot;\&quot;&quot;);
+		str = str.replace(/&amp;/, &quot;&amp;&quot;);
+	}
+	return str;
+};
+
+Spry.Utils.fixupIETagAttributes = function(inStr)
+{
+	var outStr = &quot;&quot;;
+
+	// Break the tag string into 3 pieces.
+
+	var tagStart = inStr.match(/^&lt;[^\s&gt;]+\s*/)[0];
+	var tagEnd = inStr.match(/\s*\/?&gt;$/)[0];
+	var tagAttrs = inStr.replace(/^&lt;[^\s&gt;]+\s*|\s*\/?&gt;/g, &quot;&quot;);
+
+	// Write out the start of the tag.
+	outStr += tagStart;
+
+	// If the tag has attributes, parse it out manually to avoid accidentally fixing up
+	// attributes that contain JavaScript expressions.
+
+	if (tagAttrs)
+	{
+		var startIndex = 0;
+		var endIndex = 0;
+
+		while (startIndex &lt; tagAttrs.length)
+		{
+			// Find the '=' char of the attribute.
+			while (tagAttrs.charAt(endIndex) != '=' &amp;&amp; endIndex &lt; tagAttrs.length)
+				++endIndex;
+
+			// If we are at the end of the string, just write out what we've
+			// collected.
+
+			if (endIndex &gt;= tagAttrs.length)
+			{
+				outStr += tagAttrs.substring(startIndex, endIndex);
+				break;
+			}
+
+			// Step past the '=' character and write out what we've
+			// collected so far.
+
+			++endIndex;
+			outStr += tagAttrs.substring(startIndex, endIndex);
+			startIndex = endIndex;
+
+			if (tagAttrs.charAt(endIndex) == '&quot;' || tagAttrs.charAt(endIndex) == &quot;'&quot;)
+			{
+				// Attribute is quoted. Advance us past the quoted value!
+				var savedIndex = endIndex++;
+				while (endIndex &lt; tagAttrs.length)
+				{
+					if (tagAttrs.charAt(endIndex) == tagAttrs.charAt(savedIndex))
+					{
+						endIndex++;
+						break;
+					}
+					else if (tagAttrs.charAt(endIndex) == &quot;\\&quot;)
+						endIndex++;
+					endIndex++;
+				}
+
+				outStr += tagAttrs.substring(startIndex, endIndex);
+				startIndex = endIndex;
+			}
+			else
+			{
+				// This attribute value wasn't quoted! Wrap it with quotes and
+				// write out everything till we hit a space, or the end of the
+				// string.
+
+				outStr += &quot;\&quot;&quot;;
+				
+				var sIndex = tagAttrs.slice(endIndex).search(/\s/);
+				endIndex = (sIndex != -1) ? (endIndex + sIndex) : tagAttrs.length;
+				outStr += tagAttrs.slice(startIndex, endIndex);				
+				outStr += &quot;\&quot;&quot;;				
+				startIndex = endIndex;
+			}
+		}
+	}
+
+	outStr += tagEnd;
+
+	// Write out the end of the tag.
+	return outStr;
+}
+
+Spry.Utils.fixUpIEInnerHTML = function(inStr)
+{
+	var outStr = &quot;&quot;;
+
+	// Create a regular expression that will match:
+	//     &lt;!--
+	//     &lt;![CDATA[
+	//     &lt;tag&gt;
+	//     --&gt;
+	//     ]]&gt;
+	//     ]]&gt;   // Yet another workaround for an IE innerHTML bug.
+	//
+	// The idea here is that we only want to fix up attribute values on tags that
+	// are not in any comments or CDATA.
+
+	var regexp = new RegExp(&quot;&lt;\\!--|&lt;\\!\\[CDATA\\[|&lt;\\w+[^&lt;&gt;]*&gt;|--&gt;|\\]\\](&gt;|\&gt;)&quot;, &quot;g&quot;);
+	var searchStartIndex = 0;
+	var skipFixUp = 0;
+	
+	while (inStr.length)
+	{
+		var results = regexp.exec(inStr);
+		if (!results || !results[0])
+		{
+			outStr += inStr.substr(searchStartIndex, inStr.length - searchStartIndex);
+			break;
+		}
+
+		if (results.index != searchStartIndex)
+		{
+			// We found a match but it's not at the start of the inStr.
+			// Create a string token for everything that precedes the match.
+			outStr += inStr.substr(searchStartIndex, results.index - searchStartIndex);
+		}
+
+		if (results[0] == &quot;&lt;!--&quot; || results[0] == &quot;&lt;![CDATA[&quot;)
+		{
+			++skipFixUp;
+			outStr += results[0];
+		}
+		else if (results[0] == &quot;--&gt;&quot; || results[0] == &quot;]]&gt;&quot; || (skipFixUp &amp;&amp; results[0] == &quot;]]&gt;&quot;))
+		{
+			--skipFixUp;
+			outStr += results[0];
+		}
+		else if (!skipFixUp &amp;&amp; results[0].charAt(0) == '&lt;')
+			outStr += Spry.Utils.fixupIETagAttributes(results[0]);
+		else
+			outStr += results[0];
+
+		searchStartIndex = regexp.lastIndex;
+	}
+	
+	return outStr;
+};
+
+Spry.Utils.stringToXMLDoc = function(str)
+{
+	var xmlDoc = null;
+
+	try
+	{
+		// Attempt to parse the string using the IE method.
+
+		var xmlDOMObj = new ActiveXObject(&quot;Microsoft.XMLDOM&quot;);
+		xmlDOMObj.async = false;
+		xmlDOMObj.loadXML(str);
+		xmlDoc = xmlDOMObj;
+	}
+	catch (e)
+	{
+		// The IE method didn't work. Try the Mozilla way.
+
+		try
+		{
+			var domParser = new DOMParser;
+			xmlDoc = domParser.parseFromString(str, 'text/xml');
+		}
+		catch (e)
+		{
+			Spry.Debug.reportError(&quot;Caught exception in Spry.Utils.stringToXMLDoc(): &quot; + e + &quot;\n&quot;);
+			xmlDoc = null;
+		}
+	}
+
+	return xmlDoc;
+};
+
+Spry.Utils.serializeObject = function(obj)
+{
+	// Create a JSON representation of a given object.
+
+	var str = &quot;&quot;;
+	var firstItem = true;
+
+	if (obj == null || obj == undefined)
+		return str + obj;
+
+	var objType = typeof obj;
+
+	if (objType == &quot;number&quot; || objType == &quot;boolean&quot;)
+		str += obj;
+	else if (objType == &quot;string&quot;)
+		str += &quot;\&quot;&quot; + Spry.Utils.escapeQuotesAndLineBreaks(obj) + &quot;\&quot;&quot;;
+	else if (obj.constructor == Array)
+	{
+		str += &quot;[&quot;;
+		for (var i = 0; i &lt; obj.length; i++)
+		{
+			if (!firstItem)
+				str += &quot;, &quot;;
+			str += Spry.Utils.serializeObject(obj[i]);
+			firstItem = false;
+		}
+		str += &quot;]&quot;;
+	}
+	else if (objType == &quot;object&quot;)
+	{
+		str += &quot;{&quot;;
+		for (var p in obj)
+		{
+			if (!firstItem)
+				str += &quot;, &quot;;
+			str += &quot;\&quot;&quot; + p + &quot;\&quot;: &quot; + Spry.Utils.serializeObject(obj[p]);
+			firstItem = false;
+		}
+		str += &quot;}&quot;;
+	}
+	return str;
+};
+
+Spry.Utils.getNodesByFunc = function(root, func)
+{
+	var nodeStack = new Array;
+	var resultArr = new Array;
+	var node = root;
+
+	while (node)
+	{
+		if (func(node))
+			resultArr.push(node);
+
+		if (node.hasChildNodes())
+		{
+			nodeStack.push(node);
+			node = node.firstChild;
+		}
+		else
+		{
+			if (node == root)
+				node = null;
+			else
+				try { node = node.nextSibling; } catch (e) { node = null; };
+		}
+		
+		while (!node &amp;&amp; nodeStack.length &gt; 0)
+		{
+			node = nodeStack.pop();
+			if (node == root)
+				node = null;
+			else
+				try { node = node.nextSibling; } catch (e) { node = null; }
+		}
+	}
+	
+	if (nodeStack &amp;&amp; nodeStack.length &gt; 0)
+		Spry.Debug.trace(&quot;-- WARNING: Spry.Utils.getNodesByFunc() failed to traverse all nodes!\n&quot;);
+
+	return resultArr;
+};
+
+Spry.Utils.addClassName = function(ele, className)
+{
+	ele = $(ele);
+	if (!ele || !className || (ele.className &amp;&amp; ele.className.search(new RegExp(&quot;\\b&quot; + className + &quot;\\b&quot;)) != -1))
+		return;
+	ele.className += (ele.className ? &quot; &quot; : &quot;&quot;) + className;
+};
+
+Spry.Utils.removeClassName = function(ele, className)
+{
+	ele = $(ele);
+	if (!ele || !className || (ele.className &amp;&amp; ele.className.search(new RegExp(&quot;\\b&quot; + className + &quot;\\b&quot;)) == -1))
+		return;
+	ele.className = ele.className.replace(new RegExp(&quot;\\s*\\b&quot; + className + &quot;\\b&quot;, &quot;g&quot;), &quot;&quot;);
+};
+
+Spry.Utils.getFirstChildWithNodeName = function(node, nodeName)
+{
+	var child = node.firstChild;
+
+	while (child)
+	{
+		if (child.nodeName == nodeName)
+			return child;
+		child = child.nextSibling;
+	} 
+
+	return null;
+};
+
+Spry.Utils.nodeContainsElementNode = function(node)
+{
+	if (node)
+	{
+		node = node.firstChild;
+
+		while (node)
+		{
+			if (node.nodeType == 1 /* Node.ELEMENT_NODE */)
+				return true;
+
+			node = node.nextSibling;
+		}
+	}
+	return false;
+};
+
+Spry.Utils.getNodeText = function(node)
+{
+	var txt = &quot;&quot;;
+  
+	if (!node)
+		return;
+
+	try
+	{
+		var child = node.firstChild;
+ 
+		while (child)
+		{
+			try
+			{
+				if (child.nodeType == 3 /* TEXT_NODE */)
+					txt += Spry.Utils.encodeEntities(child.data);
+				else if (child.nodeType == 4 /* CDATA_SECTION_NODE */)
+					txt += child.data;
+			} catch (e) { Spry.Debug.reportError(&quot;Spry.Utils.getNodeText() exception caught: &quot; + e + &quot;\n&quot;); }
+
+			child = child.nextSibling;
+		}
+	}
+	catch (e) { Spry.Debug.reportError(&quot;Spry.Utils.getNodeText() exception caught: &quot; + e + &quot;\n&quot;); }
+  
+	return txt;
+};
+
+Spry.Utils.CreateObjectForNode = function(node)
+{
+	if (!node)
+		return null;
+
+	var obj = null;
+	var i = 0;
+	var attr = null;
+
+	try
+	{
+		for (i = 0; i &lt; node.attributes.length; i++)
+		{
+			attr = node.attributes[i];
+			if (attr &amp;&amp; attr.nodeType == 2 /* Node.ATTRIBUTE_NODE */)
+			{
+				if (!obj)
+				{
+					obj = new Object();
+					if (!obj)
+					{
+						Spry.Debug.reportError(&quot;Spry.Utils.CreateObjectForNode(): Object creation failed!&quot;);
+						return null;
+					}
+				}
+		
+				obj[&quot;@&quot; + attr.name] = attr.value;
+			}
+		}
+	}
+	catch (e)
+	{
+		Spry.Debug.reportError(&quot;Spry.Utils.CreateObjectForNode() caught exception while accessing attributes: &quot; + e + &quot;\n&quot;);
+	}
+  
+	var child = node.firstChild;
+	
+	if (child &amp;&amp; !child.nextSibling &amp;&amp; child.nodeType != 1 /* Node.ELEMENT_NODE */)
+	{
+		// We have a single child and it's not an element. It must
+		// be the text value for this node. Add it to the record set and
+		// give it the column the same name as the node.
+
+		if (!obj)
+		{
+			obj = new Object();
+			if (!obj)
+			{
+				Spry.Debug.reportError(&quot;Spry.Utils.CreateObjectForNode(): Object creation failed!&quot;);
+				return null;
+			}
+		}
+
+		obj[node.nodeName] = Spry.Utils.getNodeText(node);
+	}
+  
+	while (child)
+	{
+		// Add the text value for each child element. Note that
+		// We skip elements that have element children (sub-elements)
+		// because we don't handle multi-level data sets right now.
+	
+		if (child.nodeType == 1 /* Node.ELEMENT_NODE */)
+		{
+			if (!Spry.Utils.nodeContainsElementNode(child))
+			{
+				var txt = Spry.Utils.getNodeText(child);
+				if (!obj)
+				{
+					obj = new Object();
+					if (!obj)
+					{
+						Spry.Debug.reportError(&quot;Spry.Utils.CreateObjectForNode(): Object creation failed!&quot;);
+						return null;
+					}
+				}
+	  
+				obj[child.nodeName] = txt;
+
+				// Now add properties for any attributes on the child. The property
+				// name will be of the form &quot;&lt;child.nodeName&gt;/@&lt;attr.name&gt;&quot;.
+				try
+				{
+					var namePrefix = child.nodeName + &quot;/@&quot;;
+					
+					for (i = 0; i &lt; child.attributes.length; i++)
+					{
+						attr = child.attributes[i];
+						if (attr &amp;&amp; attr.nodeType == 2 /* Node.ATTRIBUTE_NODE */)
+							obj[namePrefix + attr.name] = attr.value;
+					}
+				}
+				catch (e)
+				{
+					Spry.Debug.reportError(&quot;Spry.Utils.CreateObjectForNode() caught exception while accessing attributes: &quot; + e + &quot;\n&quot;);
+				}
+        
+			}
+			// else Spry.Debug.trace(&quot;WARNING: Skipping '&quot; + child.nodeName + &quot;' node! Multi-level data sets are not supported right now!\n&quot;);
+		}
+
+		child = child.nextSibling;
+	}
+  
+	return obj;
+};
+
+Spry.Utils.getRecordSetFromXMLDoc = function(xmlDoc, path)
+{
+	if (!xmlDoc || !path)
+		return null;
+
+	var recordSet = new Object();
+	recordSet.xmlDoc = xmlDoc;
+	recordSet.xmlPath = path;
+	recordSet.dataHash = new Object;
+	recordSet.data = new Array;
+	recordSet.getData = function() { return this.data; };
+
+	// Use the XPath library to find the nodes that will
+	// make up our data set. The result should be an array
+	// of subtrees that we need to flatten.
+
+	var ctx = new ExprContext(xmlDoc);
+	var pathExpr = xpathParse(path);
+	var e = pathExpr.evaluate(ctx);
+
+	// XXX: Note that we should check the result type of the evaluation
+	// just in case it's a boolean, string, or number value instead of
+	// a node set.
+  
+	var nodeArray = e.nodeSetValue();
+
+	var isDOMNodeArray = true;
+
+	if (nodeArray &amp;&amp; nodeArray.length &gt; 0)
+		isDOMNodeArray = nodeArray[0].nodeType != 2 /* Node.ATTRIBUTE_NODE */;
+
+	var nextID = 0;
+
+	// We now have the set of nodes that make up our data set
+	// so process each one.
+
+	for (var i = 0; i &lt; nodeArray.length; i++)
+	{
+		var rowObj = null;
+	
+		if (isDOMNodeArray)
+			rowObj = Spry.Utils.CreateObjectForNode(nodeArray[i]);
+		else // Must be a Node.ATTRIBUTE_NODE array.
+		{
+			rowObj = new Object;
+			rowObj[&quot;@&quot; + nodeArray[i].name] = nodeArray[i].value;
+		}
+	
+		if (rowObj)
+		{
+			// We want to make sure that every row has a unique ID and since we
+			// we don't know which column, if any, in this recordSet is a unique
+			// identifier, we generate a unique ID ourselves and store it under
+			// the ds_RowID column in the row object.
+
+			rowObj['ds_RowID'] = nextID++;
+			recordSet.dataHash[rowObj['ds_RowID']] = rowObj;
+			recordSet.data.push(rowObj);
+		}
+	}
+  
+	return recordSet;
+};
+
+Spry.Utils.setOptions = function(obj, optionsObj, ignoreUndefinedProps)
+{
+	if (!optionsObj)
+		return;
+
+	for (var optionName in optionsObj)
+	{
+		if (ignoreUndefinedProps &amp;&amp; optionsObj[optionName] == undefined)
+			continue;
+		obj[optionName] = optionsObj[optionName];
+	}
+};
+
+Spry.Utils.SelectionManager = {};
+Spry.Utils.SelectionManager.selectionGroups = new Object;
+
+Spry.Utils.SelectionManager.SelectionGroup = function()
+{
+	this.selectedElements = new Array;
+};
+
+Spry.Utils.SelectionManager.SelectionGroup.prototype.select = function(element, className, multiSelect)
+{
+	var selObj = null;
+
+	if (!multiSelect)
+	{
+		// Multiple selection is not enabled, so clear any
+		// selected elements from our list.
+
+		this.clearSelection();
+	}
+	else
+	{
+		// Multiple selection is enabled, so check to see if element
+		// is already in the array. If it is, make sure the className
+		// is the className that was passed in.
+
+		for (var i = 0; i &lt; this.selectedElements.length; i++)
+		{
+			selObj = this.selectedElements[i].element;
+
+			if (selObj.element == element)
+			{
+				if (selObj.className != className)
+				{
+					Spry.Utils.removeClassName(element, selObj.className);
+					Spry.Utils.addClassName(element, className);
+				}
+				return;
+			}
+		}
+	}
+
+	// Add the element to our list of selected elements.
+
+	selObj = new Object;
+	selObj.element = element;
+	selObj.className = className;
+	this.selectedElements.push(selObj);
+	Spry.Utils.addClassName(element, className);
+};
+
+Spry.Utils.SelectionManager.SelectionGroup.prototype.unSelect = function(element)
+{
+	for (var i = 0; i &lt; this.selectedElements.length; i++)
+	{
+		var selObj = this.selectedElements[i].element;
+	
+		if (selObj.element == element)
+		{
+			Spry.Utils.removeClassName(selObj.element, selObj.className);
+			return;
+		}
+	}
+};
+
+Spry.Utils.SelectionManager.SelectionGroup.prototype.clearSelection = function()
+{
+	var selObj = null;
+
+	do
+	{
+		selObj = this.selectedElements.shift();
+		if (selObj)
+			Spry.Utils.removeClassName(selObj.element, selObj.className);
+	}
+	while (selObj);
+};
+
+Spry.Utils.SelectionManager.getSelectionGroup = function(selectionGroupName)
+{
+	if (!selectionGroupName)
+		return null;
+
+	var groupObj = Spry.Utils.SelectionManager.selectionGroups[selectionGroupName];
+
+	if (!groupObj)
+	{
+		groupObj = new Spry.Utils.SelectionManager.SelectionGroup();
+		Spry.Utils.SelectionManager.selectionGroups[selectionGroupName] = groupObj;
+	}
+
+	return groupObj;
+};
+
+Spry.Utils.SelectionManager.select = function(selectionGroupName, element, className, multiSelect)
+{
+	var groupObj = Spry.Utils.SelectionManager.getSelectionGroup(selectionGroupName);
+
+	if (!groupObj)
+		return;
+
+	groupObj.select(element, className, multiSelect);
+};
+
+Spry.Utils.SelectionManager.unSelect = function(selectionGroupName, element)
+{
+	var groupObj = Spry.Utils.SelectionManager.getSelectionGroup(selectionGroupName);
+
+	if (!groupObj)
+		return;
+
+	groupObj.unSelect(element, className);
+};
+
+Spry.Utils.SelectionManager.clearSelection = function(selectionGroupName)
+{
+	var groupObj = Spry.Utils.SelectionManager.getSelectionGroup(selectionGroupName);
+
+	if (!groupObj)
+		return;
+
+	groupObj.clearSelection();
+};
+
+//////////////////////////////////////////////////////////////////////
+//
+// Define Prototype's $() convenience function.
+//
+//////////////////////////////////////////////////////////////////////
+
+function $()
+{
+	var elements = new Array();
+	
+	for (var i = 0; i &lt; arguments.length; i++)
+	{
+		var element = arguments[i];
+		if (typeof element == 'string')
+			element = document.getElementById(element);
+		
+		if (arguments.length == 1)
+			return element;
+		
+		elements.push(element);
+	}
+	
+	return elements;
+}
+
+Spry.Utils.Notifier = function()
+{
+	this.observers = [];
+	this.suppressNotifications = 0;
+};
+
+Spry.Utils.Notifier.prototype.addObserver = function(observer)
+{
+	if (!observer)
+		return;
+
+	// Make sure the observer isn't already on the list.
+
+	var len = this.observers.length;
+	for (var i = 0; i &lt; len; i++)
+	{
+		if (this.observers[i] == observer)
+			return;
+	}
+	this.observers[len] = observer;
+};
+
+Spry.Utils.Notifier.prototype.removeObserver = function(observer)
+{
+	if (!observer)
+		return;
+
+	for (var i = 0; i &lt; this.observers.length; i++)
+	{
+		if (this.observers[i] == observer)
+		{
+			this.observers.splice(i, 1);
+			break;
+		}
+	}
+};
+
+Spry.Utils.Notifier.prototype.notifyObservers = function(methodName, data)
+{
+	if (!methodName)
+		return;
+
+	if (!this.suppressNotifications)
+	{
+		var len = this.observers.length;
+		for (var i = 0; i &lt; len; i++)
+		{
+			var obs = this.observers[i];
+			if (obs)
+			{
+				if (typeof obs == &quot;function&quot;)
+					obs(methodName, this, data);
+				else if (obs[methodName])
+					obs[methodName](this, data);
+			}
+		}
+	}
+};
+
+Spry.Utils.Notifier.prototype.enableNotifications = function()
+{
+	if (--this.suppressNotifications &lt; 0)
+	{
+		this.suppressNotifications = 0;
+		Spry.Debug.reportError(&quot;Unbalanced enableNotifications() call!\n&quot;);
+	}
+};
+
+Spry.Utils.Notifier.prototype.disableNotifications = function()
+{
+	++this.suppressNotifications;
+};
+
+//////////////////////////////////////////////////////////////////////
+//
+// Spry.Debug
+//
+//////////////////////////////////////////////////////////////////////
+
+Spry.Debug = {};
+Spry.Debug.enableTrace = true;
+Spry.Debug.debugWindow = null;
+
+Spry.Debug.createDebugWindow = function()
+{
+	if (!Spry.Debug.enableTrace || Spry.Debug.debugWindow)
+		return;
+	try
+	{
+		Spry.Debug.debugWindow = document.createElement(&quot;div&quot;);
+		var div = Spry.Debug.debugWindow;
+		div.style.fontSize = &quot;12px&quot;;
+		div.style.fontFamily = &quot;console&quot;;
+		div.style.position = &quot;absolute&quot;;
+		div.style.width = &quot;400px&quot;;
+		div.style.height = &quot;300px&quot;;
+		div.style.overflow = &quot;auto&quot;;
+		div.style.border = &quot;solid 1px black&quot;;
+		div.style.backgroundColor = &quot;white&quot;;
+		div.style.color = &quot;black&quot;;
+		div.style.bottom = &quot;0px&quot;;
+		div.style.right = &quot;0px&quot;;
+		// div.style.opacity = &quot;0.5&quot;;
+		// div.style.filter = &quot;alpha(opacity=50)&quot;;
+		div.setAttribute(&quot;id&quot;, &quot;SpryDebugWindow&quot;);
+		document.body.appendChild(Spry.Debug.debugWindow);
+	}
+	catch (e) {}
+};
+
+Spry.Debug.debugOut = function(str, bgColor)
+{
+	if (!Spry.Debug.debugWindow)
+	{
+		Spry.Debug.createDebugWindow();
+		if (!Spry.Debug.debugWindow)
+			return;
+	}
+
+	var d = document.createElement(&quot;div&quot;);
+	if (bgColor)
+		d.style.backgroundColor = bgColor;
+	d.innerHTML = str;
+	Spry.Debug.debugWindow.appendChild(d);	
+};
+
+Spry.Debug.trace = function(str)
+{
+	Spry.Debug.debugOut(str);
+};
+
+Spry.Debug.reportError = function(str)
+{
+	Spry.Debug.debugOut(str, &quot;red&quot;);
+};
+
+//////////////////////////////////////////////////////////////////////
+//
+// Spry.Data
+//
+//////////////////////////////////////////////////////////////////////
+
+Spry.Data = {};
+Spry.Data.regionsArray = {};
+
+Spry.Data.initRegions = function(rootNode)
+{
+	if (!rootNode)
+		rootNode = document.body;
+
+	var lastRegionFound = null;
+
+	var regions = Spry.Utils.getNodesByFunc(rootNode, function(node)
+	{
+		try
+		{
+			if (node.nodeType != 1 /* Node.ELEMENT_NODE */)
+				return false;
+
+			// Region elements must have an spryregion attribute with a
+			// non-empty value. An id attribute is also required so we can
+			// reference the region by name if necessary.
+
+			var attrName = &quot;spry:region&quot;;
+			var attr = node.attributes.getNamedItem(attrName);
+			if (!attr)
+			{
+				attrName = &quot;spry:detailregion&quot;;
+				attr = node.attributes.getNamedItem(attrName);
+			}
+			if (attr)
+			{
+				if (lastRegionFound)
+				{
+					var parent = node.parentNode;
+					while (parent)
+					{
+						if (parent == lastRegionFound)
+						{
+							Spry.Debug.reportError(&quot;Found a nested &quot; + attrName + &quot; in the following markup. Nested regions are currently not supported.&lt;br/&gt;&lt;pre&gt;&quot; + Spry.Utils.encodeEntities(parent.innerHTML) + &quot;&lt;/pre&gt;&quot;);
+							return false;
+						}
+						parent = parent.parentNode;
+					}
+				}
+
+				if (attr.value)
+				{
+					attr = node.attributes.getNamedItem(&quot;id&quot;);
+					if (!attr || !attr.value)
+					{
+						// The node is missing an id attribute so add one.
+						node.setAttribute(&quot;id&quot;, &quot;spryregion&quot; + (++Spry.Data.initRegions.nextUniqueRegionID));
+					}
+
+					lastRegionFound = node;
+					return true;
+				}
+				else
+					Spry.Debug.reportError(attrName + &quot; attributes require one or more data set names as values!&quot;);
+			}
+		}
+		catch(e) {}
+		return false;
+	});
+
+	var name, dataSets, i;
+  
+	for (i = 0; i &lt; regions.length; i++)
+	{
+		var rgn = regions[i];
+
+		var isDetailRegion = false;
+
+		// Get the region name.
+		name = rgn.attributes.getNamedItem(&quot;id&quot;).value;
+
+		attr = rgn.attributes.getNamedItem(&quot;spry:region&quot;);
+		if (!attr)
+		{
+			attr = rgn.attributes.getNamedItem(&quot;spry:detailregion&quot;);
+			isDetailRegion = true;
+		}
+
+		if (!attr.value)
+		{
+			Spry.Debug.reportError(&quot;spry:region and spry:detailregion attributes require one or more data set names as values!&quot;);
+			continue;
+		}
+
+		// Remove the spry:region or spry:detailregion attribute so it doesn't appear in
+		// the output generated by our processing of the dynamic region.
+		rgn.attributes.removeNamedItem(attr.nodeName);
+
+		// Remove the hiddenRegionCSS class from the rgn.
+		Spry.Utils.removeClassName(rgn, Spry.Data.Region.hiddenRegionClassName);
+
+		// Get the DataSets that should be bound to the region.
+		dataSets = Spry.Data.Region.strToDataSetsArray(attr.value);
+
+		if (!dataSets.length)
+		{
+			Spry.Debug.reportError(&quot;spry:region or spry:detailregion attribute has no data set!&quot;);
+			continue;
+		}
+	
+		var hasBehaviorAttributes = false;
+		var hasSpryContent = false;
+		var dataStr = &quot;&quot;;
+
+		var parent = null;
+		var regionStates = {};
+		var regionStateMap = {};
+
+		// Check if there are any attributes on the region node that remap
+		// the default states.
+
+		attr = rgn.attributes.getNamedItem(&quot;spry:readystate&quot;);
+		if (attr &amp;&amp; attr.value)
+			regionStateMap[&quot;ready&quot;] = attr.value;
+		attr = rgn.attributes.getNamedItem(&quot;spry:errorstate&quot;);
+		if (attr &amp;&amp; attr.value)
+			regionStateMap[&quot;error&quot;] = attr.value;
+		attr = rgn.attributes.getNamedItem(&quot;spry:loadingstate&quot;);
+		if (attr &amp;&amp; attr.value)
+			regionStateMap[&quot;loading&quot;] = attr.value;
+		
+		// Find all of the processing instruction regions in the region.
+		// Insert comments around the regions we find so we can identify them
+		// easily when tokenizing the region html string.
+
+		var piRegions = Spry.Utils.getNodesByFunc(rgn, function(node)
+		{
+			try
+			{
+				if (node.nodeType == 1 /* ELEMENT_NODE */)
+				{
+					var attributes = node.attributes;
+					var numPI = Spry.Data.Region.PI.orderedInstructions.length;
+					var lastStartComment = null;
+					var lastEndComment = null;
+
+					for (var i = 0; i &lt; numPI; i++)
+					{
+						var piName = Spry.Data.Region.PI.orderedInstructions[i];
+						var attr = attributes.getNamedItem(piName);
+						if (!attr)
+							continue;
+	
+						var piDesc = Spry.Data.Region.PI.instructions[piName];
+						var childrenOnly = (node == rgn) ? true : piDesc.childrenOnly;
+						var openTag = piDesc.getOpenTag(node, piName);
+						var closeTag = piDesc.getCloseTag(node, piName);
+	
+						if (childrenOnly)
+						{
+								var oComment = document.createComment(openTag);
+								var cComment = document.createComment(closeTag)
+
+								if (!lastStartComment)
+									node.insertBefore(oComment, node.firstChild);
+								else
+									node.insertBefore(oComment, lastStartComment.nextSibling);
+								lastStartComment = oComment;
+
+								if (!lastEndComment)
+									node.appendChild(cComment);
+								else
+									node.insertBefore(cComment, lastEndComment);
+								lastEndComment = cComment;
+						}
+						else
+						{
+							var parent = node.parentNode;
+							parent.insertBefore(document.createComment(openTag), node);
+							parent.insertBefore(document.createComment(closeTag), node.nextSibling);
+						}
+
+						// If this is a spry:state processing instruction, record the state name
+						// so we know that we should re-generate the region if we ever see that state.
+
+						if (piName == &quot;spry:state&quot;)
+							regionStates[attr.value] = true;
+
+						node.removeAttribute(piName);
+					}
+
+					if (Spry.Data.Region.enableBehaviorAttributes)
+					{
+						var bAttrs = Spry.Data.Region.behaviorAttrs;
+						for (var behaviorAttrName in bAttrs)
+						{
+							var bAttr = attributes.getNamedItem(behaviorAttrName);
+							if (bAttr)
+							{
+								hasBehaviorAttributes = true;
+								if (bAttrs[behaviorAttrName].setup)
+									bAttrs[behaviorAttrName].setup(node, bAttr.value);
+							}
+						}
+					}
+				}
+			}
+			catch(e) {}
+			return false;
+		});
+	
+		// Get the data in the region.
+		dataStr = rgn.innerHTML;
+
+		// Argh! IE has an innerHTML bug where it will remove the quotes around any
+		// attribute value that it thinks is a single word. This includes removing quotes
+		// around our data references which is problematic since a single data reference
+		// can be replaced with multiple words. If we are running in IE, we have to call
+		// fixUpIEInnerHTML to get around this problem.
+
+		if (window.ActiveXObject &amp;&amp; !Spry.Data.Region.disableIEInnerHTMLFixUp &amp;&amp; dataStr.search(/=\{/) != -1)
+		{
+			if (Spry.Data.Region.debug)
+				Spry.Debug.trace(&quot;&lt;hr /&gt;Performing IE innerHTML fix up of Region: &quot; + name + &quot;&lt;br /&gt;&lt;br /&gt;&quot; + Spry.Utils.encodeEntities(dataStr));
+
+			dataStr = Spry.Utils.fixUpIEInnerHTML(dataStr);
+		}
+
+		if (Spry.Data.Region.debug)
+			Spry.Debug.trace(&quot;&lt;hr /&gt;Region template markup for '&quot; + name + &quot;':&lt;br /&gt;&lt;br /&gt;&quot; + Spry.Utils.encodeEntities(dataStr));
+
+		if (!hasSpryContent)
+		{
+			// Clear the region.
+			rgn.innerHTML = &quot;&quot;;
+		}
+
+		// Create a Spry.Data.Region object for this region.
+		var region = new Spry.Data.Region(rgn, name, isDetailRegion, dataStr, dataSets, regionStates, regionStateMap, hasBehaviorAttributes);
+		Spry.Data.regionsArray[region.name] = region;
+	}
+
+	Spry.Data.updateAllRegions();
+};
+
+Spry.Data.initRegions.nextUniqueRegionID = 0;
+
+Spry.Data.updateRegion = function(regionName)
+{
+	if (!regionName || !Spry.Data.regionsArray || !Spry.Data.regionsArray[regionName])
+		return;
+
+	try { Spry.Data.regionsArray[regionName].updateContent(); }
+	catch(e) { Spry.Debug.reportError(&quot;Spry.Data.updateRegion(&quot; + regionName + &quot;) caught an exception: &quot; + e + &quot;\n&quot;); }
+};
+
+Spry.Data.getRegion = function(regionName)
+{
+	return Spry.Data.regionsArray[regionName];
+};
+
+
+Spry.Data.updateAllRegions = function()
+{
+	if (!Spry.Data.regionsArray)
+		return;
+
+	for (var regionName in Spry.Data.regionsArray)
+		Spry.Data.updateRegion(regionName);
+};
+
+//////////////////////////////////////////////////////////////////////
+//
+// Spry.Data.DataSet
+//
+//////////////////////////////////////////////////////////////////////
+
+Spry.Data.DataSet = function()
+{
+	Spry.Utils.Notifier.call(this);
+
+	this.name = &quot;&quot;;
+	this.internalID = Spry.Data.DataSet.nextDataSetID++;
+	this.curRowID = 0;
+	this.data = null;
+	this.unfilteredData = null;
+	this.dataHash = null;
+	this.columnTypes = new Object;
+	this.filterFunc = null;		// non-destructive filter function
+	this.filterDataFunc = null;	// destructive filter function
+
+	this.distinctOnLoad = false;
+	this.sortOnLoad = null;
+	this.sortOrderOnLoad = &quot;ascending&quot;;
+	this.keepSorted = false;
+
+	this.dataWasLoaded = false;
+	this.pendingRequest = null;
+
+	this.lastSortColumns = [];
+	this.lastSortOrder = &quot;&quot;;
+
+	this.loadIntervalID = 0;
+};
+
+Spry.Data.DataSet.prototype = new Spry.Utils.Notifier();
+Spry.Data.DataSet.prototype.constructor = Spry.Data.DataSet;
+
+Spry.Data.DataSet.prototype.getData = function(unfiltered)
+{
+	return (unfiltered &amp;&amp; this.unfilteredData) ? this.unfilteredData : this.data;
+};
+
+Spry.Data.DataSet.prototype.getUnfilteredData = function()
+{
+	// XXX: Deprecated.
+	return this.getData(true);
+};
+
+Spry.Data.DataSet.prototype.getLoadDataRequestIsPending = function()
+{
+	return this.pendingRequest != null;
+};
+
+Spry.Data.DataSet.prototype.getDataWasLoaded = function()
+{
+	return this.dataWasLoaded;
+};
+
+Spry.Data.DataSet.prototype.loadData = function()
+{
+	// The idea here is that folks using the base class DataSet directly
+	// would change the data in the DataSet manually and then call loadData()
+	// to fire off an async notifications to say that it was ready for consumption.
+	//
+	// Firing off data changed notificataions synchronously from this method
+	// can wreak havoc with complicated master/detail regions that use data sets
+	// that have master/detail relationships with other data sets. Our data set
+	// logic already handles async data loading nicely so we use a timer to fire
+	// off the data changed notification to insure that it happens after this
+	// function is finished and the JS stack unwinds.
+	//
+	// Other classes that derive from this class and load data synchronously
+	// inside their loadData() implementation should also fire off an async
+	// notification in this same manner to avoid this same problem.
+
+	var self = this;
+
+	this.pendingRequest = new Object;
+	this.dataWasLoaded = false;
+	this.pendingRequest.timer = setTimeout(function()
+	{
+		self.pendingRequest = null;
+		self.dataWasLoaded = true;
+
+		if (self.filterDataFunc)
+			self.filterData(self.filterDataFunc, true);
+
+		if (self.distinctOnLoad)
+			self.distinct();
+
+		if (self.keepSorted &amp;&amp; self.getSortColumn())
+			self.sort(self.lastSortColumns, self.lastSortOrder)
+		else if (self.sortOnLoad)
+			self.sort(self.sortOnLoad, self.sortOrderOnLoad);
+	
+		if (self.filterFunc)
+			self.filter(self.filterFunc, true);
+	
+		self.notifyObservers(&quot;onDataChanged&quot;);
+	}, 0);  
+};
+
+Spry.Data.DataSet.prototype.cancelLoadData = function()
+{
+	if (this.pendingRequest &amp;&amp; this.pendingRequest.timer)
+		clearTimeout(this.pendingRequest.timer);
+	this.pendingRequest = null;
+};
+
+Spry.Data.DataSet.prototype.getRowCount = function(unfiltered)
+{
+	var rows = this.getData(unfiltered);
+	return rows ? rows.length : 0;
+};
+
+Spry.Data.DataSet.prototype.getRowByID = function(rowID)
+{
+	if (!this.data)
+		return null;
+	return this.dataHash[rowID];
+};
+
+Spry.Data.DataSet.prototype.getRowByRowNumber = function(rowNumber, unfiltered)
+{
+	var rows = this.getData(unfiltered);
+	if (rows &amp;&amp; rowNumber &gt;= 0 &amp;&amp; rowNumber &lt; rows.length)
+		return rows[rowNumber];
+	return null;
+};
+
+Spry.Data.DataSet.prototype.getCurrentRow = function()
+{
+	return this.getRowByID(this.curRowID);
+};
+
+Spry.Data.DataSet.prototype.setCurrentRow = function(rowID)
+{
+	if (this.curRowID == rowID)
+		return;
+
+	var nData = { oldRowID: this.curRowID, newRowID: rowID };
+	this.curRowID = rowID;
+	this.notifyObservers(&quot;onCurrentRowChanged&quot;, nData);
+};
+
+Spry.Data.DataSet.prototype.getRowNumber = function(row)
+{
+	if (row &amp;&amp; this.data &amp;&amp; this.data.length)
+	{
+		var numRows = this.data.length;
+		for (var i = 0; i &lt; numRows; i++)
+		{
+			if (this.data[i] == row)
+				return i;
+		}
+	}
+
+	return 0;
+};
+
+Spry.Data.DataSet.prototype.getCurrentRowNumber = function()
+{
+	return this.getRowNumber(this.getCurrentRow());
+};
+
+Spry.Data.DataSet.prototype.setCurrentRowNumber = function(rowNumber)
+{
+	if (!this.data || rowNumber &gt;= this.data.length)
+	{
+		Spry.Debug.trace(&quot;Invalid row number: &quot; + rowNumber + &quot;\n&quot;);
+		return;
+	}
+
+	var rowID = this.data[rowNumber][&quot;ds_RowID&quot;];
+
+	if (rowID == undefined || this.curRowID == rowID)
+		return;
+
+	this.setCurrentRow(rowID);
+};
+
+Spry.Data.DataSet.prototype.findRowsWithColumnValues = function(valueObj, firstMatchOnly, unfiltered)
+{
+	var results = [];
+	var rows = this.getData(unfiltered);
+	if (rows)
+	{
+		var numRows = rows.length;
+		for (var i = 0; i &lt; numRows; i++)
+		{
+			var row = rows[i];
+			var matched = true;
+
+			for (var colName in valueObj)
+			{
+				if (valueObj[colName] != row[colName])
+				{
+					matched = false;
+					break;
+				}
+			}
+			
+			if (matched)
+			{
+				if (firstMatchOnly)
+					return row;
+				results.push(row);
+			}
+		}
+	}
+
+	return results;
+};
+
+Spry.Data.DataSet.prototype.setColumnType = function(columnName, columnType)
+{
+	if (columnName)
+		this.columnTypes[columnName] = columnType;
+};
+
+Spry.Data.DataSet.prototype.getColumnType = function(columnName)
+{
+	if (this.columnTypes[columnName])
+		return this.columnTypes[columnName];
+	return &quot;string&quot;;
+};
+
+Spry.Data.DataSet.prototype.distinct = function()
+{
+	if (this.data)
+	{
+		var oldData = this.data;
+		this.data = [];
+		this.dataHash = {};
+
+		var alreadySeenHash = {};
+		var i = 0;
+
+		for (var i = 0; i &lt; oldData.length; i++)
+		{
+			var rec = oldData[i];
+			var hashStr = &quot;&quot;;
+			for (var recField in rec)
+			{
+				if (recField != &quot;ds_RowID&quot;)
+				{
+					if (hashStr)
+						hashStr += &quot;,&quot;;
+					hashStr += recField + &quot;:&quot; + &quot;\&quot;&quot; + rec[recField] + &quot;\&quot;&quot;;
+				}
+			}
+			if (!alreadySeenHash[hashStr])
+			{
+				this.data.push(rec);
+				this.dataHash[rec['ds_RowID']] = rec;
+				alreadySeenHash[hashStr] = true;
+			}
+		}
+	}
+};
+
+Spry.Data.DataSet.prototype.getSortColumn = function() {
+	return (this.lastSortColumns &amp;&amp; this.lastSortColumns.length &gt; 0) ? this.lastSortColumns[0] : &quot;&quot;;
+};
+
+Spry.Data.DataSet.prototype.getSortOrder = function() {
+	return this.lastSortOrder ? this.lastSortOrder : &quot;&quot;;
+};
+
+Spry.Data.DataSet.prototype.sort = function(columnNames, sortOrder)
+{
+	// columnNames can be either the name of a column to
+	// sort on, or an array of column names, but it can't be
+	// null/undefined.
+
+	if (!columnNames)
+		return;
+
+	// If only one column name was specified for sorting, do a
+	// secondary sort on ds_RowID so we get a stable sort order.
+
+	if (typeof columnNames == &quot;string&quot;)
+		columnNames = [ columnNames, &quot;ds_RowID&quot; ];
+	else if (columnNames.length &lt; 2 &amp;&amp; columnNames[0] != &quot;ds_RowID&quot;)
+		columnNames.push(&quot;ds_RowID&quot;);
+
+	if (!sortOrder)
+		sortOrder = &quot;toggle&quot;;
+
+	if (sortOrder == &quot;toggle&quot;)
+	{
+		if (this.lastSortColumns.length &gt; 0 &amp;&amp; this.lastSortColumns[0] == columnNames[0] &amp;&amp; this.lastSortOrder == &quot;ascending&quot;)
+			sortOrder = &quot;descending&quot;;
+		else
+			sortOrder = &quot;ascending&quot;;
+	}
+
+	if (sortOrder != &quot;ascending&quot; &amp;&amp; sortOrder != &quot;descending&quot;)
+	{
+		Spry.Debug.reportError(&quot;Invalid sort order type specified: &quot; + sortOrder + &quot;\n&quot;);
+		return;
+	}
+
+	var nData = {
+		oldSortColumns: this.lastSortColumns,
+		oldSortOrder: this.lastSortOrder,
+		newSortColumns: columnNames,
+		newSortOrder: sortOrder
+	};
+	this.notifyObservers(&quot;onPreSort&quot;, nData);
+
+	var cname = columnNames[columnNames.length - 1];
+	var sortfunc = Spry.Data.DataSet.prototype.sort.getSortFunc(cname, this.getColumnType(cname), sortOrder);
+
+	for (var i = columnNames.length - 2; i &gt;= 0; i--)
+	{
+		cname = columnNames[i];
+		sortfunc = Spry.Data.DataSet.prototype.sort.buildSecondarySortFunc(Spry.Data.DataSet.prototype.sort.getSortFunc(cname, this.getColumnType(cname), sortOrder), sortfunc);
+	}
+
+	if (this.unfilteredData)
+	{
+		this.unfilteredData.sort(sortfunc);
+		if (this.filterFunc)
+			this.filter(this.filterFunc, true);
+	}
+	else
+		this.data.sort(sortfunc);
+
+	this.lastSortColumns = columnNames.slice(0); // Copy the array.
+	this.lastSortOrder = sortOrder;
+
+	this.notifyObservers(&quot;onPostSort&quot;, nData);
+};
+
+Spry.Data.DataSet.prototype.sort.getSortFunc = function(prop, type, order)
+{
+	var sortfunc = null;
+	if (type == &quot;number&quot;)
+	{
+		if (order == &quot;ascending&quot;)
+			sortfunc = function(a, b){ return a[prop]-b[prop]; };
+		else // order == &quot;descending&quot;
+			sortfunc = function(a, b){ return b[prop]-a[prop]; };
+	}
+	else if (type == &quot;date&quot;)
+	{
+		if (order == &quot;ascending&quot;)
+			sortfunc = function(a, b)
+			{
+				var dA = a[prop];
+				var dB = b[prop];			
+				dA = dA ? (new Date(dA)) : 0;
+				dB = dB ? (new Date(dB)) : 0;
+				return dA - dB;
+			};
+		else // order == &quot;descending&quot;
+			sortfunc = function(a, b)
+			{
+				var dA = a[prop];
+				var dB = b[prop];			
+				dA = dA ? (new Date(dA)) : 0;
+				dB = dB ? (new Date(dB)) : 0;
+				return dB - dA;
+			};
+	}
+	else // type == &quot;string&quot;
+	{
+		if (order == &quot;ascending&quot;)
+			sortfunc = function(a, b){
+				var tA = a[prop].toString();
+				var tB = b[prop].toString();
+				var tA_l = tA.toLowerCase();
+				var tB_l = tB.toLowerCase();
+				var min_len = tA.length &gt; tB.length ? tB.length : tA.length;
+
+				for (var i=0; i &lt; min_len; i++){
+					var a_l_c = tA_l.charAt(i);
+					var b_l_c = tB_l.charAt(i);
+					var a_c = tA.charAt(i);
+					var b_c = tB.charAt(i);
+					if (a_l_c &gt; b_l_c){
+							return 1;
+					}else if (a_l_c &lt; b_l_c){
+						 return -1;
+					}else if (a_c &gt; b_c){
+						 return 1;
+					}else if (a_c &lt; b_c){
+						 return -1;
+					}
+				}
+				if(tA.length == tB.length){
+					return 0;
+				}else if (tA.length &gt; tB.length){
+					return 1;
+				}else{
+					return -1;	
+				}
+			};
+		else // order == &quot;descending&quot;
+			sortfunc = function(a, b){
+				var tA = a[prop].toString();
+				var tB = b[prop].toString();
+				var tA_l = tA.toLowerCase();
+				var tB_l = tB.toLowerCase();
+				var min_len = tA.length &gt; tB.length ? tB.length : tA.length;
+				for (var i=0; i &lt; min_len; i++){
+					var a_l_c = tA_l.charAt(i);
+					var b_l_c = tB_l.charAt(i);
+					var a_c = tA.charAt(i);
+					var b_c = tB.charAt(i);
+					if (a_l_c &gt; b_l_c){
+							return -1;
+					}else if (a_l_c &lt; b_l_c){
+						 return 1;
+					}else if (a_c &gt; b_c){
+						 return -1;
+					}else if (a_c &lt; b_c){
+						 return 1;
+					}
+				}
+				if(tA.length == tB.length){
+					return 0;
+				}else if (tA.length &gt; tB.length){
+					return -1;
+				}else{
+					return 1;	
+				}
+			};	
+     }
+
+	return sortfunc;
+};
+
+Spry.Data.DataSet.prototype.sort.buildSecondarySortFunc = function(funcA, funcB)
+{
+	return function(a, b)
+	{
+		var ret = funcA(a, b);
+		if (ret == 0)
+			ret = funcB(a, b);
+		return ret;
+	};
+};
+
+Spry.Data.DataSet.prototype.filterData = function(filterFunc, filterOnly)
+{
+	// This is a destructive filter function.
+	
+	var dataChanged = false;
+
+	if (!filterFunc)
+	{
+		// Caller wants to remove the filter.
+
+		this.filterDataFunc = null;
+		dataChanged = true;
+	}
+	else
+	{
+		this.filterDataFunc = filterFunc;
+		
+		if (this.dataWasLoaded &amp;&amp; ((this.unfilteredData &amp;&amp; this.unfilteredData.length) || (this.data &amp;&amp; this.data.length)))
+		{
+			if (this.unfilteredData)
+			{
+				this.data = this.unfilteredData;
+				this.unfilteredData = null;
+			}
+	
+			var oldData = this.data;
+			this.data = [];
+			this.dataHash = {};
+	
+			for (var i = 0; i &lt; oldData.length; i++)
+			{
+				var newRow = filterFunc(this, oldData[i], i);
+				if (newRow)
+				{
+					this.data.push(newRow);
+					this.dataHash[newRow[&quot;ds_RowID&quot;]] = newRow;
+				}
+			}
+	
+			dataChanged = true;
+		}
+	}
+
+	if (dataChanged)
+	{
+		if (!filterOnly)
+		{
+			this.disableNotifications();
+			if (this.filterFunc)
+				this.filter(this.filterFunc, true);
+			this.enableNotifications();
+		}
+
+		this.notifyObservers(&quot;onDataChanged&quot;);
+	}
+};
+
+Spry.Data.DataSet.prototype.filter = function(filterFunc, filterOnly)
+{
+	// This is a non-destructive filter function.
+
+	var dataChanged = false;
+
+	if (!filterFunc)
+	{
+		if (this.filterFunc &amp;&amp; this.unfilteredData)
+		{
+			// Caller wants to remove the filter. Restore the unfiltered
+			// data and trigger a data changed notification.
+	
+			this.data = this.unfilteredData;
+			this.unfilteredData = null;
+			this.filterFunc = null;
+			dataChanged = true;
+		}
+	}
+	else
+	{
+		this.filterFunc = filterFunc;
+		
+		if (this.dataWasLoaded &amp;&amp; (this.unfilteredData || (this.data &amp;&amp; this.data.length)))
+		{
+			if (!this.unfilteredData)
+				this.unfilteredData = this.data;
+	
+			var udata = this.unfilteredData;
+			this.data = [];
+	
+			for (var i = 0; i &lt; udata.length; i++)
+			{
+				var newRow = filterFunc(this, udata[i], i);
+	
+				if (newRow)
+					this.data.push(newRow);
+			}
+	
+			dataChanged = true;
+		}
+	}
+
+	if (dataChanged)
+		this.notifyObservers(&quot;onDataChanged&quot;);
+};
+
+Spry.Data.DataSet.prototype.startLoadInterval = function(interval)
+{
+	this.stopLoadInterval();
+	if (interval &gt; 0)
+	{
+		var self = this;
+		this.loadInterval = interval;
+		this.loadIntervalID = setInterval(function() { self.loadData(); }, interval);
+	}
+};
+
+Spry.Data.DataSet.prototype.stopLoadInterval = function()
+{
+	if (this.loadIntervalID)
+		clearInterval(this.loadIntervalID);
+	this.loadInterval = 0;
+	this.loadIntervalID = null;
+};
+
+Spry.Data.DataSet.nextDataSetID = 0;
+
+//////////////////////////////////////////////////////////////////////
+//
+// Spry.Data.XMLDataSet
+//
+//////////////////////////////////////////////////////////////////////
+
+Spry.Data.XMLDataSet = function(dataSetURL, dataSetPath, dataSetOptions)
+{
+	// Call the constructor for our DataSet base class so that
+	// our base class properties get defined. We'll call setOptions
+	// manually after we set up our XMLDataSet properties.
+
+	Spry.Data.DataSet.call(this);
+	
+	// XMLDataSet Properties:
+
+	this.url = dataSetURL;
+	this.xpath = dataSetPath;
+	this.doc = null;
+	this.dataSetsForDataRefStrings = new Array;
+	this.hasDataRefStrings = false;
+	this.useCache = true;
+
+	// Create a loadURL request object to store any load options
+	// the caller specified. We'll fill in the URL at the last minute
+	// before we make the actual load request because our URL needs
+	// to be processed at the last possible minute in case it contains
+	// data references.
+
+	this.requestInfo = new Spry.Utils.loadURL.Request();
+	this.requestInfo.extractRequestOptions(dataSetOptions, true);
+
+	// If the caller wants to use &quot;POST&quot; to fetch the data, but didn't
+	// provide the content type, default to x-www-form-urlencoded.
+
+	if (this.requestInfo.method == &quot;POST&quot;)
+	{
+		if (!this.requestInfo.headers)
+			this.requestInfo.headers = {};
+		if (!this.requestInfo.headers['Content-Type'])
+			this.requestInfo.headers['Content-Type'] = &quot;application/x-www-form-urlencoded; charset=UTF-8&quot;;
+	}
+
+	Spry.Utils.setOptions(this, dataSetOptions, true);
+	
+	this.recalculateDataSetDependencies();
+
+	if (this.loadInterval &gt; 0)
+		this.startLoadInterval(this.loadInterval);
+}; // End of Spry.Data.XMLDataSet() constructor.
+
+Spry.Data.XMLDataSet.prototype = new Spry.Data.DataSet();
+Spry.Data.XMLDataSet.prototype.constructor = Spry.Data.XMLDataSet;
+
+Spry.Data.XMLDataSet.prototype.recalculateDataSetDependencies = function()
+{
+	this.hasDataRefStrings = false;
+
+	if (!this.url)
+		return;
+
+	// Clear all old callbacks that may have been registered.
+
+	var i = 0;
+	for (i = 0; i &lt; this.dataSetsForDataRefStrings.length; i++)
+	{
+		var ds = this.dataSetsForDataRefStrings[i];
+		if (ds)
+			ds.removeObserver(this);
+	}
+
+	// Now run through the strings that may contain data references and figure
+	// out what data sets they require. Note that the data references in these
+	// strings must be fully qualified with a data set name. (ex: {dsDataSetName::columnName})
+
+	this.dataSetsForDataRefStrings = new Array();
+
+	var regionStrs = [ this.url, this.xpath, this.requestInfo.postData ];
+
+	// If postData exists, and is a string, we want to check it for data refs.
+	var postData = this.requestInfo.postData;
+	if (postData &amp;&amp; (typeof postData) == &quot;string&quot;)
+		regionStrs.push(postData);
+
+	var dsCount = 0;
+
+	for (var n = 0; n &lt; regionStrs.length; n++)
+	{
+		var tokens = Spry.Data.Region.getTokensFromStr(regionStrs[n]);
+
+		for (i = 0; tokens &amp;&amp; i &lt; tokens.length; i++)
+		{
+			if (tokens[i].search(/{[^}:]+::[^}]+}/) != -1)
+			{
+				var dsName = tokens[i].replace(/^\{|::.*\}/g, &quot;&quot;);
+				var ds = null;
+				if (!this.dataSetsForDataRefStrings[dsName])
+				{
+					try { ds = eval(dsName); } catch (e) { ds = null; }
+	
+					if (dsName &amp;&amp; ds)
+					{
+						// The dataSetsForDataRefStrings array serves as both an
+						// array of data sets and a hash lookup by name.
+
+						this.dataSetsForDataRefStrings[dsName] = ds;
+						this.dataSetsForDataRefStrings[dsCount++] = ds;
+						this.hasDataRefStrings = true;
+					}
+				}
+			}
+		}
+	}
+
+	// Set up observers on any data sets our URL depends on.
+
+	for (i = 0; i &lt; this.dataSetsForDataRefStrings.length; i++)
+	{
+		var ds = this.dataSetsForDataRefStrings[i];
+		ds.addObserver(this);
+	}
+};
+
+Spry.Data.XMLDataSet.prototype.attemptLoadData = function()
+{
+	// We only want to trigger a load when all of our data sets have data!
+	for (var i = 0; i &lt; this.dataSetsForDataRefStrings.length; i++)
+	{
+		var ds = this.dataSetsForDataRefStrings[i];
+		if (ds.getLoadDataRequestIsPending() || !ds.getDataWasLoaded())
+			return;
+	}
+
+	this.loadData();
+};
+
+Spry.Data.XMLDataSet.prototype.onCurrentRowChanged = function(ds, data)
+{
+	this.attemptLoadData();
+};
+
+Spry.Data.XMLDataSet.prototype.onPostSort = function(ds, data)
+{
+	this.attemptLoadData();
+};
+			
+Spry.Data.XMLDataSet.prototype.onDataChanged = function(ds, data)
+{
+	this.attemptLoadData();
+};
+			
+Spry.Data.XMLDataSet.prototype.loadData = function()
+{
+	if (!this.url || !this.xpath)
+		return;
+
+	this.cancelLoadData();
+
+	var url = this.url;
+	var postData = this.requestInfo.postData;
+
+	if (this.hasDataRefStrings)
+	{
+		var allDataSetsReady = true;
+
+		for (var i = 0; i &lt; this.dataSetsForDataRefStrings.length; i++)
+		{
+			var ds = this.dataSetsForDataRefStrings[i];
+			if (ds.getLoadDataRequestIsPending())
+				allDataSetsReady = false;
+			else if (!ds.getDataWasLoaded())
+			{
+				// Kick off the load of this data set!
+				ds.loadData();
+				allDataSetsReady = false;
+			}
+		}
+
+		// If our data sets aren't ready, just return. We'll
+		// get called back to load our data when they are all
+		// done.
+
+		if (!allDataSetsReady)
+			return;
+
+		url = Spry.Data.Region.processDataRefString(null, this.url, this.dataSetsForDataRefStrings);
+		if (!url)
+			return;
+			
+		if (postData &amp;&amp; (typeof postData) == &quot;string&quot;)
+			postData = Spry.Data.Region.processDataRefString(null, postData, this.dataSetsForDataRefStrings);
+	}
+
+	this.notifyObservers(&quot;onPreLoad&quot;);
+
+	this.data = null;
+	this.dataWasLoaded = false;
+	this.unfilteredData = null;
+	this.dataHash = null;
+	this.curRowID = 0;
+
+	// At this point the url should've been processed if it contained any
+	// data references. Set the url of the requestInfo structure and pass it
+	// to LoadManager.loadData().
+
+	var req = this.requestInfo.clone();
+	req.url = url;
+	req.postData = postData;
+
+	this.pendingRequest = new Object;
+	this.pendingRequest.data = Spry.Data.XMLDataSet.LoadManager.loadData(req, this, this.useCache);
+};
+
+Spry.Data.XMLDataSet.prototype.cancelLoadData = function()
+{
+	if (this.pendingRequest)
+	{
+		Spry.Data.XMLDataSet.LoadManager.cancelLoadData(this.pendingRequest.data, this);
+		this.pendingRequest = null;
+	}
+};
+
+Spry.Data.XMLDataSet.prototype.getURL = function() { return this.url; };
+Spry.Data.XMLDataSet.prototype.setURL = function(url, requestOptions)
+{
+	if (this.url == url)
+		return;
+	this.url = url;
+
+	if (requestOptions)
+		this.requestInfo.extractRequestOptions(requestOptions);
+
+	this.cancelLoadData();
+	this.recalculateDataSetDependencies();
+	this.dataWasLoaded = false;
+};
+Spry.Data.XMLDataSet.prototype.getDocument = function() { return this.doc; };
+Spry.Data.XMLDataSet.prototype.getXPath = function() { return this.xpath; };
+Spry.Data.XMLDataSet.prototype.setXPath = function(path)
+{
+	if (this.xpath != path)
+	{
+		this.xpath = path;
+		if (this.dataWasLoaded &amp;&amp; this.doc)
+			this.setDataFromDoc(this.doc);
+	}
+};
+
+Spry.Data.XMLDataSet.prototype.setDataFromDoc = function(doc)
+{
+	this.pendingRequest = null;
+
+	var rs = null;
+
+	rs = Spry.Utils.getRecordSetFromXMLDoc(doc, Spry.Data.Region.processDataRefString(null, this.xpath, this.dataSetsForDataRefStrings));
+
+	if (!rs)
+	{
+		Spry.Debug.reportError(&quot;Spry.Data.XMLDataSet.setDataFromDoc() failed to create dataSet '&quot; + this.name + &quot;'for '&quot; + this.xpath + &quot;' - &quot; + this.url + &quot;\n&quot;);
+		return;
+	}
+
+	this.doc = rs.xmlDoc;
+	this.data = rs.data;
+	this.dataHash = rs.dataHash;
+	this.dataWasLoaded = (this.doc != null);
+
+	// If there is a data filter installed, run it.
+
+	if (this.filterDataFunc)
+		this.filterData(this.filterDataFunc, true);
+
+	// If the distinct flag was set, run through all the records in the recordset
+	// and toss out any that are duplicates.
+
+	if (this.distinctOnLoad)
+		this.distinct();
+
+	// If sortOnLoad was set, sort the data based on the columns
+	// specified in sortOnLoad.
+
+	if (this.keepSorted &amp;&amp; this.getSortColumn())
+		this.sort(this.lastSortColumns, this.lastSortOrder)
+	else if (this.sortOnLoad)
+		this.sort(this.sortOnLoad, this.sortOrderOnLoad);
+
+	// If there is a view filter installed, run it.
+
+	if (this.filterFunc)
+		this.filter(this.filterFunc, true);
+
+	// The default &quot;current&quot; row is the first row of the data set.
+	if (this.data &amp;&amp; this.data.length &gt; 0)
+		this.curRowID = this.data[0]['ds_RowID'];
+	else
+		this.curRowID = 0;
+
+	this.notifyObservers(&quot;onPostLoad&quot;);
+	this.notifyObservers(&quot;onDataChanged&quot;);
+};
+
+Spry.Data.XMLDataSet.prototype.onRequestResponse = function(cachedRequest, req)
+{
+	this.setDataFromDoc(cachedRequest.doc);
+};
+
+Spry.Data.XMLDataSet.prototype.onRequestError = function(cachedRequest, req)
+{
+	this.notifyObservers(&quot;onLoadError&quot;, req);
+	// Spry.Debug.reportError(&quot;Spry.Data.XMLDataSet.LoadManager.CachedRequest.loadDataCallback(&quot; + req.xhRequest.status + &quot;) failed to load: &quot; + req.url + &quot;\n&quot;);
+};
+
+Spry.Data.XMLDataSet.LoadManager = {};
+Spry.Data.XMLDataSet.LoadManager.cache = [];
+
+Spry.Data.XMLDataSet.LoadManager.CachedRequest = function(reqInfo)
+{
+	Spry.Utils.Notifier.call(this);
+
+	this.reqInfo = reqInfo;
+	this.doc = null;
+	this.timer = null;
+	this.state = Spry.Data.XMLDataSet.LoadManager.CachedRequest.NOT_LOADED;
+};
+
+Spry.Data.XMLDataSet.LoadManager.CachedRequest.prototype = new Spry.Utils.Notifier();
+Spry.Data.XMLDataSet.LoadManager.CachedRequest.prototype.constructor = Spry.Data.XMLDataSet.LoadManager.CachedRequest;
+
+Spry.Data.XMLDataSet.LoadManager.CachedRequest.NOT_LOADED      = 1;
+Spry.Data.XMLDataSet.LoadManager.CachedRequest.LOAD_REQUESTED  = 2;
+Spry.Data.XMLDataSet.LoadManager.CachedRequest.LOAD_FAILED     = 3;
+Spry.Data.XMLDataSet.LoadManager.CachedRequest.LOAD_SUCCESSFUL = 4;
+
+Spry.Data.XMLDataSet.LoadManager.CachedRequest.prototype.loadDataCallback = function(req)
+{
+	if (req.xhRequest.readyState != 4)
+		return;
+
+	var xmlDoc = req.xhRequest.responseXML;
+
+	if (req.xhRequest.status != 200)
+	{
+		if (req.xhRequest.status == 0)
+		{
+			// The page that is attempting to load data was probably loaded with
+			// a <A HREF="file://">file://</A> url. Mozilla based browsers will actually provide the complete DOM
+			// tree for the data, but IE provides an empty document node so try to parse
+			// the xml text manually to create a dom tree we can use.
+
+			if (req.xhRequest.responseText &amp;&amp; (!xmlDoc || !xmlDoc.firstChild))
+				xmlDoc = Spry.Utils.stringToXMLDoc(req.xhRequest.responseText);
+		}
+	}
+
+	if (!xmlDoc  || !xmlDoc.firstChild || xmlDoc.firstChild.nodeName == &quot;parsererror&quot;)
+	{
+		this.state = Spry.Data.XMLDataSet.LoadManager.CachedRequest.LOAD_FAILED;
+		this.notifyObservers(&quot;onRequestError&quot;, req);
+		this.observers.length = 0; // Clear the observers list.
+		return;
+	}
+
+	this.doc = xmlDoc;
+	this.state = Spry.Data.XMLDataSet.LoadManager.CachedRequest.LOAD_SUCCESSFUL;
+
+	// Notify all of the cached request's observers!
+	this.notifyObservers(&quot;onRequestResponse&quot;, req);
+
+	// Clear the observers list.
+	this.observers.length = 0;
+};
+
+Spry.Data.XMLDataSet.LoadManager.CachedRequest.prototype.loadData = function()
+{
+	// IE will synchronously fire our loadDataCallback() during the call
+	// to an async Spry.Utils.loadURL() if the data for the url is already
+	// in the browser's local cache. This can wreak havoc with complicated master/detail
+	// regions that use data sets that have master/detail relationships with other
+	// data sets. Our data set logic already handles async data loading nicely so we
+	// use a timer to fire off the async Spry.Utils.loadURL() call to insure that any
+	// data loading happens asynchronously after this function is finished.
+
+	var self = this;
+	this.cancelLoadData();
+	this.doc = null;
+	this.state = Spry.Data.XMLDataSet.LoadManager.CachedRequest.LOAD_REQUESTED;
+
+	var reqInfo = this.reqInfo.clone();
+	reqInfo.successCallback = function(req) { self.loadDataCallback(req); };
+	reqInfo.errorCallback = reqInfo.successCallback;
+
+	this.timer = setTimeout(function()
+	{
+		self.timer = null;
+		Spry.Utils.loadURL(reqInfo.method, reqInfo.url, reqInfo.async, reqInfo.successCallback, reqInfo);
+	}, 0);  
+};
+
+Spry.Data.XMLDataSet.LoadManager.CachedRequest.prototype.cancelLoadData = function()
+{
+	if (this.state == Spry.Data.XMLDataSet.LoadManager.CachedRequest.LOAD_REQUESTED)
+	{
+		if (this.timer)
+		{
+			this.timer.clearTimeout();
+			this.timer = null;
+		}
+
+		this.doc = null;
+		this.state = Spry.Data.XMLDataSet.LoadManager.CachedRequest.NOT_LOADED;
+	}
+};
+
+Spry.Data.XMLDataSet.LoadManager.getCacheKey = function(reqInfo)
+{
+	return reqInfo.method + &quot;::&quot; + reqInfo.url + &quot;::&quot; + reqInfo.postData + &quot;::&quot; + reqInfo.username;
+};
+
+Spry.Data.XMLDataSet.LoadManager.loadData = function(reqInfo, ds, useCache)
+{
+	if (!reqInfo)
+		return null;
+
+	var cacheObj = null;
+	var cacheKey = null;
+
+	if (useCache)
+	{
+		cacheKey = Spry.Data.XMLDataSet.LoadManager.getCacheKey(reqInfo);
+		cacheObj = Spry.Data.XMLDataSet.LoadManager.cache[cacheKey];
+	}
+
+	if (cacheObj)
+	{
+		if (cacheObj.state == Spry.Data.XMLDataSet.LoadManager.CachedRequest.LOAD_REQUESTED)
+		{
+			if (ds)
+				cacheObj.addObserver(ds);
+			return cacheObj;
+		}
+		else if (cacheObj.state == Spry.Data.XMLDataSet.LoadManager.CachedRequest.LOAD_SUCCESSFUL)
+		{
+			// Data is already cached so if we have a data set, trigger an async call
+			// that tells it to load its data.
+			if (ds)
+				setTimeout(function() { ds.setDataFromDoc(cacheObj.doc); }, 0);
+			return cacheObj;
+		}
+	}
+
+	// We're either loading this url for the first time, or an error occurred when
+	// we last tried to load it, or the caller requested a forced load.
+
+	if (!cacheObj)
+	{
+		cacheObj = new Spry.Data.XMLDataSet.LoadManager.CachedRequest(reqInfo);
+		if (useCache)
+		{
+			Spry.Data.XMLDataSet.LoadManager.cache[cacheKey] = cacheObj;
+
+			// Add an observer that will remove the cacheObj from the cache
+			// if there is a load request failure.
+			cacheObj.addObserver({ onRequestError: function() { Spry.Data.XMLDataSet.LoadManager.cache[cacheKey] = undefined; }});
+		}
+	}
+
+	if (ds)
+		cacheObj.addObserver(ds);
+
+	cacheObj.loadData();
+
+	return cacheObj;
+};
+
+Spry.Data.XMLDataSet.LoadManager.cancelLoadData = function(cacheObj, ds)
+{
+	if (cacheObj)
+	{
+		if (ds)
+			cacheObj.removeObserver(ds);
+		else
+			cacheObj.cancelLoadData();
+	}
+};
+
+//////////////////////////////////////////////////////////////////////
+//
+// Spry.Data.Region
+//
+//////////////////////////////////////////////////////////////////////
+ 
+Spry.Data.Region = function(regionNode, name, isDetailRegion, data, dataSets, regionStates, regionStateMap, hasBehaviorAttributes)
+{
+	this.regionNode = regionNode;
+	this.name = name;
+	this.isDetailRegion = isDetailRegion;
+	this.data = data;
+	this.dataSets = dataSets;
+	this.hasBehaviorAttributes = hasBehaviorAttributes;
+	this.tokens = null;
+	this.currentState = null;
+	this.states = { ready: true };
+	this.stateMap = {};
+
+	Spry.Utils.setOptions(this.states, regionStates);
+	Spry.Utils.setOptions(this.stateMap, regionStateMap);
+
+	// Add the region as an observer to the dataSet!
+	for (var i = 0; i &lt; this.dataSets.length; i++)
+	{
+		var ds = this.dataSets[i];
+
+		try 
+		{
+			if (ds)
+				ds.addObserver(this);
+		}
+		catch(e) { Spry.Debug.reportError(&quot;Failed to add '&quot; + this.name + &quot;' as a dataSet observer!\n&quot;); }
+	}
+}; // End of Spry.Data.Region() constructor.
+
+Spry.Data.Region.hiddenRegionClassName = &quot;SpryHiddenRegion&quot;;
+Spry.Data.Region.evenRowClassName = &quot;even&quot;;
+Spry.Data.Region.oddRowClassName = &quot;odd&quot;;
+Spry.Data.Region.notifiers = {};
+Spry.Data.Region.evalScripts = true;
+
+Spry.Data.Region.addObserver = function(regionID, observer)
+{
+	var n = Spry.Data.Region.notifiers[regionID];
+	if (!n)
+	{
+		n = new Spry.Utils.Notifier();
+		Spry.Data.Region.notifiers[regionID] = n;
+	}
+	n.addObserver(observer);
+};
+
+Spry.Data.Region.removeObserver = function(regionID, observer)
+{
+	var n = Spry.Data.Region.notifiers[regionID];
+	if (n)
+		n.removeObserver(observer);
+};
+
+Spry.Data.Region.notifyObservers = function(methodName, region, data)
+{
+	var n = Spry.Data.Region.notifiers[region.name];
+	if (n)
+	{
+		var dataObj = {};
+		if (data &amp;&amp; typeof data == &quot;object&quot;)
+			dataObj = data;
+		else
+			dataObj.data = data;
+
+		dataObj.region = region;
+		dataObj.regionID = region.name;
+		dataObj.regionNode = region.regionNode;
+
+		n.notifyObservers(methodName, dataObj);
+	}
+};
+
+Spry.Data.Region.RS_Error = 0x01;
+Spry.Data.Region.RS_LoadingData = 0x02;
+Spry.Data.Region.RS_PreUpdate = 0x04;
+Spry.Data.Region.RS_PostUpdate = 0x08;
+
+Spry.Data.Region.prototype.getState = function()
+{
+	return this.currentState;
+};
+
+Spry.Data.Region.prototype.mapState = function(stateName, newStateName)
+{
+	this.stateMap[stateName] = newStateName;
+};
+
+Spry.Data.Region.prototype.getMappedState = function(stateName)
+{
+	var mappedState = this.stateMap[stateName];
+	return mappedState ? mappedState : stateName;
+};
+
+Spry.Data.Region.prototype.setState = function(stateName, suppressNotfications)
+{
+	var stateObj = { state: stateName, mappedState: this.getMappedState(stateName) };
+	if (!suppressNotfications)
+		Spry.Data.Region.notifyObservers(&quot;onPreStateChange&quot;, this, stateObj);
+
+	this.currentState = stateObj.mappedState ? stateObj.mappedState : stateName;
+
+	// If the region has content that is specific to this
+	// state, regenerate the region so that its markup is updated.
+
+	if (this.states[stateName])
+	{
+		if (!suppressNotfications)
+			Spry.Data.Region.notifyObservers(&quot;onPreUpdate&quot;, this, { state: this.currentState });
+	
+		// Make the region transform the xml data. The result is
+		// a string that we need to parse and insert into the document.
+		var str = this.transform();
+	
+		// Clear out any previous transformed content.
+		// this.clearContent();
+	
+		if (Spry.Data.Region.debug)
+			Spry.Debug.trace(&quot;&lt;hr /&gt;Generated region markup for '&quot; + this.name + &quot;':&lt;br /&gt;&lt;br /&gt;&quot; + Spry.Utils.encodeEntities(str));
+
+		// Now insert the new transformed content into the document.
+		Spry.Utils.setInnerHTML(this.regionNode, str, !Spry.Data.Region.evalScripts);
+	
+		// Now run through the content looking for attributes
+		// that tell us what behaviors to attach to each element.
+		if (this.hasBehaviorAttributes)
+			this.attachBehaviors();
+	
+		if (!suppressNotfications)
+			Spry.Data.Region.notifyObservers(&quot;onPostUpdate&quot;, this, { state: this.currentState });
+	}
+
+	if (!suppressNotfications)
+		Spry.Data.Region.notifyObservers(&quot;onPostStateChange&quot;, this, stateObj);
+};
+
+Spry.Data.Region.prototype.getDataSets = function()
+{
+	return this.dataSets;
+};
+
+Spry.Data.Region.prototype.addDataSet = function(aDataSet)
+{
+	if (!aDataSet)
+		return;
+
+	if (!this.dataSets)
+		this.dataSets = new Array;
+
+	// Check to see if the data set is already in our list.
+
+	for (var i = 0; i &lt; this.dataSets.length; i++)
+	{
+		if (this.dataSets[i] == aDataSet)
+			return; // It's already in our list!
+	}
+
+	this.dataSets.push(aDataSet);
+	aDataSet.addObserver(this);
+};
+
+Spry.Data.Region.prototype.removeDataSet = function(aDataSet)
+{
+	if (!aDataSet || this.dataSets)
+		return;
+
+	for (var i = 0; i &lt; this.dataSets.length; i++)
+	{
+		if (this.dataSets[i] == aDataSet)
+		{
+			this.dataSets.splice(i, 1);
+			aDataSet.removeObserver(this);
+			return;
+		}
+	}
+};
+
+Spry.Data.Region.prototype.onPreLoad = function(dataSet)
+{
+	if (this.currentState != &quot;loading&quot;)
+		this.setState(&quot;loading&quot;);
+};
+
+Spry.Data.Region.prototype.onLoadError = function(dataSet)
+{
+	if (this.currentState != &quot;error&quot;)
+		this.setState(&quot;error&quot;);
+	Spry.Data.Region.notifyObservers(&quot;onError&quot;, this);
+};
+
+Spry.Data.Region.prototype.onCurrentRowChanged = function(dataSet, data)
+{
+	if (this.isDetailRegion)
+		this.updateContent();
+};
+
+Spry.Data.Region.prototype.onPostSort = function(dataSet, data)
+{
+	this.updateContent();
+};
+
+Spry.Data.Region.prototype.onDataChanged = function(dataSet, data)
+{
+	this.updateContent();
+};
+
+Spry.Data.Region.enableBehaviorAttributes = true;
+Spry.Data.Region.behaviorAttrs = {};
+
+Spry.Data.Region.behaviorAttrs[&quot;spry:select&quot;] =
+{
+	attach: function(rgn, node, value)
+	{
+		var selectGroupName = null;
+		try { selectGroupName = node.attributes.getNamedItem(&quot;spry:selectgroup&quot;).value; } catch (e) {}
+		if (!selectGroupName)
+			selectGroupName = &quot;default&quot;;
+
+		Spry.Utils.addEventListener(node, &quot;click&quot;, function(event) { Spry.Utils.SelectionManager.select(selectGroupName, node, value); }, false);
+		
+		if (node.attributes.getNamedItem(&quot;spry:selected&quot;))
+			Spry.Utils.SelectionManager.select(selectGroupName, node, value);
+	}
+};
+
+Spry.Data.Region.behaviorAttrs[&quot;spry:hover&quot;] =
+{
+	attach: function(rgn, node, value)
+	{
+		Spry.Utils.addEventListener(node, &quot;mouseover&quot;, function(event){ Spry.Utils.addClassName(node, value); }, false);
+		Spry.Utils.addEventListener(node, &quot;mouseout&quot;, function(event){ Spry.Utils.removeClassName(node, value); }, false);
+	}
+};
+
+Spry.Data.Region.setUpRowNumberForEvenOddAttr = function(node, attr, value, rowNumAttrName)
+{
+	// The format for the spry:even and spry:odd attributes are as follows:
+	//
+	// &lt;div spry:even=&quot;dataSetName cssEvenClassName&quot; spry:odd=&quot;dataSetName cssOddClassName&quot;&gt;
+	//
+	// The dataSetName is optional, and if not specified, the first data set
+	// listed for the region is used.
+	//
+	// cssEvenClassName and cssOddClassName are required and *must* be specified. They can be
+	// any user defined CSS class name.
+
+	if (!value)
+	{
+		Spry.Debug.showError(&quot;The &quot; + attr + &quot; attribute requires a CSS class name as its value!&quot;);
+		node.attributes.removeNamedItem(attr);
+		return;
+	}
+
+	var dsName = &quot;&quot;;
+	var valArr = value.split(/\s/);
+	if (valArr.length &gt; 1)
+	{
+		// Extract out the data set name and reset the attribute so
+		// that it only contains the CSS class name to use.
+
+		dsName = valArr[0];
+		node.setAttribute(attr, valArr[1]);
+	}
+
+	// Tag the node with an attribute that will allow us to fetch the row
+	// number used when it is written out during the re-generation process.
+
+	node.setAttribute(rowNumAttrName, &quot;{&quot; + (dsName ? (dsName + &quot;::&quot;) : &quot;&quot;) + &quot;ds_RowNumber}&quot;);
+};
+
+Spry.Data.Region.behaviorAttrs[&quot;spry:even&quot;] =
+{
+	setup: function(node, value)
+	{
+		Spry.Data.Region.setUpRowNumberForEvenOddAttr(node, &quot;spry:even&quot;, value, &quot;spryevenrownumber&quot;);
+	},
+
+	attach: function(rgn, node, value)
+	{
+		if (value)
+		{
+			rowNumAttr = node.attributes.getNamedItem(&quot;spryevenrownumber&quot;);
+			if (rowNumAttr &amp;&amp; rowNumAttr.value)
+			{
+				var rowNum = parseInt(rowNumAttr.value);
+				if (rowNum % 2)
+					Spry.Utils.addClassName(node, value);
+			}
+		}
+		node.removeAttribute(&quot;spry:even&quot;);
+		node.removeAttribute(&quot;spryevenrownumber&quot;);
+	}
+};
+
+Spry.Data.Region.behaviorAttrs[&quot;spry:odd&quot;] =
+{
+	setup: function(node, value)
+	{
+		Spry.Data.Region.setUpRowNumberForEvenOddAttr(node, &quot;spry:odd&quot;, value, &quot;spryoddrownumber&quot;);
+	},
+
+	attach: function(rgn, node, value)
+	{
+		if (value)
+		{
+			rowNumAttr = node.attributes.getNamedItem(&quot;spryoddrownumber&quot;);
+			if (rowNumAttr &amp;&amp; rowNumAttr.value)
+			{
+				var rowNum = parseInt(rowNumAttr.value);
+				if (rowNum % 2 == 0)
+					Spry.Utils.addClassName(node, value);
+			}
+		}
+		node.removeAttribute(&quot;spry:odd&quot;);
+		node.removeAttribute(&quot;spryoddrownumber&quot;);
+	}
+};
+
+Spry.Data.Region.setRowAttrClickHandler = function(node, dsName, rowAttr, funcName)
+{
+		if (dsName)
+		{
+			var ds = null;
+			try { ds = Spry.Utils.eval(dsName); } catch(e) { ds = null; };
+			if (ds)
+			{
+				rowIDAttr = node.attributes.getNamedItem(rowAttr);
+				if (rowIDAttr)
+				{
+					var rowAttrVal = rowIDAttr.value;
+					if (rowAttrVal)
+						Spry.Utils.addEventListener(node, &quot;click&quot;, function(event){ ds[funcName](rowAttrVal); }, false);
+				}
+			}
+		}
+};
+
+Spry.Data.Region.behaviorAttrs[&quot;spry:setrow&quot;] =
+{
+	setup: function(node, value)
+	{
+		if (!value)
+		{
+			Spry.Debug.reportError(&quot;The spry:setrow attribute requires a data set name as its value!&quot;);
+			node.removeAttribute(&quot;spry:setrow&quot;);
+			return;
+		}
+
+		// Tag the node with an attribute that will allow us to fetch the id of the
+		// row used when it is written out during the re-generation process.
+
+		node.setAttribute(&quot;spryrowid&quot;, &quot;{&quot; + value + &quot;::ds_RowID}&quot;);
+	},
+
+	attach: function(rgn, node, value)
+	{
+		Spry.Data.Region.setRowAttrClickHandler(node, value, &quot;spryrowid&quot;, &quot;setCurrentRow&quot;);
+		node.removeAttribute(&quot;spry:setrow&quot;);
+		node.removeAttribute(&quot;spryrowid&quot;);
+	}
+};
+
+Spry.Data.Region.behaviorAttrs[&quot;spry:setrownumber&quot;] =
+{
+	setup: function(node, value)
+	{
+		if (!value)
+		{
+			Spry.Debug.reportError(&quot;The spry:setrownumber attribute requires a data set name as its value!&quot;);
+			node.removeAttribute(&quot;spry:setrownumber&quot;);
+			return;
+		}
+
+		// Tag the node with an attribute that will allow us to fetch the row number
+		// of the row used when it is written out during the re-generation process.
+
+		node.setAttribute(&quot;spryrownumber&quot;, &quot;{&quot; + value + &quot;::ds_RowID}&quot;);
+	},
+
+	attach: function(rgn, node, value)
+	{
+		Spry.Data.Region.setRowAttrClickHandler(node, value, &quot;spryrownumber&quot;, &quot;setCurrentRowNumber&quot;);
+		node.removeAttribute(&quot;spry:setrownumber&quot;);
+		node.removeAttribute(&quot;spryrownumber&quot;);
+	}
+};
+
+Spry.Data.Region.behaviorAttrs[&quot;spry:sort&quot;] =
+{
+	attach: function(rgn, node, value)
+	{
+		if (!value)
+			return;
+
+		// The format of a spry:sort attribute is as follows:
+		//
+		// &lt;div spry:sort=&quot;dataSetName column1Name column2Name ... sortOrderName&quot;&gt;
+		//
+		// The dataSetName and sortOrderName are optional, but when specified, they
+		// must appear in the order mentioned above. If the dataSetName is not specified,
+		// the first data set listed for the region is used. If the sortOrderName is not
+		// specified, the sort defaults to &quot;toggle&quot;.
+		//
+		// The user *must* specify at least one column name.
+
+		var ds = rgn.getDataSets()[0];
+		var sortOrder = &quot;toggle&quot;;
+
+		var colArray = value.split(/\s/);
+		if (colArray.length &gt; 1)
+		{
+			// Check the first string in the attribute to see if a data set was
+			// specified. If so, make sure we use it for the sort.
+
+			try
+			{
+				var specifiedDS = eval(colArray[0]);
+				if (specifiedDS &amp;&amp; (typeof specifiedDS) == &quot;object&quot;)
+				{
+					ds = specifiedDS;
+					colArray.shift();
+				}
+
+			} catch(e) {}
+
+			// Check to see if the last string in the attribute is the name of
+			// a sort order. If so, use that sort order during the sort.
+
+			if (colArray.length &gt; 1)
+			{
+				var str = colArray[colArray.length - 1];
+				if (str == &quot;ascending&quot; || str == &quot;descending&quot; || str == &quot;toggle&quot;)
+				{
+					sortOrder = str;
+					colArray.pop();
+				}
+			}
+		}
+
+		// If we have a data set and some column names, add a non-destructive
+		// onclick handler that will perform a toggle sort on the data set.
+
+		if (ds &amp;&amp; colArray.length &gt; 0)
+			Spry.Utils.addEventListener(node, &quot;click&quot;, function(event){ ds.sort(colArray, sortOrder); }, false);
+
+		node.removeAttribute(&quot;spry:sort&quot;);
+	}
+};
+
+Spry.Data.Region.prototype.attachBehaviors = function()
+{
+	var rgn = this;
+	Spry.Utils.getNodesByFunc(this.regionNode, function(node)
+	{
+		if (!node || node.nodeType != 1 /* Node.ELEMENT_NODE */)
+			return false;
+		try
+		{
+			var bAttrs = Spry.Data.Region.behaviorAttrs;
+			for (var bAttrName in bAttrs)
+			{
+				var attr = node.attributes.getNamedItem(bAttrName);
+				if (attr)
+				{
+					var behavior = bAttrs[bAttrName];
+					if (behavior &amp;&amp; behavior.attach)
+						behavior.attach(rgn, node, attr.value);
+				}
+			}
+		} catch(e) {}
+
+		return false;
+	});
+};
+
+Spry.Data.Region.prototype.updateContent = function()
+{
+	var allDataSetsReady = true;
+
+	var dsArray = this.getDataSets();
+
+	if (!dsArray || dsArray.length &lt; 1)
+	{
+		Spry.Debug.reportError(&quot;updateContent(): Region '&quot; + this.name + &quot;' has no data set!\n&quot;);
+		return;
+	}
+
+	for (var i = 0; i &lt; dsArray.length; i++)
+	{
+		var ds = dsArray[i];
+
+		if (ds)
+		{
+			if (ds.getLoadDataRequestIsPending())
+				allDataSetsReady = false;
+			else if (!ds.getDataWasLoaded())
+			{
+				// Kick off the loading of the data if it hasn't happened yet.
+				ds.loadData();
+				allDataSetsReady = false;
+			}
+		}
+	}
+
+	if (!allDataSetsReady)
+	{
+		Spry.Data.Region.notifyObservers(&quot;onLoadingData&quot;, this);
+
+		// Just return, this method will get called again automatically
+		// as each data set load completes!
+		return;
+	}
+
+	this.setState(&quot;ready&quot;);
+};
+
+Spry.Data.Region.prototype.clearContent = function()
+{
+	this.regionNode.innerHTML = &quot;&quot;;
+};
+
+Spry.Data.Region.processContentPI = function(inStr)
+{
+	var outStr = &quot;&quot;;
+	var regexp = /&lt;!--\s*&lt;\/?spry:content\s*[^&gt;]*&gt;\s*--&gt;/mg;
+	var searchStartIndex = 0;
+	var processingContentTag = 0;
+
+	while (inStr.length)
+	{
+		var results = regexp.exec(inStr);
+		if (!results || !results[0])
+		{
+			outStr += inStr.substr(searchStartIndex, inStr.length - searchStartIndex);
+			break;
+		}
+
+		if (!processingContentTag &amp;&amp; results.index != searchStartIndex)
+		{
+			// We found a match but it's not at the start of the inStr.
+			// Create a string token for everything that precedes the match.
+			outStr += inStr.substr(searchStartIndex, results.index - searchStartIndex);
+		}
+
+		if (results[0].search(/&lt;\//) != -1)
+		{
+			--processingContentTag;
+			if (processingContentTag)
+				Spry.Debug.reportError(&quot;Nested spry:content regions are not allowed!\n&quot;);
+		}
+		else
+		{
+			++processingContentTag;
+			var dataRefStr = results[0].replace(/.*\bdataref=&quot;/, &quot;&quot;);
+			outStr += dataRefStr.replace(/&quot;.*$/, &quot;&quot;);
+		}
+		
+		searchStartIndex = regexp.lastIndex;
+	}
+
+	return outStr;
+}
+
+Spry.Data.Region.prototype.tokenizeData = function(dataStr)
+{
+	// If there is no data, there's nothing to do.
+	if (!dataStr)
+		return null;
+
+	var rootToken = new Spry.Data.Region.Token(Spry.Data.Region.Token.LIST_TOKEN, null, null, null);
+	var tokenStack = new Array;
+	var parseStr = Spry.Data.Region.processContentPI(dataStr);
+
+	tokenStack.push(rootToken);
+
+	// Create a regular expression that will match one of the following:
+	//
+	//   &lt;spry:repeat select=&quot;regionName&quot; test=&quot;true&quot;&gt;
+	//   &lt;/spry:repeat&gt;
+	//   {valueReference}
+	var regexp = /((&lt;!--\s*){0,1}&lt;\/{0,1}spry:[^&gt;]+&gt;(\s*--&gt;){0,1})|((\{|%7[bB])[^\}\s%]+(\}|%7[dD]))/mg;
+	var searchStartIndex = 0;
+
+	while(parseStr.length)
+	{
+		var results = regexp.exec(parseStr);
+		var token = null;
+		
+		if (!results || !results[0])
+		{
+			// If we get here, the rest of the parseStr should be
+			// just a plain string. Create a token for it and then
+			// break out of the list.
+			var str = parseStr.substr(searchStartIndex, parseStr.length - searchStartIndex);
+			token = new Spry.Data.Region.Token(Spry.Data.Region.Token.STRING_TOKEN, null, str, str);
+			tokenStack[tokenStack.length - 1].addChild(token);
+			break;
+		}
+
+		if (results.index != searchStartIndex)
+		{
+			// We found a match but it's not at the start of the parseStr.
+			// Create a string token for everything that precedes the match.
+			var str = parseStr.substr(searchStartIndex, results.index - searchStartIndex);
+			token = new Spry.Data.Region.Token(Spry.Data.Region.Token.STRING_TOKEN, null, str, str);
+			tokenStack[tokenStack.length - 1].addChild(token);
+		}
+
+		// We found a string that needs to be turned into a token. Create a token
+		// for it and then update parseStr for the next iteration.
+		if (results[0].search(/^({|%7[bB])/) != -1 /* results[0].charAt(0) == '{' */)
+		{
+			var valueName = results[0];
+			var regionStr = results[0];
+			
+			// Strip off brace and url encode brace chars inside the valueName.
+
+			valueName = valueName.replace(/^({|%7[bB])/, &quot;&quot;);
+			valueName = valueName.replace(/(}|%7[dD])$/, &quot;&quot;);
+
+			// Check to see if our value begins with the name of a data set.
+			// For example: {dataSet:tokenValue}. If it is, we need to save
+			// the data set name so we know which data set to use to get the
+			// value for the token during the region transform.
+
+			var dataSetName = null;
+			var splitArray = valueName.split(/::/);
+
+			if (splitArray.length &gt; 1)
+			{
+				dataSetName = splitArray[0];
+				valueName = splitArray[1];
+			}
+
+			// Convert any url encoded braces to regular brace chars.
+
+			regionStr = regionStr.replace(/^%7[bB]/, &quot;{&quot;);
+			regionStr = regionStr.replace(/%7[dD]$/, &quot;}&quot;);
+
+			// Now create a token for the placeholder.
+
+			token = new Spry.Data.Region.Token(Spry.Data.Region.Token.VALUE_TOKEN, dataSetName, valueName, new String(regionStr));
+			tokenStack[tokenStack.length - 1].addChild(token);
+		}
+		else if (results[0].charAt(0) == '&lt;')
+		{
+			// Extract out the name of the processing instruction.
+			var piName = results[0].replace(/^(&lt;!--\s*){0,1}&lt;\/?/, &quot;&quot;);
+			piName = piName.replace(/&gt;(\s*--&gt;){0,1}|\s.*$/, &quot;&quot;);
+			
+			if (results[0].search(/&lt;\//) != -1 /* results[0].charAt(1) == '/' */)
+			{
+				// We found a processing instruction close tag. Pop the top of the
+				// token stack!
+				//
+				// XXX: We need to make sure that the close tag name matches the one
+				//      on the top of the token stack!
+				if (tokenStack[tokenStack.length - 1].tokenType != Spry.Data.Region.Token.PROCESSING_INSTRUCTION_TOKEN)
+				{
+					Spry.Debug.reportError(&quot;Invalid processing instruction close tag: &quot; + piName + &quot; -- &quot; + results[0] + &quot;\n&quot;);
+					return null;
+				}
+
+				tokenStack.pop();
+			}
+			else
+			{
+				// Create the processing instruction token, add it as a child of the token
+				// at the top of the token stack, and then push it on the stack so that it
+				// becomes the parent of any tokens between it and its close tag.
+
+				var piDesc = Spry.Data.Region.PI.instructions[piName];
+
+				if (piDesc)
+				{
+					var dataSet = null;
+
+					var selectedDataSetName = &quot;&quot;;
+					if (results[0].search(/^.*\bselect=\&quot;/) != -1)
+					{
+						selectedDataSetName = results[0].replace(/^.*\bselect=\&quot;/, &quot;&quot;);
+						selectedDataSetName = selectedDataSetName.replace(/&quot;.*$/, &quot;&quot;);
+	
+						if (selectedDataSetName)
+						{
+							try
+							{
+								dataSet = eval(selectedDataSetName);
+							}
+							catch (e)
+							{
+								Spry.Debug.reportError(&quot;Caught exception in tokenizeData() while trying to retrieve data set (&quot; + selectedDataSetName + &quot;): &quot; + e + &quot;\n&quot;);
+								dataSet = null;
+								selectedDataSetName = &quot;&quot;;
+							}
+						}
+					}
+
+					// Check if the repeat has a test attribute.
+					var jsExpr = null;
+					if (results[0].search(/^.*\btest=\&quot;/) != -1)
+					{
+						jsExpr = results[0].replace(/^.*\btest=\&quot;/, &quot;&quot;);
+						jsExpr = jsExpr.replace(/&quot;.*$/, &quot;&quot;);
+						jsExpr = Spry.Utils.decodeEntities(jsExpr);
+					}
+
+					// Check if the instruction has a state name specified.
+					var regionState = null;
+					if (results[0].search(/^.*\bname=\&quot;/) != -1)
+					{
+						regionState = results[0].replace(/^.*\bname=\&quot;/, &quot;&quot;);
+						regionState = regionState.replace(/&quot;.*$/, &quot;&quot;);
+						regionState = Spry.Utils.decodeEntities(regionState);
+					}
+
+					var piData = new Spry.Data.Region.Token.PIData(piName, selectedDataSetName, jsExpr, regionState);
+
+					token = new Spry.Data.Region.Token(Spry.Data.Region.Token.PROCESSING_INSTRUCTION_TOKEN, dataSet, piData, new String(results[0]));
+
+					tokenStack[tokenStack.length - 1].addChild(token);
+					tokenStack.push(token);
+				}
+				else
+				{
+					Spry.Debug.reportError(&quot;Unsupported region processing instruction: &quot; + results[0] + &quot;\n&quot;);
+					return null;
+				}
+			}
+		}
+		else
+		{
+			Spry.Debug.reportError(&quot;Invalid region token: &quot; + results[0] + &quot;\n&quot;);
+			return null;
+		}
+
+		searchStartIndex = regexp.lastIndex;
+	}
+
+	return rootToken;
+};
+
+Spry.Data.Region.prototype.processTokenChildren = function(token, processContext)
+{
+	// The use of an array to gather the strings returned from processing
+	// the child tokens is actually a performance enhancement for IE.
+	// The original code:
+	//
+	//     for (var i = 0; i &lt; token.children.length; i++)
+	//       outputStr += this.processTokens(token.children[i], processContext);
+	//
+	// seemed to cause an n-square problem in IE. Using an array with
+	// a final join reduced one of our test cases (SelectExample.html) from over
+	// a minute to about 15 seconds.
+	
+	var strArr = [ &quot;&quot; ];
+	var len = token.children.length;
+	var children = token.children;
+	
+	for (var i = 0; i &lt; len; i++)
+		strArr.push(this.processTokens(children[i], processContext));
+
+	return strArr.join(&quot;&quot;);
+};
+
+Spry.Data.Region.prototype.processTokens = function(token, processContext)
+{
+	if (!processContext)
+	{
+		processContext = new Spry.Data.Region.ProcessingContext(this);
+		if (!processContext)
+			return &quot;&quot;;
+	}
+
+	var outputStr = &quot;&quot;;
+	var i = 0;
+
+	switch(token.tokenType)
+	{
+		case Spry.Data.Region.Token.LIST_TOKEN:
+			outputStr += this.processTokenChildren(token, processContext);
+			break;
+		case Spry.Data.Region.Token.STRING_TOKEN:
+			outputStr += token.data;
+			break;
+		case Spry.Data.Region.Token.PROCESSING_INSTRUCTION_TOKEN:
+			if (token.data.name == &quot;spry:repeat&quot;)
+			{
+				var dataSet = null;
+
+				if (token.dataSet)
+					dataSet = token.dataSet;
+				else
+					dataSet = this.dataSets[0];
+
+				if (dataSet)
+				{
+					var dsContext = processContext.getDataSetContext(dataSet);
+					if (!dsContext)
+					{
+						Spry.Debug.reportError(&quot;processTokens() failed to get a data set context!\n&quot;);
+						break;
+					}
+
+					var numRows = dsContext.getNumRows();
+					var dataSetRows = dataSet.getData();
+					dsContext.pushState();
+
+					for (i = 0; i &lt; numRows; i++)
+					{
+						dsContext.setRowIndex(i);
+						var testVal = true;
+						if (token.data.jsExpr)
+						{
+							var jsExpr = Spry.Data.Region.processDataRefString(processContext, token.data.jsExpr, null, true);
+							try { testVal = Spry.Utils.eval(jsExpr); }
+							catch(e)
+							{
+								Spry.Debug.trace(&quot;Caught exception in Spry.Data.Region.prototype.processTokens while evaluating: &quot; + jsExpr + &quot;\n    Exception:&quot; + e + &quot;\n&quot;);
+								testVal = true;
+							}
+						}
+
+						if (testVal)
+							outputStr += this.processTokenChildren(token, processContext);
+					}
+
+					dsContext.popState();
+				}
+			}
+			else if (token.data.name == &quot;spry:if&quot;)
+			{
+				var testVal = true;
+				
+				if (token.data.jsExpr)
+				{
+					var jsExpr = Spry.Data.Region.processDataRefString(processContext, token.data.jsExpr, null, true);
+
+					try { testVal = Spry.Utils.eval(jsExpr); }
+					catch(e)
+					{
+						Spry.Debug.trace(&quot;Caught exception in Spry.Data.Region.prototype.processTokens while evaluating: &quot; + jsExpr + &quot;\n    Exception:&quot; + e + &quot;\n&quot;);
+						testVal = true;
+					}
+				}
+	
+				if (testVal)
+					outputStr += this.processTokenChildren(token, processContext);
+			}
+			else if (token.data.name == &quot;spry:choose&quot;)
+			{
+				var defaultChild = null;
+				var childToProcess = null;
+				var testVal = false;
+				var j = 0;
+
+				// All of the children of the spry:choose token should be of the type spry:when or spry:default.
+				// Run through all of the spry:when children and see if any of their test expressions return true.
+				// If one does, then process its children tokens. If none of the test expressions return true,
+				// process the spry:default token's children, if it exists.
+
+				for (j = 0; j &lt; token.children.length; j++)
+				{
+					var child = token.children[j];
+					if (child.tokenType == Spry.Data.Region.Token.PROCESSING_INSTRUCTION_TOKEN)
+					{
+						if (child.data.name == &quot;spry:when&quot;)
+						{
+							if (child.data.jsExpr)
+							{
+								var jsExpr = Spry.Data.Region.processDataRefString(processContext, child.data.jsExpr, null, true);
+								try { testVal = Spry.Utils.eval(jsExpr); }
+								catch(e)
+								{
+									Spry.Debug.trace(&quot;Caught exception in Spry.Data.Region.prototype.processTokens while evaluating: &quot; + jsExpr + &quot;\n    Exception:&quot; + e + &quot;\n&quot;);
+									testVal = false;
+								}
+
+								if (testVal)
+								{
+									childToProcess = child;
+									break;
+								}
+							}
+						}
+						else if (child.data.name == &quot;spry:default&quot;)
+							defaultChild = child;
+					}
+				}
+
+				// If we didn't find a match, use the token for the default case.
+
+				if (!childToProcess &amp;&amp; defaultChild)
+					childToProcess = defaultChild;
+
+				if (childToProcess)
+					outputStr += this.processTokenChildren(childToProcess, processContext);
+			}
+			else if (token.data.name == &quot;spry:state&quot;)
+			{
+				var testVal = true;
+				
+				if (!token.data.regionState || token.data.regionState == this.currentState)
+					outputStr += this.processTokenChildren(token, processContext);
+			}
+			else
+			{
+				Spry.Debug.reportError(&quot;processTokens(): Unknown processing instruction: &quot; + token.data.name + &quot;\n&quot;);
+				return &quot;&quot;;
+			}
+			break;
+		case Spry.Data.Region.Token.VALUE_TOKEN:
+
+			var dataSet = token.dataSet;
+			if (!dataSet &amp;&amp; this.dataSets &amp;&amp; this.dataSets.length &gt; 0 &amp;&amp; this.dataSets[0])
+			{
+				// No dataSet was specified by the token, so use whatever the first
+				// data set specified in the region.
+
+				dataSet = this.dataSets[0];
+			}
+			if (!dataSet)
+			{
+				Spry.Debug.reportError(&quot;processTokens(): Value reference has no data set specified: &quot; + token.regionStr + &quot;\n&quot;);
+				return &quot;&quot;;
+			}
+
+			var dsContext = processContext.getDataSetContext(dataSet);
+			if (!dsContext)
+			{
+				Spry.Debug.reportError(&quot;processTokens: Failed to get a data set context!\n&quot;);
+				return &quot;&quot;;
+			}
+
+			var ds = dsContext.getDataSet();
+
+			if (token.data == &quot;ds_RowNumber&quot;)
+				outputStr += dsContext.getRowIndex();
+			else if (token.data == &quot;ds_RowNumberPlus1&quot;)
+				outputStr += (dsContext.getRowIndex() + 1);
+			else if (token.data == &quot;ds_RowCount&quot;)
+				outputStr += dsContext.getNumRows();
+			else if (token.data == &quot;ds_UnfilteredRowCount&quot;)
+				outputStr += dsContext.getNumRows(true);
+			else if (token.data == &quot;ds_CurrentRowNumber&quot;)
+				outputStr += ds.getRowNumber(ds.getCurrentRow());
+			else if (token.data == &quot;ds_CurrentRowID&quot;)
+				outputStr += ds.curRowID;
+			else if (token.data == &quot;ds_EvenOddRow&quot;)
+				outputStr += (dsContext.getRowIndex() % 2) ? Spry.Data.Region.evenRowClassName : Spry.Data.Region.oddRowClassName;
+			else if (token.data == &quot;ds_SortOrder&quot;)
+				outputStr += ds.getSortOrder();
+			else if (token.data == &quot;ds_SortColumn&quot;)
+				outputStr += ds.getSortColumn();
+			else
+			{
+				var curDataSetRow = dsContext.getCurrentRow();
+				if (curDataSetRow)
+					outputStr += curDataSetRow[token.data];
+			}
+			break;
+		default:
+			Spry.Debug.reportError(&quot;processTokens(): Invalid token type: &quot; + token.regionStr + &quot;\n&quot;);
+			break;
+	}
+
+	return outputStr;
+};
+
+Spry.Data.Region.prototype.transform = function()
+{
+	if (this.data &amp;&amp; !this.tokens)
+		this.tokens = this.tokenizeData(this.data);
+
+	if (!this.tokens)
+		return &quot;&quot;;
+
+	return this.processTokens(this.tokens, null);
+};
+
+Spry.Data.Region.PI = {};
+Spry.Data.Region.PI.instructions = {};
+
+Spry.Data.Region.PI.buildOpenTagForValueAttr = function(ele, piName, attrName)
+{
+	if (!ele || !piName)
+		return &quot;&quot;;
+
+	var jsExpr = &quot;&quot;;
+
+	try
+	{
+		var testAttr = ele.attributes.getNamedItem(piName);
+		if (testAttr &amp;&amp; testAttr.value)
+			jsExpr = Spry.Utils.encodeEntities(testAttr.value);
+	}
+	catch (e) { jsExpr = &quot;&quot;; }
+
+	if (!jsExpr)
+	{
+		Spry.Debug.reportError(piName + &quot; attribute requires a JavaScript expression that returns true or false!\n&quot;);
+		return &quot;&quot;;
+	}
+
+	return &quot;&lt;&quot; + Spry.Data.Region.PI.instructions[piName].tagName + &quot; &quot; + attrName +&quot;=\&quot;&quot; + jsExpr + &quot;\&quot;&gt;&quot;;
+};
+
+Spry.Data.Region.PI.buildOpenTagForTest = function(ele, piName)
+{
+	return Spry.Data.Region.PI.buildOpenTagForValueAttr(ele, piName, &quot;test&quot;);
+};
+
+Spry.Data.Region.PI.buildOpenTagForState = function(ele, piName)
+{
+	return Spry.Data.Region.PI.buildOpenTagForValueAttr(ele, piName, &quot;name&quot;);
+};
+
+Spry.Data.Region.PI.buildOpenTagForRepeat = function(ele, piName)
+{
+	if (!ele || !piName)
+		return &quot;&quot;;
+
+	var selectAttrStr = &quot;&quot;;
+
+	try
+	{
+		var selectAttr = ele.attributes.getNamedItem(piName);
+		if (selectAttr &amp;&amp; selectAttr.value)
+		{
+			selectAttrStr = selectAttr.value;
+			selectAttrStr = selectAttrStr.replace(/\s/g, &quot;&quot;);
+		}
+	}
+	catch (e) { selectAttrStr = &quot;&quot;; }
+
+	if (!selectAttrStr)
+	{
+		Spry.Debug.reportError(piName + &quot; attribute requires a data set name!\n&quot;);
+		return &quot;&quot;;
+	}
+
+	var testAttrStr = &quot;&quot;;
+
+	try
+	{
+		var testAttr = ele.attributes.getNamedItem(&quot;spry:test&quot;);
+		if (testAttr)
+		{
+			if (testAttr.value)
+				testAttrStr = &quot; test=\&quot;&quot; + Spry.Utils.encodeEntities(testAttr.value) + &quot;\&quot;&quot;;
+			ele.attributes.removeNamedItem(testAttr.nodeName);
+		}
+	}
+	catch (e) { testAttrStr = &quot;&quot;; }
+
+	return &quot;&lt;&quot; + Spry.Data.Region.PI.instructions[piName].tagName + &quot; select=\&quot;&quot; + selectAttrStr + &quot;\&quot;&quot; + testAttrStr + &quot;&gt;&quot;;
+};
+
+Spry.Data.Region.PI.buildOpenTagForContent = function(ele, piName)
+{
+	if (!ele || !piName)
+		return &quot;&quot;;
+
+	var dataRefStr = &quot;&quot;;
+
+	try
+	{
+		var contentAttr = ele.attributes.getNamedItem(piName);
+		if (contentAttr &amp;&amp; contentAttr.value)
+			dataRefStr = Spry.Utils.encodeEntities(contentAttr.value);
+	}
+	catch (e) { dataRefStr = &quot;&quot;; }
+
+	if (!dataRefStr)
+	{
+		Spry.Debug.reportError(piName + &quot; attribute requires a data reference!\n&quot;);
+		return &quot;&quot;;
+	}
+
+	return &quot;&lt;&quot; + Spry.Data.Region.PI.instructions[piName].tagName + &quot; dataref=\&quot;&quot; + dataRefStr + &quot;\&quot;&gt;&quot;;
+};
+
+Spry.Data.Region.PI.buildOpenTag = function(ele, piName)
+{
+	return &quot;&lt;&quot; + Spry.Data.Region.PI.instructions[piName].tagName + &quot;&gt;&quot;;
+};
+
+Spry.Data.Region.PI.buildCloseTag = function(ele, piName)
+{
+	return &quot;&lt;/&quot; + Spry.Data.Region.PI.instructions[piName].tagName + &quot;&gt;&quot;;
+};
+
+Spry.Data.Region.PI.instructions[&quot;spry:state&quot;] = { tagName: &quot;spry:state&quot;, childrenOnly: false, getOpenTag: Spry.Data.Region.PI.buildOpenTagForState, getCloseTag: Spry.Data.Region.PI.buildCloseTag };
+Spry.Data.Region.PI.instructions[&quot;spry:if&quot;] = { tagName: &quot;spry:if&quot;, childrenOnly: false, getOpenTag: Spry.Data.Region.PI.buildOpenTagForTest, getCloseTag: Spry.Data.Region.PI.buildCloseTag };
+Spry.Data.Region.PI.instructions[&quot;spry:repeat&quot;] = { tagName: &quot;spry:repeat&quot;, childrenOnly: false, getOpenTag: Spry.Data.Region.PI.buildOpenTagForRepeat, getCloseTag: Spry.Data.Region.PI.buildCloseTag };
+Spry.Data.Region.PI.instructions[&quot;spry:repeatchildren&quot;] = { tagName: &quot;spry:repeat&quot;, childrenOnly: true, getOpenTag: Spry.Data.Region.PI.buildOpenTagForRepeat, getCloseTag: Spry.Data.Region.PI.buildCloseTag };
+Spry.Data.Region.PI.instructions[&quot;spry:choose&quot;] = { tagName: &quot;spry:choose&quot;, childrenOnly: true, getOpenTag: Spry.Data.Region.PI.buildOpenTag, getCloseTag: Spry.Data.Region.PI.buildCloseTag };
+Spry.Data.Region.PI.instructions[&quot;spry:when&quot;] = { tagName: &quot;spry:when&quot;, childrenOnly: false, getOpenTag: Spry.Data.Region.PI.buildOpenTagForTest, getCloseTag: Spry.Data.Region.PI.buildCloseTag };
+Spry.Data.Region.PI.instructions[&quot;spry:default&quot;] = { tagName: &quot;spry:default&quot;, childrenOnly: false, getOpenTag: Spry.Data.Region.PI.buildOpenTag, getCloseTag: Spry.Data.Region.PI.buildCloseTag };
+Spry.Data.Region.PI.instructions[&quot;spry:content&quot;] = { tagName: &quot;spry:content&quot;, childrenOnly: true, getOpenTag: Spry.Data.Region.PI.buildOpenTagForContent, getCloseTag: Spry.Data.Region.PI.buildCloseTag };
+
+Spry.Data.Region.PI.orderedInstructions = [ &quot;spry:state&quot;, &quot;spry:if&quot;, &quot;spry:repeat&quot;, &quot;spry:repeatchildren&quot;, &quot;spry:choose&quot;, &quot;spry:when&quot;, &quot;spry:default&quot;, &quot;spry:content&quot; ];
+
+Spry.Data.Region.getTokensFromStr = function(str)
+{
+	// XXX: This will need to be modified if we support
+	// tokens that use javascript between the braces!
+	if (!str)
+		return null;
+	return str.match(/{[^}]+}/g);
+};
+
+Spry.Data.Region.processDataRefString = function(processingContext, regionStr, dataSetsToUse, isJSExpr)
+{
+	if (!regionStr)
+		return &quot;&quot;;
+
+	if (!processingContext &amp;&amp; !dataSetsToUse)
+		return regionStr;
+
+	var resultStr = &quot;&quot;;
+	var re = new RegExp(&quot;\\{([^\\}:]+::)?[^\\}]+\\}&quot;, &quot;g&quot;);
+	var startSearchIndex = 0;
+
+	while (startSearchIndex &lt; regionStr.length)
+	{
+		var reArray = re.exec(regionStr);
+		if (!reArray || !reArray[0])
+		{
+			resultStr += regionStr.substr(startSearchIndex, regionStr.length - startSearchIndex);
+			return resultStr;
+		}
+
+		if (reArray.index != startSearchIndex)
+			resultStr += regionStr.substr(startSearchIndex, reArray.index - startSearchIndex);
+
+		var dsName = &quot;&quot;;
+		if (reArray[0].search(/^\{[^}:]+::/) != -1)
+			dsName = reArray[0].replace(/^\{|::.*/g, &quot;&quot;);
+
+		var fieldName = reArray[0].replace(/^\{|.*::|\}/g, &quot;&quot;);
+		var row = null;
+
+		if (processingContext)
+		{
+			var dsContext = processingContext.getDataSetContext(dsName);
+
+			if (fieldName == &quot;ds_RowNumber&quot;)
+			{
+				resultStr += dsContext.getRowIndex();
+				row = null;
+			}
+			else if (fieldName == &quot;ds_RowNumberPlus1&quot;)
+			{
+				resultStr += (dsContext.getRowIndex() + 1);
+				row = null;
+			}
+			else if (fieldName == &quot;ds_RowCount&quot;)
+			{
+				resultStr += dsContext.getNumRows();
+				row = null;
+			}
+			else if (fieldName == &quot;ds_UnfilteredRowCount&quot;)
+			{
+				resultStr += dsContext.getNumRows(true);
+				row = null;
+			}
+			else if (fieldName == &quot;ds_CurrentRowNumber&quot;)
+			{
+				var ds = dsContext.getDataSet();
+				resultStr += ds.getRowNumber(ds.getCurrentRow());
+				row = null;
+			}
+			else if (fieldName == &quot;ds_CurrentRowID&quot;)
+			{
+				var ds = dsContext.getDataSet();
+				resultStr += &quot;&quot; + ds.curRowID;
+				row = null;
+			}
+			else if (fieldName == &quot;ds_EvenOddRow&quot;)
+			{
+				resultStr += (dsContext.getRowIndex() % 2) ? Spry.Data.Region.evenRowClassName : Spry.Data.Region.oddRowClassName;
+				row = null;
+			}
+			else if (fieldName == &quot;ds_SortOrder&quot;)
+			{
+				resultStr += dsContext.getDataSet().getSortOrder();;
+				row = null;
+			}
+			else if (fieldName == &quot;ds_SortColumn&quot;)
+			{
+				resultStr += dsContext.getDataSet().getSortColumn();
+				row = null;
+			}
+			else
+				row = processingContext.getCurrentRowForDataSet(dsName);
+		}
+		else
+		{
+			var ds = dsName ? dataSetsToUse[dsName] : dataSetsToUse[0];
+			if (ds)
+				row = ds.getCurrentRow();
+		}
+
+		if (row)
+			resultStr += isJSExpr ? Spry.Utils.escapeQuotesAndLineBreaks(&quot;&quot; + row[fieldName]) : row[fieldName];
+
+		if (startSearchIndex == re.lastIndex)
+		{
+			// On IE if there was a match near the end of the string, it sometimes
+			// leaves re.lastIndex pointing to the value it had before the last time
+			// we called re.exec. We check for this case to prevent an infinite loop!
+			// We need to write out any text in regionStr that comes after the last
+			// match.
+
+			var leftOverIndex = reArray.index + reArray[0].length;
+			if (leftOverIndex &lt; regionStr.length)
+				resultStr += regionStr.substr(leftOverIndex);
+
+			break;
+		}
+
+		startSearchIndex = re.lastIndex;
+	}
+
+	return resultStr;
+};
+
+Spry.Data.Region.strToDataSetsArray = function(str, returnRegionNames)
+{
+	var dataSetsArr = new Array;
+	var foundHash = {};
+
+	if (!str)
+		return dataSetsArr;
+
+	str = str.replace(/\s+/g, &quot; &quot;);
+	str = str.replace(/^\s|\s$/g, &quot;&quot;);
+	var arr = str.split(/ /);
+
+
+	for (var i = 0; i &lt; arr.length; i++)
+	{
+		if (arr[i] &amp;&amp; !Spry.Data.Region.PI.instructions[arr[i]])
+		{
+			try {
+				var dataSet = eval(arr[i]);
+
+				if (!foundHash[arr[i]])
+				{
+					if (returnRegionNames)
+						dataSetsArr.push(arr[i]);
+					else
+						dataSetsArr.push(dataSet);
+					foundHash[arr[i]] = true;
+				}
+			}
+			catch (e) { /* Spry.Debug.trace(&quot;Caught exception: &quot; + e + &quot;\n&quot;); */ }
+		}
+	}
+
+	return dataSetsArr;
+};
+
+Spry.Data.Region.DSContext = function(dataSet)
+{
+	var m_self = this;
+	var m_dataSet = dataSet;
+	var m_curRowIndexArray = [ -1 ]; // -1 means return whatever the current row is inside the data set.
+
+	// Private Methods:
+
+	function getInternalRowIndex() { return m_curRowIndexArray[m_curRowIndexArray.length - 1]; }
+
+	// Public Methods:
+	this.resetAll = function() { m_curRowIndexArray = [ m_dataSet.getCurrentRow() ] };
+	this.getDataSet = function() { return m_dataSet; };
+	this.getNumRows = function(unfiltered)
+	{
+		return m_dataSet.getRowCount(unfiltered);
+	};
+	this.getCurrentRow = function()
+	{
+		if (m_curRowIndexArray.length &lt; 2 || getInternalRowIndex() &lt; 0)
+			return m_dataSet.getCurrentRow();
+	
+		var data = m_dataSet.getData();
+		var curRowIndex = getInternalRowIndex();
+	
+		if (curRowIndex &lt; 0 || curRowIndex &gt; data.length)
+		{
+			Spry.Debug.reportError(&quot;Invalid index used in Spry.Data.Region.DSContext.getCurrentRow()!\n&quot;);
+			return null;
+		}
+	
+		return data[curRowIndex];
+	};
+	this.getRowIndex = function()
+	{
+		var curRowIndex = getInternalRowIndex();
+		if (curRowIndex &gt;= 0)
+			return curRowIndex;
+
+		return m_dataSet.getRowNumber(m_dataSet.getCurrentRow());
+	};
+	this.setRowIndex = function(rowIndex) { m_curRowIndexArray[m_curRowIndexArray.length - 1] = rowIndex; };
+	this.pushState = function() { m_curRowIndexArray.push( getInternalRowIndex()); };
+	this.popState = function()
+	{
+		if (m_curRowIndexArray.length &lt; 2)
+		{
+			// Our array should always have at least one element in it!
+			Spry.Debug.reportError(&quot;Stack underflow in Spry.Data.Region.DSContext.popState()!\n&quot;);
+			return;
+		}
+		m_curRowIndexArray.pop();
+	};
+};
+
+Spry.Data.Region.ProcessingContext = function(region)
+{
+	var m_self = this;
+	var m_region = region;
+	var m_dataSetContexts = [];
+	
+	if (region &amp;&amp; region.dataSets)
+	{
+		for (var i = 0; i &lt; region.dataSets.length; i++)
+			m_dataSetContexts.push(new Spry.Data.Region.DSContext(region.dataSets[i]));
+	}
+
+	this.getDataSetContext = function(dataSet)
+	{
+		if (!dataSet)
+		{
+			// We were called without a specified data set or
+			// data set name. Assume the caller wants the first
+			// data set in the processing context.
+
+			if (m_dataSetContexts.length &gt; 0)
+				return m_dataSetContexts[0];
+			return null;
+		}
+
+		if (typeof dataSet == 'string')
+		{
+			try { dataSet = eval(dataSet); } catch (e) { dataSet = null; }
+			if (!dataSet)
+				return null;
+		}
+	
+		for (var i = 0; i &lt; m_dataSetContexts.length; i++)
+		{
+			var dsc = m_dataSetContexts[i];
+			if (dsc.getDataSet() == dataSet)
+				return dsc;
+		}
+	
+		return null;
+	};
+
+	this.getCurrentRowForDataSet = function(dataSet)
+	{
+		var dsc = m_self.getDataSetContext(dataSet);
+		if (dsc)
+			return dsc.getCurrentRow();
+		return null;
+	};
+};
+
+Spry.Data.Region.Token = function(tokenType, dataSet, data, regionStr)
+{
+	var self = this;
+	this.tokenType = tokenType;
+	this.dataSet = dataSet;
+	this.data = data;
+	this.regionStr = regionStr;
+	this.parent = null;
+	this.children = null;
+};
+
+Spry.Data.Region.Token.prototype.addChild = function(child)
+{
+	if (!child)
+		return;
+	
+	if (!this.children)
+		this.children = new Array;
+	
+	this.children.push(child);
+	child.parent = this;
+};
+
+Spry.Data.Region.Token.LIST_TOKEN                   = 0;
+Spry.Data.Region.Token.STRING_TOKEN                 = 1;
+Spry.Data.Region.Token.PROCESSING_INSTRUCTION_TOKEN = 2;
+Spry.Data.Region.Token.VALUE_TOKEN                  = 3;
+
+Spry.Data.Region.Token.PIData = function(piName, data, jsExpr, regionState)
+{
+	var self = this;
+	this.name = piName;
+	this.data = data;
+	this.jsExpr = jsExpr;
+	this.regionState = regionState;
+};
+
+Spry.Utils.addLoadListener(function() { setTimeout(function() { Spry.Data.initRegions(); }, 0); });

Added: YDFramework2.0/trunk/examples/adobe_spry/index.php
===================================================================
--- YDFramework2.0/trunk/examples/adobe_spry/index.php	2007-01-03 12:50:04 UTC (rev 2294)
+++ YDFramework2.0/trunk/examples/adobe_spry/index.php	2007-01-03 12:51:22 UTC (rev 2295)
@@ -0,0 +1,56 @@
+&lt;?php
+
+    // Initialize the Yellow Duck Framework
+    include_once( dirname( __FILE__ ) . '/../../YDFramework2/YDF2_init.php' );
+
+    // Database setup
+    $db['type'] = 'mysql';
+    $db['name'] = 'mysql';
+    $db['user'] = 'root';
+    $db['pass'] = '';
+    $db['host'] = 'localhost';
+
+    // Includes
+    YDInclude( 'YDTemplate.php' );
+    YDInclude( 'YDDatabase.php' );
+
+    // Class definition for the index request
+    class index extends YDRequest {
+
+        // Class constructor
+        function index() {
+
+            // Initialize the parent class
+            $this-&gt;YDRequest();
+
+            // Initialize the template object
+            $this-&gt;template = new YDTemplate();
+
+            // Make the database connection
+            $this-&gt;db = YDDatabase::getInstance(
+                $GLOBALS['db']['type'],
+                $GLOBALS['db']['name'],
+                $GLOBALS['db']['user'],
+                $GLOBALS['db']['pass'],
+                $GLOBALS['db']['host']
+            );
+
+        }
+
+        // Default action
+        function actionDefault() {
+            $this-&gt;template-&gt;display();
+        }
+
+        // Get the records as XML
+        function actionGetRecords() {
+            header( 'Content-type: text/xml' );
+            echo( YDArrayUtil::toXml( $this-&gt;db-&gt;getRecords( 'show status' ) ) );
+        }
+
+    }
+
+    // Process the request
+    YDInclude( 'YDF2_process.php' );
+
+?&gt;
\ No newline at end of file

Added: YDFramework2.0/trunk/examples/adobe_spry/index.tpl
===================================================================
--- YDFramework2.0/trunk/examples/adobe_spry/index.tpl	2007-01-03 12:50:04 UTC (rev 2294)
+++ YDFramework2.0/trunk/examples/adobe_spry/index.tpl	2007-01-03 12:51:22 UTC (rev 2295)
@@ -0,0 +1,85 @@
+&lt;html&gt;
+
+&lt;head&gt;
+
+    &lt;title&gt;Adobe Spry + Yellow Duck Framework&lt;/title&gt;
+
+    &lt;script type=&quot;text/javascript&quot; src=&quot;xpath.js&quot;&gt;&lt;/script&gt;
+    &lt;script type=&quot;text/javascript&quot; src=&quot;SpryData.js&quot;&gt;&lt;/script&gt;
+
+    {literal}&lt;style&gt;
+        .even {
+            background-color: #eee;
+        }
+        .odd {
+            background-color: #fff;
+        }
+        th {
+            text-align: left;
+            background-color: #ccc;
+        }
+    &lt;/style&gt;
+
+    &lt;script type=&quot;text/javascript&quot;&gt;
+
+        var dsData = new Spry.Data.XMLDataSet( &quot;?do=GetRecords&quot;, &quot;root/row&quot; );
+
+        function FilterData() {
+            var tf = document.getElementById( &quot;filterTF&quot; );
+            if ( ! tf.value ) {
+                dsData.filter(null);
+                return;
+            }
+            var regExpStr = tf.value;
+            if ( ! document.getElementById( &quot;containsCB&quot; ).checked ) {
+                regExpStr = &quot;^&quot; + regExpStr;
+            }
+            var regExp = new RegExp( regExpStr, &quot;i&quot; );
+            var filterFunc = function( ds, row, rowNumber ) {
+                var str = row[&quot;variable_name&quot;];
+                if ( str &amp;&amp; str.search( regExp ) != -1 ) {
+                    return row;
+                }
+                return null;
+            };
+            dsData.filter( filterFunc );
+        }
+
+        function StartFilterTimer() {
+            if ( StartFilterTimer.timerID ) {
+                clearTimeout( StartFilterTimer.timerID );
+            }
+            StartFilterTimer.timerID = setTimeout(
+                function() { StartFilterTimer.timerID = null; FilterData(); }, 100
+            );
+        }
+
+    &lt;/script&gt;{/literal}
+
+&lt;/head&gt;
+
+&lt;body&gt;
+
+    &lt;h1&gt;Adobe Spry + Yellow Duck Framework&lt;/h1&gt;
+
+    &lt;p&gt;Enter the name of a variable: 
+        &lt;input type=&quot;text&quot; id=&quot;filterTF&quot; onkeyup=&quot;StartFilterTimer();&quot; /&gt; 
+        Contains: &lt;input type=&quot;checkbox&quot; id=&quot;containsCB&quot; /&gt;
+    &lt;/p&gt;
+
+    {literal}&lt;div spry:region=&quot;dsData&quot;&gt;
+        &lt;table border=&quot;0&quot; width=&quot;100%&quot; cellspacing=&quot;0&quot; cellpadding=&quot;4&quot;&gt;
+            &lt;tr&gt;
+                &lt;th scope=&quot;col&quot; onclick=&quot;dsData.sort('variable_name');&quot;&gt;Variable&lt;/th&gt;
+                &lt;th scope=&quot;col&quot; onclick=&quot;dsData.sort('value');&quot;&gt;Value&lt;/th&gt;
+            &lt;/tr&gt;
+            &lt;tr spry:repeat=&quot;dsData&quot; class=&quot;{ds_EvenOddRow}&quot;&gt;
+                &lt;td&gt;{variable_name}&lt;/td&gt;
+                &lt;td&gt;{value}&lt;/td&gt;
+            &lt;/tr&gt;
+        &lt;/table&gt;
+    &lt;/div&gt;{/literal}
+
+&lt;/body&gt;
+
+&lt;/html&gt;
\ No newline at end of file

Added: YDFramework2.0/trunk/examples/adobe_spry/xpath.js
===================================================================
--- YDFramework2.0/trunk/examples/adobe_spry/xpath.js	2007-01-03 12:50:04 UTC (rev 2294)
+++ YDFramework2.0/trunk/examples/adobe_spry/xpath.js	2007-01-03 12:51:22 UTC (rev 2295)
@@ -0,0 +1,2499 @@
+/* xpath.js - Revision: Spry Preview Release 1.4 */
+
+// Copyright (c) 2005, Google Inc.
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//         
+//  * Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 
+//  * Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the
+//    distribution.
+// 
+//  * Neither the name of Google Inc. nor the names of its contributors
+//    may be used to endorse or promote products derived from this
+//    software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// An XPath parser and evaluator written in JavaScript. The
+// implementation is complete except for functions handling
+// namespaces.
+//
+// Reference: [XPATH] XPath Specification
+// &lt;<A HREF="http://www.w3.org/TR/1999/REC-xpath-19991116">http://www.w3.org/TR/1999/REC-xpath-19991116</A>&gt;.
+//
+//
+// The API of the parser has several parts:
+//
+// 1. The parser function xpathParse() that takes a string and returns
+// an expession object.
+//
+// 2. The expression object that has an evaluate() method to evaluate the
+// XPath expression it represents. (It is actually a hierarchy of
+// objects that resembles the parse tree, but an application will call
+// evaluate() only on the top node of this hierarchy.)
+//
+// 3. The context object that is passed as an argument to the evaluate()
+// method, which represents the DOM context in which the expression is
+// evaluated.
+//
+// 4. The value object that is returned from evaluate() and represents
+// values of the different types that are defined by XPath (number,
+// string, boolean, and node-set), and allows to convert between them.
+//
+// These parts are near the top of the file, the functions and data
+// that are used internally follow after them.
+//
+//
+// TODO(mesch): add jsdoc comments. Use more coherent naming.
+//
+//
+// Author: Steffen Meschkat &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/ydframework-devel">mesch at google.com</A>&gt;
+
+
+// The entry point for the parser.
+//
+// @param expr a string that contains an XPath expression.
+// @return an expression object that can be evaluated with an
+// expression context.
+
+function xpathParse(expr) {
+  if (xpathdebug) {
+    Log.write('XPath parse ' + expr);
+  }
+  xpathParseInit();
+
+  var cached = xpathCacheLookup(expr);
+  if (cached) {
+    if (xpathdebug) {
+      Log.write(' ... cached');
+    }
+    return cached;
+  }
+
+  // Optimize for a few common cases: simple attribute node tests
+  // (@id), simple element node tests (page), variable references
+  // ($address), numbers (4), multi-step path expressions where each
+  // step is a plain element node test
+  // (page/overlay/locations/location).
+  
+  if (expr.match(/^(\$|@)?\w+$/i)) {
+    var ret = makeSimpleExpr(expr);
+    xpathParseCache[expr] = ret;
+    if (xpathdebug) {
+      Log.write(' ... simple');
+    }
+    return ret;
+  }
+
+  if (expr.match(/^\w+(\/\w+)*$/i)) {
+    var ret = makeSimpleExpr2(expr);
+    xpathParseCache[expr] = ret;
+    if (xpathdebug) {
+      Log.write(' ... simple 2');
+    }
+    return ret;
+  }
+
+  var cachekey = expr; // expr is modified during parse
+  if (xpathdebug) {
+    Timer.start('XPath parse', cachekey);
+  }
+
+  var stack = [];
+  var ahead = null;
+  var previous = null;
+  var done = false;
+
+  var parse_count = 0;
+  var lexer_count = 0;
+  var reduce_count = 0;
+  
+  while (!done) {
+    parse_count++;
+    expr = expr.replace(/^\s*/, '');
+    previous = ahead;
+    ahead = null;
+
+    var rule = null;
+    var match = '';
+    for (var i = 0; i &lt; xpathTokenRules.length; ++i) {
+      var result = xpathTokenRules[i].re.exec(expr);
+      lexer_count++;
+      if (result &amp;&amp; result.length &gt; 0 &amp;&amp; result[0].length &gt; match.length) {
+        rule = xpathTokenRules[i];
+        match = result[0];
+        break;
+      }
+    }
+
+    // Special case: allow operator keywords to be element and
+    // variable names.
+
+    // NOTE(mesch): The parser resolves conflicts by looking ahead,
+    // and this is the only case where we look back to
+    // disambiguate. So this is indeed something different, and
+    // looking back is usually done in the lexer (via states in the
+    // general case, called &quot;start conditions&quot; in flex(1)). Also,the
+    // conflict resolution in the parser is not as robust as it could
+    // be, so I'd like to keep as much off the parser as possible (all
+    // these precedence values should be computed from the grammar
+    // rules and possibly associativity declarations, as in bison(1),
+    // and not explicitly set.
+
+    if (rule &amp;&amp;
+        (rule == TOK_DIV || 
+         rule == TOK_MOD ||
+         rule == TOK_AND || 
+         rule == TOK_OR) &amp;&amp;
+        (!previous || 
+         previous.tag == TOK_AT || 
+         previous.tag == TOK_DSLASH || 
+         previous.tag == TOK_SLASH ||
+         previous.tag == TOK_AXIS || 
+         previous.tag == TOK_DOLLAR)) {
+      rule = TOK_QNAME;
+    }
+
+    if (rule) {
+      expr = expr.substr(match.length);
+      if (xpathdebug) {
+        Log.write('token: ' + match + ' -- ' + rule.label);
+      }
+      ahead = {
+        tag: rule,
+        match: match,
+        prec: rule.prec ?  rule.prec : 0, // || 0 is removed by the compiler
+        expr: makeTokenExpr(match)
+      };
+
+    } else {
+      if (xpathdebug) {
+        Log.write('DONE');
+      }
+      done = true;
+    }
+
+    while (xpathReduce(stack, ahead)) {
+      reduce_count++;
+      if (xpathdebug) {
+        Log.write('stack: ' + stackToString(stack));
+      }
+    }
+  }
+
+  if (xpathdebug) {
+    Log.write(stackToString(stack));
+  }
+
+  if (stack.length != 1) {
+    throw 'XPath parse error ' + cachekey + ':\n' + stackToString(stack);
+  }
+
+  var result = stack[0].expr;
+  xpathParseCache[cachekey] = result;
+
+  if (xpathdebug) {
+    Timer.end('XPath parse', cachekey);
+  }
+
+  if (xpathdebug) {
+    Log.write('XPath parse: ' + parse_count + ' / ' + 
+              lexer_count + ' / ' + reduce_count);
+  }
+
+  return result;
+}
+
+var xpathParseCache = {};
+
+function xpathCacheLookup(expr) {
+  return xpathParseCache[expr];
+}
+
+function xpathReduce(stack, ahead) {
+  var cand = null;
+
+  if (stack.length &gt; 0) {
+    var top = stack[stack.length-1];
+    var ruleset = xpathRules[top.tag.key];
+
+    if (ruleset) {
+      for (var i = 0; i &lt; ruleset.length; ++i) {
+        var rule = ruleset[i];
+        var match = xpathMatchStack(stack, rule[1]);
+        if (match.length) {
+          cand = {
+            tag: rule[0],
+            rule: rule,
+            match: match
+          };
+          cand.prec = xpathGrammarPrecedence(cand);
+          break;
+        }
+      }
+    }
+  }
+
+  var ret;
+  if (cand &amp;&amp; (!ahead || cand.prec &gt; ahead.prec || 
+               (ahead.tag.left &amp;&amp; cand.prec &gt;= ahead.prec))) {
+    for (var i = 0; i &lt; cand.match.matchlength; ++i) {
+      stack.pop();
+    }
+
+    if (xpathdebug) {
+      Log.write('reduce ' + cand.tag.label + ' ' + cand.prec +
+                ' ahead ' + (ahead ? ahead.tag.label + ' ' + ahead.prec + 
+                             (ahead.tag.left ? ' left' : '')
+                             : ' none '));
+    }
+
+    var matchexpr = mapExpr(cand.match, function(m) { return m.expr; });
+    cand.expr = cand.rule[3].apply(null, matchexpr);
+
+    stack.push(cand);
+    ret = true;
+
+  } else {
+    if (ahead) {
+      if (xpathdebug) {
+        Log.write('shift ' + ahead.tag.label + ' ' + ahead.prec + 
+                  (ahead.tag.left ? ' left' : '') +
+                  ' over ' + (cand ? cand.tag.label + ' ' + 
+                              cand.prec : ' none'));
+      }
+      stack.push(ahead);
+    }
+    ret = false;
+  }
+  return ret;
+}
+
+function xpathMatchStack(stack, pattern) {
+
+  // NOTE(mesch): The stack matches for variable cardinality are
+  // greedy but don't do backtracking. This would be an issue only
+  // with rules of the form A* A, i.e. with an element with variable
+  // cardinality followed by the same element. Since that doesn't
+  // occur in the grammar at hand, all matches on the stack are
+  // unambiguous.
+
+  var S = stack.length;
+  var P = pattern.length;
+  var p, s;
+  var match = [];
+  match.matchlength = 0;
+  var ds = 0;
+  for (p = P - 1, s = S - 1; p &gt;= 0 &amp;&amp; s &gt;= 0; --p, s -= ds) {
+    ds = 0;
+    var qmatch = [];
+    if (pattern[p] == Q_MM) {
+      p -= 1;
+      match.push(qmatch);
+      while (s - ds &gt;= 0 &amp;&amp; stack[s - ds].tag == pattern[p]) {
+        qmatch.push(stack[s - ds]);
+        ds += 1;
+        match.matchlength += 1;
+      }
+
+    } else if (pattern[p] == Q_01) {
+      p -= 1;
+      match.push(qmatch);
+      while (s - ds &gt;= 0 &amp;&amp; ds &lt; 2 &amp;&amp; stack[s - ds].tag == pattern[p]) {
+        qmatch.push(stack[s - ds]);
+        ds += 1;
+        match.matchlength += 1;
+      }
+
+    } else if (pattern[p] == Q_1M) {
+      p -= 1;
+      match.push(qmatch);
+      if (stack[s].tag == pattern[p]) {
+        while (s - ds &gt;= 0 &amp;&amp; stack[s - ds].tag == pattern[p]) {
+          qmatch.push(stack[s - ds]);
+          ds += 1;
+          match.matchlength += 1;
+        }
+      } else {
+        return [];
+      }
+
+    } else if (stack[s].tag == pattern[p]) {
+      match.push(stack[s]);
+      ds += 1;
+      match.matchlength += 1;
+
+    } else {
+      return [];
+    }
+
+    reverseInplace(qmatch);
+    qmatch.expr = mapExpr(qmatch, function(m) { return m.expr; });
+  }
+
+  reverseInplace(match);
+
+  if (p == -1) {
+    return match;
+
+  } else {
+    return [];
+  }
+}
+
+function xpathTokenPrecedence(tag) {
+  return tag.prec || 2;
+}
+
+function xpathGrammarPrecedence(frame) {
+  var ret = 0;
+
+  if (frame.rule) { /* normal reduce */
+    if (frame.rule.length &gt;= 3 &amp;&amp; frame.rule[2] &gt;= 0) {
+      ret = frame.rule[2];
+
+    } else {
+      for (var i = 0; i &lt; frame.rule[1].length; ++i) {
+        var p = xpathTokenPrecedence(frame.rule[1][i]);
+        ret = Math.max(ret, p);
+      }
+    }
+  } else if (frame.tag) { /* TOKEN match */
+    ret = xpathTokenPrecedence(frame.tag);
+
+  } else if (frame.length) { /* Q_ match */
+    for (var j = 0; j &lt; frame.length; ++j) {
+      var p = xpathGrammarPrecedence(frame[j]);
+      ret = Math.max(ret, p);
+    }
+  }
+
+  return ret;
+}
+
+function stackToString(stack) {
+  var ret = '';
+  for (var i = 0; i &lt; stack.length; ++i) {
+    if (ret) {
+      ret += '\n';
+    }
+    ret += stack[i].tag.label;
+  }
+  return ret;
+}
+
+
+// XPath expression evaluation context. An XPath context consists of a
+// DOM node, a list of DOM nodes that contains this node, a number
+// that represents the position of the single node in the list, and a
+// current set of variable bindings. (See XPath spec.)
+//
+// The interface of the expression context:
+//
+//   Constructor -- gets the node, its position, the node set it
+//   belongs to, and a parent context as arguments. The parent context
+//   is used to implement scoping rules for variables: if a variable
+//   is not found in the current context, it is looked for in the
+//   parent context, recursively. Except for node, all arguments have
+//   default values: default position is 0, default node set is the
+//   set that contains only the node, and the default parent is null.
+//
+//     Notice that position starts at 0 at the outside interface;
+//     inside XPath expressions this shows up as position()=1.
+//
+//   clone() -- creates a new context with the current context as
+//   parent. If passed as argument to clone(), the new context has a
+//   different node, position, or node set. What is not passed is
+//   inherited from the cloned context.
+//
+//   setVariable(name, expr) -- binds given XPath expression to the
+//   name.
+//
+//   getVariable(name) -- what the name says.
+//
+//   setNode(node, position) -- sets the context to the new node and
+//   its corresponding position. Needed to implement scoping rules for
+//   variables in XPath. (A variable is visible to all subsequent
+//   siblings, not only to its children.)
+
+function ExprContext(node, position, nodelist, parent) {
+  this.node = node;
+  this.position = position || 0;
+  this.nodelist = nodelist || [ node ];
+  this.variables = {};
+  this.parent = parent || null;
+  this.root = parent ? parent.root : node.ownerDocument;
+}
+
+ExprContext.prototype.clone = function(node, position, nodelist) {
+  return new
+  ExprContext(node || this.node,
+              typeof position != 'undefined' ? position : this.position,
+              nodelist || this.nodelist, this);
+};
+
+ExprContext.prototype.setVariable = function(name, value) {
+  this.variables[name] = value;
+};
+
+ExprContext.prototype.getVariable = function(name) {
+  if (typeof this.variables[name] != 'undefined') {
+    return this.variables[name];
+
+  } else if (this.parent) {
+    return this.parent.getVariable(name);
+
+  } else {
+    return null;
+  }
+}
+
+ExprContext.prototype.setNode = function(node, position) {
+  this.node = node;
+  this.position = position;
+}
+
+
+// XPath expression values. They are what XPath expressions evaluate
+// to. Strangely, the different value types are not specified in the
+// XPath syntax, but only in the semantics, so they don't show up as
+// nonterminals in the grammar. Yet, some expressions are required to
+// evaluate to particular types, and not every type can be coerced
+// into every other type. Although the types of XPath values are
+// similar to the types present in JavaScript, the type coercion rules
+// are a bit peculiar, so we explicitly model XPath types instead of
+// mapping them onto JavaScript types. (See XPath spec.)
+//
+// The four types are:
+//
+//   StringValue
+//
+//   NumberValue
+//
+//   BooleanValue
+//
+//   NodeSetValue
+//
+// The common interface of the value classes consists of methods that
+// implement the XPath type coercion rules:
+//
+//   stringValue() -- returns the value as a JavaScript String,
+//
+//   numberValue() -- returns the value as a JavaScript Number,
+//
+//   booleanValue() -- returns the value as a JavaScript Boolean,
+//
+//   nodeSetValue() -- returns the value as a JavaScript Array of DOM
+//   Node objects.
+//
+
+function StringValue(value) {
+  this.value = value;
+  this.type = 'string';
+}
+
+StringValue.prototype.stringValue = function() {
+  return this.value;
+}
+
+StringValue.prototype.booleanValue = function() {
+  return this.value.length &gt; 0;
+}
+
+StringValue.prototype.numberValue = function() {
+  return this.value - 0;
+}
+
+StringValue.prototype.nodeSetValue = function() {
+  throw this + ' ' + Error().stack;
+}
+
+function BooleanValue(value) {
+  this.value = value;
+  this.type = 'boolean';
+}
+
+BooleanValue.prototype.stringValue = function() {
+  return '' + this.value;
+}
+
+BooleanValue.prototype.booleanValue = function() {
+  return this.value;
+}
+
+BooleanValue.prototype.numberValue = function() {
+  return this.value ? 1 : 0;
+}
+
+BooleanValue.prototype.nodeSetValue = function() {
+  throw this + ' ' + Error().stack;
+}
+
+function NumberValue(value) {
+  this.value = value;
+  this.type = 'number';
+}
+
+NumberValue.prototype.stringValue = function() {
+  return '' + this.value;
+}
+
+NumberValue.prototype.booleanValue = function() {
+  return !!this.value;
+}
+
+NumberValue.prototype.numberValue = function() {
+  return this.value - 0;
+}
+
+NumberValue.prototype.nodeSetValue = function() {
+  throw this + ' ' + Error().stack;
+}
+
+function NodeSetValue(value) {
+  this.value = value;
+  this.type = 'node-set';
+}
+
+NodeSetValue.prototype.stringValue = function() {
+  if (this.value.length == 0) {
+    return '';
+  } else {
+    return xmlValue(this.value[0]);
+  }
+}
+
+NodeSetValue.prototype.booleanValue = function() {
+  return this.value.length &gt; 0;
+}
+
+NodeSetValue.prototype.numberValue = function() {
+  return this.stringValue() - 0;
+}
+
+NodeSetValue.prototype.nodeSetValue = function() {
+  return this.value;
+};
+
+// XPath expressions. They are used as nodes in the parse tree and
+// possess an evaluate() method to compute an XPath value given an XPath
+// context. Expressions are returned from the parser. Teh set of
+// expression classes closely mirrors the set of non terminal symbols
+// in the grammar. Every non trivial nonterminal symbol has a
+// corresponding expression class.
+//
+// The common expression interface consists of the following methods:
+//
+// evaluate(context) -- evaluates the expression, returns a value.
+//
+// toString() -- returns the XPath text representation of the
+// expression (defined in xsltdebug.js).
+//
+// parseTree(indent) -- returns a parse tree representation of the
+// expression (defined in xsltdebug.js).
+
+function TokenExpr(m) {
+  this.value = m;
+}
+
+TokenExpr.prototype.evaluate = function() {
+  return new StringValue(this.value);
+};
+
+function LocationExpr() {
+  this.absolute = false;
+  this.steps = [];
+}
+
+LocationExpr.prototype.appendStep = function(s) {
+  this.steps.push(s);
+}
+
+LocationExpr.prototype.prependStep = function(s) {
+  var steps0 = this.steps;
+  this.steps = [ s ];
+  for (var i = 0; i &lt; steps0.length; ++i) {
+    this.steps.push(steps0[i]);
+  }
+};
+
+LocationExpr.prototype.evaluate = function(ctx) {
+  var start;
+  if (this.absolute) {
+    start = ctx.root;
+
+  } else {
+    start = ctx.node;
+  }
+
+  var nodes = [];
+  xPathStep(nodes, this.steps, 0, start, ctx);
+  return new NodeSetValue(nodes);
+};
+
+function xPathStep(nodes, steps, step, input, ctx) {
+  var s = steps[step];
+  var ctx2 = ctx.clone(input);
+  var nodelist = s.evaluate(ctx2).nodeSetValue();
+
+  for (var i = 0; i &lt; nodelist.length; ++i) {
+    if (step == steps.length - 1) {
+      nodes.push(nodelist[i]);
+    } else {
+      xPathStep(nodes, steps, step + 1, nodelist[i], ctx);
+    }
+  }
+}
+
+function StepExpr(axis, nodetest, predicate) {
+  this.axis = axis;
+  this.nodetest = nodetest;
+  this.predicate = predicate || [];
+}
+
+StepExpr.prototype.appendPredicate = function(p) {
+  this.predicate.push(p);
+}
+
+StepExpr.prototype.evaluate = function(ctx) {
+  var input = ctx.node;
+  var nodelist = [];
+
+  // NOTE(mesch): When this was a switch() statement, it didn't work
+  // in Safari/2.0. Not sure why though; it resulted in the JavaScript
+  // console output &quot;undefined&quot; (without any line number or so).
+
+  if (this.axis ==  xpathAxis.ANCESTOR_OR_SELF) {
+    nodelist.push(input);
+    for (var n = input.parentNode; n; n = input.parentNode) {
+      nodelist.push(n);
+    }
+
+  } else if (this.axis == xpathAxis.ANCESTOR) {
+    for (var n = input.parentNode; n; n = input.parentNode) {
+      nodelist.push(n);
+    }
+
+  } else if (this.axis == xpathAxis.ATTRIBUTE) {
+    copyArray(nodelist, input.attributes);
+
+  } else if (this.axis == xpathAxis.CHILD) {
+    copyArray(nodelist, input.childNodes);
+
+  } else if (this.axis == xpathAxis.DESCENDANT_OR_SELF) {
+    nodelist.push(input);
+    xpathCollectDescendants(nodelist, input);
+
+  } else if (this.axis == xpathAxis.DESCENDANT) {
+    xpathCollectDescendants(nodelist, input);
+
+  } else if (this.axis == xpathAxis.FOLLOWING) {
+    for (var n = input.parentNode; n; n = n.parentNode) {
+      for (var nn = n.nextSibling; nn; nn = nn.nextSibling) {
+        nodelist.push(nn);
+        xpathCollectDescendants(nodelist, nn);
+      }
+    }
+
+  } else if (this.axis == xpathAxis.FOLLOWING_SIBLING) {
+    for (var n = input.nextSibling; n; n = input.nextSibling) {
+      nodelist.push(n);
+    }
+
+  } else if (this.axis == xpathAxis.NAMESPACE) {
+    alert('not implemented: axis namespace');
+
+  } else if (this.axis == xpathAxis.PARENT) {
+    if (input.parentNode) {
+      nodelist.push(input.parentNode);
+    }
+
+  } else if (this.axis == xpathAxis.PRECEDING) {
+    for (var n = input.parentNode; n; n = n.parentNode) {
+      for (var nn = n.previousSibling; nn; nn = nn.previousSibling) {
+        nodelist.push(nn);
+        xpathCollectDescendantsReverse(nodelist, nn);
+      }
+    }
+
+  } else if (this.axis == xpathAxis.PRECEDING_SIBLING) {
+    for (var n = input.previousSibling; n; n = input.previousSibling) {
+      nodelist.push(n);
+    }
+
+  } else if (this.axis == xpathAxis.SELF) {
+    nodelist.push(input);
+
+  } else {
+    throw 'ERROR -- NO SUCH AXIS: ' + this.axis;
+  }
+
+  // process node test
+  var nodelist0 = nodelist;
+  nodelist = [];
+  for (var i = 0; i &lt; nodelist0.length; ++i) {
+    var n = nodelist0[i];
+    if (this.nodetest.evaluate(ctx.clone(n, i, nodelist0)).booleanValue()) {
+      nodelist.push(n);
+    }
+  }
+
+  // process predicates
+  for (var i = 0; i &lt; this.predicate.length; ++i) {
+    var nodelist0 = nodelist;
+    nodelist = [];
+    for (var ii = 0; ii &lt; nodelist0.length; ++ii) {
+      var n = nodelist0[ii];
+      if (this.predicate[i].evaluate(ctx.clone(n, ii, nodelist0)).booleanValue()) {
+        nodelist.push(n);
+      }
+    }
+  }
+
+  return new NodeSetValue(nodelist);
+};
+
+function NodeTestAny() {
+  this.value = new BooleanValue(true);
+}
+
+NodeTestAny.prototype.evaluate = function(ctx) {
+  return this.value;
+};
+
+function NodeTestElement() {}
+
+NodeTestElement.prototype.evaluate = function(ctx) {
+  return new BooleanValue(ctx.node.nodeType == DOM_ELEMENT_NODE);
+}
+
+function NodeTestText() {}
+
+NodeTestText.prototype.evaluate = function(ctx) {
+  return new BooleanValue(ctx.node.nodeType == DOM_TEXT_NODE);
+}
+
+function NodeTestComment() {}
+
+NodeTestComment.prototype.evaluate = function(ctx) {
+  return new BooleanValue(ctx.node.nodeType == DOM_COMMENT_NODE);
+}
+
+function NodeTestPI(target) {
+  this.target = target;
+}
+
+NodeTestPI.prototype.evaluate = function(ctx) {
+  return new
+  BooleanValue(ctx.node.nodeType == DOM_PROCESSING_INSTRUCTION_NODE &amp;&amp;
+               (!this.target || ctx.node.nodeName == this.target));
+}
+
+function NodeTestNC(nsprefix) {
+  this.regex = new RegExp(&quot;^&quot; + nsprefix + &quot;:&quot;);
+  this.nsprefix = nsprefix;
+}
+
+NodeTestNC.prototype.evaluate = function(ctx) {
+  var n = ctx.node;
+  return new BooleanValue(this.regex.match(n.nodeName));
+}
+
+function NodeTestName(name) {
+  this.name = name;
+}
+
+NodeTestName.prototype.evaluate = function(ctx) {
+  var n = ctx.node;
+  return new BooleanValue(n.nodeName == this.name);
+}
+
+function PredicateExpr(expr) {
+  this.expr = expr;
+}
+
+PredicateExpr.prototype.evaluate = function(ctx) {
+  var v = this.expr.evaluate(ctx);
+  if (v.type == 'number') {
+    // NOTE(mesch): Internally, position is represented starting with
+    // 0, however in XPath position starts with 1. See functions
+    // position() and last().
+    return new BooleanValue(ctx.position == v.numberValue() - 1);
+  } else {
+    return new BooleanValue(v.booleanValue());
+  }
+};
+
+function FunctionCallExpr(name) {
+  this.name = name;
+  this.args = [];
+}
+
+FunctionCallExpr.prototype.appendArg = function(arg) {
+  this.args.push(arg);
+};
+
+FunctionCallExpr.prototype.evaluate = function(ctx) {
+  var fn = '' + this.name.value;
+  var f = this.xpathfunctions[fn];
+  if (f) {
+    return f.call(this, ctx);
+  } else {
+    Log.write('XPath NO SUCH FUNCTION ' + fn);
+    return new BooleanValue(false);
+  }
+};
+
+FunctionCallExpr.prototype.xpathfunctions = {
+  'last': function(ctx) {
+    assert(this.args.length == 0);
+    // NOTE(mesch): XPath position starts at 1.
+    return new NumberValue(ctx.nodelist.length);
+  },
+
+  'position': function(ctx) {
+    assert(this.args.length == 0);
+    // NOTE(mesch): XPath position starts at 1.
+    return new NumberValue(ctx.position + 1);
+  },
+
+  'count': function(ctx) {
+    assert(this.args.length == 1);
+    var v = this.args[0].evaluate(ctx);
+    return new NumberValue(v.nodeSetValue().length);
+  },
+
+  'id': function(ctx) {
+    assert(this.args.length == 1);
+    var e = this.args.evaluate(ctx);
+    var ret = [];
+    var ids;
+    if (e.type == 'node-set') {
+      ids = [];
+      for (var i = 0; i &lt; e.length; ++i) {
+        var v = xmlValue(e[i]).split(/\s+/);
+        for (var ii = 0; ii &lt; v.length; ++ii) {
+          ids.push(v[ii]);
+        }
+      }
+    } else {
+      ids = e.split(/\s+/);
+    }
+    var d = ctx.node.ownerDocument;
+    for (var i = 0; i &lt; ids.length; ++i) {
+      var n = d.getElementById(ids[i]);
+      if (n) {
+        ret.push(n);
+      }
+    }
+    return new NodeSetValue(ret);
+  },
+
+  'local-name': function(ctx) {
+    alert('not implmented yet: XPath function local-name()');
+  },
+
+  'namespace-uri': function(ctx) {
+    alert('not implmented yet: XPath function namespace-uri()');
+  },
+
+  'name': function(ctx) {
+    assert(this.args.length == 1 || this.args.length == 0);
+    var n;
+    if (this.args.length == 0) {
+      n = [ ctx.node ];
+    } else {
+      n = this.args[0].evaluate(ctx).nodeSetValue();
+    }
+
+    if (n.length == 0) {
+      return new StringValue('');
+    } else {
+      return new StringValue(n[0].nodeName);
+    }
+  },
+
+  'string':  function(ctx) {
+    assert(this.args.length == 1 || this.args.length == 0);
+    if (this.args.length == 0) {
+      return new StringValue(new NodeSetValue([ ctx.node ]).stringValue());
+    } else {
+      return new StringValue(this.args[0].evaluate(ctx).stringValue());
+    }
+  },
+
+  'concat': function(ctx) {
+    var ret = '';
+    for (var i = 0; i &lt; this.args.length; ++i) {
+      ret += this.args[i].evaluate(ctx).stringValue();
+    }
+    return new StringValue(ret);
+  },
+
+  'starts-with': function(ctx) {
+    assert(this.args.length == 2);
+    var s0 = this.args[0].evaluate(ctx).stringValue();
+    var s1 = this.args[1].evaluate(ctx).stringValue();
+    return new BooleanValue(s0.indexOf(s1) == 0);
+  },
+
+  'contains': function(ctx) {
+    assert(this.args.length == 2);
+    var s0 = this.args[0].evaluate(ctx).stringValue();
+    var s1 = this.args[1].evaluate(ctx).stringValue();
+    return new BooleanValue(s0.indexOf(s1) != -1);
+  },
+
+  'substring-before': function(ctx) {
+    assert(this.args.length == 2);
+    var s0 = this.args[0].evaluate(ctx).stringValue();
+    var s1 = this.args[1].evaluate(ctx).stringValue();
+    var i = s0.indexOf(s1);
+    var ret;
+    if (i == -1) {
+      ret = '';
+    } else {
+      ret = s0.substr(0,i);
+    }
+    return new StringValue(ret);
+  },
+
+  'substring-after': function(ctx) {
+    assert(this.args.length == 2);
+    var s0 = this.args[0].evaluate(ctx).stringValue();
+    var s1 = this.args[1].evaluate(ctx).stringValue();
+    var i = s0.indexOf(s1);
+    var ret;
+    if (i == -1) {
+      ret = '';
+    } else {
+      ret = s0.substr(i + s1.length);
+    }
+    return new StringValue(ret);
+  },
+
+  'substring': function(ctx) {
+    // NOTE: XPath defines the position of the first character in a
+    // string to be 1, in JavaScript this is 0 ([XPATH] Section 4.2).
+    assert(this.args.length == 2 || this.args.length == 3);
+    var s0 = this.args[0].evaluate(ctx).stringValue();
+    var s1 = this.args[1].evaluate(ctx).numberValue();
+    var ret;
+    if (this.args.length == 2) {
+      var i1 = Math.max(0, Math.round(s1) - 1);
+      ret = s0.substr(i1);
+
+    } else {
+      var s2 = this.args[2].evaluate(ctx).numberValue();
+      var i0 = Math.round(s1) - 1;
+      var i1 = Math.max(0, i0);
+      var i2 = Math.round(s2) - Math.max(0, -i0);
+      ret = s0.substr(i1, i2);
+    }
+    return new StringValue(ret);
+  },
+
+  'string-length': function(ctx) {
+    var s;
+    if (this.args.length &gt; 0) {
+      s = this.args[0].evaluate(ctx).stringValue();
+    } else {
+      s = new NodeSetValue([ ctx.node ]).stringValue();
+    }
+    return new NumberValue(s.length);
+  },
+
+  'normalize-space': function(ctx) {
+    var s;
+    if (this.args.length &gt; 0) {
+      s = this.args[0].evaluate(ctx).stringValue();
+    } else {
+      s = new NodeSetValue([ ctx.node ]).stringValue();
+    }
+    s = s.replace(/^\s*/,'').replace(/\s*$/,'').replace(/\s+/g, ' ');
+    return new StringValue(s);
+  },
+
+  'translate': function(ctx) {
+    assert(this.args.length == 3);
+    var s0 = this.args[0].evaluate(ctx).stringValue();
+    var s1 = this.args[1].evaluate(ctx).stringValue();
+    var s2 = this.args[2].evaluate(ctx).stringValue();
+
+    for (var i = 0; i &lt; s1.length; ++i) {
+      s0 = s0.replace(new RegExp(s1.charAt(i), 'g'), s2.charAt(i));
+    }
+    return new StringValue(s0);
+  },
+
+  'boolean': function(ctx) {
+    assert(this.args.length == 1);
+    return new BooleanValue(this.args[0].evaluate(ctx).booleanValue());
+  },
+
+  'not': function(ctx) {
+    assert(this.args.length == 1);
+    var ret = !this.args[0].evaluate(ctx).booleanValue();
+    return new BooleanValue(ret);
+  },
+
+  'true': function(ctx) {
+    assert(this.args.length == 0);
+    return new BooleanValue(true);
+  },
+
+  'false': function(ctx) {
+    assert(this.args.length == 0);
+    return new BooleanValue(false);
+  },
+
+  'lang': function(ctx) {
+    assert(this.args.length == 1);
+    var lang = this.args[0].evaluate(ctx).stringValue();
+    var xmllang;
+    var n = ctx.node;
+    while (n &amp;&amp; n != n.parentNode /* just in case ... */) {
+      xmllang = n.getAttribute('xml:lang');
+      if (xmllang) {
+        break;
+      }
+      n = n.parentNode;
+    }
+    if (!xmllang) {
+      return new BooleanValue(false);
+    } else {
+      var re = new RegExp('^' + lang + '$', 'i');
+      return new BooleanValue(xmllang.match(re) ||
+                              xmllang.replace(/_.*$/,'').match(re));
+    }
+  },
+
+  'number': function(ctx) {
+    assert(this.args.length == 1 || this.args.length == 0);
+
+    if (this.args.length == 1) {
+      return new NumberValue(this.args[0].evaluate(ctx).numberValue());
+    } else {
+      return new NumberValue(new NodeSetValue([ ctx.node ]).numberValue());
+    }
+  },
+
+  'sum': function(ctx) {
+    assert(this.args.length == 1);
+    var n = this.args[0].evaluate(ctx).nodeSetValue();
+    var sum = 0;
+    for (var i = 0; i &lt; n.length; ++i) {
+      sum += xmlValue(n[i]) - 0;
+    }
+    return new NumberValue(sum);
+  },
+
+  'floor': function(ctx) {
+    assert(this.args.length == 1);
+    var num = this.args[0].evaluate(ctx).numberValue();
+    return new NumberValue(Math.floor(num));
+  },
+
+  'ceiling': function(ctx) {
+    assert(this.args.length == 1);
+    var num = this.args[0].evaluate(ctx).numberValue();
+    return new NumberValue(Math.ceil(num));
+  },
+
+  'round': function(ctx) {
+    assert(this.args.length == 1);
+    var num = this.args[0].evaluate(ctx).numberValue();
+    return new NumberValue(Math.round(num));
+  },
+
+  // TODO(mesch): The following functions are custom. There is a
+  // standard that defines how to add functions, which should be
+  // applied here.
+
+  'ext-join': function(ctx) {
+    assert(this.args.length == 2);
+    var nodes = this.args[0].evaluate(ctx).nodeSetValue();
+    var delim = this.args[1].evaluate(ctx).stringValue();
+    var ret = '';
+    for (var i = 0; i &lt; nodes.length; ++i) {
+      if (ret) {
+        ret += delim;
+      }
+      ret += xmlValue(nodes[i]);
+    }
+    return new StringValue(ret);
+  },
+
+  // ext-if() evaluates and returns its second argument, if the
+  // boolean value of its first argument is true, otherwise it
+  // evaluates and returns its third argument.
+
+  'ext-if': function(ctx) {
+    assert(this.args.length == 3);
+    if (this.args[0].evaluate(ctx).booleanValue()) {
+      return this.args[1].evaluate(ctx);
+    } else {
+      return this.args[2].evaluate(ctx);
+    }
+  },
+
+  'ext-sprintf': function(ctx) {
+    assert(this.args.length &gt;= 1);
+    var args = [];
+    for (var i = 0; i &lt; this.args.length; ++i) {
+      args.push(this.args[i].evaluate(ctx).stringValue());
+    }
+    return new StringValue(sprintf.apply(null, args));
+  },
+
+  // ext-cardinal() evaluates its single argument as a number, and
+  // returns the current node that many times. It can be used in the
+  // select attribute to iterate over an integer range.
+  
+  'ext-cardinal': function(ctx) {
+    assert(this.args.length &gt;= 1);
+    var c = this.args[0].evaluate(ctx).numberValue();
+    var ret = [];
+    for (var i = 0; i &lt; c; ++i) {
+      ret.push(ctx.node);
+    }
+    return new NodeSetValue(ret);
+  }
+};
+
+function UnionExpr(expr1, expr2) {
+  this.expr1 = expr1;
+  this.expr2 = expr2;
+}
+
+UnionExpr.prototype.evaluate = function(ctx) {
+  var nodes1 = this.expr1.evaluate(ctx).nodeSetValue();
+  var nodes2 = this.expr2.evaluate(ctx).nodeSetValue();
+  var I1 = nodes1.length;
+  for (var i2 = 0; i2 &lt; nodes2.length; ++i2) {
+    for (var i1 = 0; i1 &lt; I1; ++i1) {
+      if (nodes1[i1] == nodes2[i2]) {
+        // break inner loop and continue outer loop, labels confuse
+        // the js compiler, so we don't use them here.
+        i1 = I1;
+      }
+    }
+    nodes1.push(nodes2[i2]);
+  }
+  return new NodeSetValue(nodes2);
+};
+
+function PathExpr(filter, rel) {
+  this.filter = filter;
+  this.rel = rel;
+}
+
+PathExpr.prototype.evaluate = function(ctx) {
+  var nodes = this.filter.evaluate(ctx).nodeSetValue();
+  var nodes1 = [];
+  for (var i = 0; i &lt; nodes.length; ++i) {
+    var nodes0 = this.rel.evaluate(ctx.clone(nodes[i], i, nodes)).nodeSetValue();
+    for (var ii = 0; ii &lt; nodes0.length; ++ii) {
+      nodes1.push(nodes0[ii]);
+    }
+  }
+  return new NodeSetValue(nodes1);
+};
+
+function FilterExpr(expr, predicate) {
+  this.expr = expr;
+  this.predicate = predicate;
+}
+
+FilterExpr.prototype.evaluate = function(ctx) {
+  var nodes = this.expr.evaluate(ctx).nodeSetValue();
+  for (var i = 0; i &lt; this.predicate.length; ++i) {
+    var nodes0 = nodes;
+    nodes = [];
+    for (var j = 0; j &lt; nodes0.length; ++j) {
+      var n = nodes0[j];
+      if (this.predicate[i].evaluate(ctx.clone(n, j, nodes0)).booleanValue()) {
+        nodes.push(n);
+      }
+    }
+  }
+
+  return new NodeSetValue(nodes);
+}
+
+function UnaryMinusExpr(expr) {
+  this.expr = expr;
+}
+
+UnaryMinusExpr.prototype.evaluate = function(ctx) {
+  return new NumberValue(-this.expr.evaluate(ctx).numberValue());
+};
+
+function BinaryExpr(expr1, op, expr2) {
+  this.expr1 = expr1;
+  this.expr2 = expr2;
+  this.op = op;
+}
+
+BinaryExpr.prototype.evaluate = function(ctx) {
+  var ret;
+  switch (this.op.value) {
+    case 'or':
+      ret = new BooleanValue(this.expr1.evaluate(ctx).booleanValue() ||
+                             this.expr2.evaluate(ctx).booleanValue());
+      break;
+
+    case 'and':
+      ret = new BooleanValue(this.expr1.evaluate(ctx).booleanValue() &amp;&amp;
+                             this.expr2.evaluate(ctx).booleanValue());
+      break;
+
+    case '+':
+      ret = new NumberValue(this.expr1.evaluate(ctx).numberValue() +
+                            this.expr2.evaluate(ctx).numberValue());
+      break;
+
+    case '-':
+      ret = new NumberValue(this.expr1.evaluate(ctx).numberValue() -
+                            this.expr2.evaluate(ctx).numberValue());
+      break;
+
+    case '*':
+      ret = new NumberValue(this.expr1.evaluate(ctx).numberValue() *
+                            this.expr2.evaluate(ctx).numberValue());
+      break;
+
+    case 'mod':
+      ret = new NumberValue(this.expr1.evaluate(ctx).numberValue() %
+                            this.expr2.evaluate(ctx).numberValue());
+      break;
+
+    case 'div':
+      ret = new NumberValue(this.expr1.evaluate(ctx).numberValue() /
+                            this.expr2.evaluate(ctx).numberValue());
+      break;
+
+    case '=':
+      ret = this.compare(ctx, function(x1, x2) { return x1 == x2; });
+      break;
+
+    case '!=':
+      ret = this.compare(ctx, function(x1, x2) { return x1 != x2; });
+      break;
+
+    case '&lt;':
+      ret = this.compare(ctx, function(x1, x2) { return x1 &lt; x2; });
+      break;
+
+    case '&lt;=':
+      ret = this.compare(ctx, function(x1, x2) { return x1 &lt;= x2; });
+      break;
+
+    case '&gt;':
+      ret = this.compare(ctx, function(x1, x2) { return x1 &gt; x2; });
+      break;
+
+    case '&gt;=':
+      ret = this.compare(ctx, function(x1, x2) { return x1 &gt;= x2; });
+      break;
+
+    default:
+      alert('BinaryExpr.evaluate: ' + this.op.value);
+  }
+  return ret;
+};
+
+BinaryExpr.prototype.compare = function(ctx, cmp) {
+  var v1 = this.expr1.evaluate(ctx);
+  var v2 = this.expr2.evaluate(ctx);
+
+  var ret;
+  if (v1.type == 'node-set' &amp;&amp; v2.type == 'node-set') {
+    var n1 = v1.nodeSetValue();
+    var n2 = v2.nodeSetValue();
+    ret = false;
+    for (var i1 = 0; i1 &lt; n1.length; ++i1) {
+      for (var i2 = 0; i2 &lt; n2.length; ++i2) {
+        if (cmp(xmlValue(n1[i1]), xmlValue(n2[i2]))) {
+          ret = true;
+          // Break outer loop. Labels confuse the jscompiler and we
+          // don't use them.
+          i2 = n2.length;
+          i1 = n1.length;
+        }
+      }
+    }
+
+  } else if (v1.type == 'node-set' || v2.type == 'node-set') {
+
+    if (v1.type == 'number') {
+      var s = v1.numberValue();
+      var n = v2.nodeSetValue();
+
+      ret = false;
+      for (var i = 0;  i &lt; n.length; ++i) {
+        var nn = xmlValue(n[i]) - 0;
+        if (cmp(s, nn)) {
+          ret = true;
+          break;
+        }
+      }
+
+    } else if (v2.type == 'number') {
+      var n = v1.nodeSetValue();
+      var s = v2.numberValue();
+
+      ret = false;
+      for (var i = 0;  i &lt; n.length; ++i) {
+        var nn = xmlValue(n[i]) - 0;
+        if (cmp(nn, s)) {
+          ret = true;
+          break;
+        }
+      }
+
+    } else if (v1.type == 'string') {
+      var s = v1.stringValue();
+      var n = v2.nodeSetValue();
+
+      ret = false;
+      for (var i = 0;  i &lt; n.length; ++i) {
+        var nn = xmlValue(n[i]);
+        if (cmp(s, nn)) {
+          ret = true;
+          break;
+        }
+      }
+
+    } else if (v2.type == 'string') {
+      var n = v1.nodeSetValue();
+      var s = v2.stringValue();
+
+      ret = false;
+      for (var i = 0;  i &lt; n.length; ++i) {
+        var nn = xmlValue(n[i]);
+        if (cmp(nn, s)) {
+          ret = true;
+          break;
+        }
+      }
+
+    } else {
+      ret = cmp(v1.booleanValue(), v2.booleanValue());
+    }
+
+  } else if (v1.type == 'boolean' || v2.type == 'boolean') {
+    ret = cmp(v1.booleanValue(), v2.booleanValue());
+
+  } else if (v1.type == 'number' || v2.type == 'number') {
+    ret = cmp(v1.numberValue(), v2.numberValue());
+
+  } else {
+    ret = cmp(v1.stringValue(), v2.stringValue());
+  }
+
+  return new BooleanValue(ret);
+}
+
+function LiteralExpr(value) {
+  this.value = value;
+}
+
+LiteralExpr.prototype.evaluate = function(ctx) {
+  return new StringValue(this.value);
+};
+
+function NumberExpr(value) {
+  this.value = value;
+}
+
+NumberExpr.prototype.evaluate = function(ctx) {
+  return new NumberValue(this.value);
+};
+
+function VariableExpr(name) {
+  this.name = name;
+}
+
+VariableExpr.prototype.evaluate = function(ctx) {
+  return ctx.getVariable(this.name);
+}
+
+// Factory functions for semantic values (i.e. Expressions) of the
+// productions in the grammar. When a production is matched to reduce
+// the current parse state stack, the function is called with the
+// semantic values of the matched elements as arguments, and returns
+// another semantic value. The semantic value is a node of the parse
+// tree, an expression object with an evaluate() method that evaluates the
+// expression in an actual context. These factory functions are used
+// in the specification of the grammar rules, below.
+
+function makeTokenExpr(m) {
+  return new TokenExpr(m);
+}
+
+function passExpr(e) {
+  return e;
+}
+
+function makeLocationExpr1(slash, rel) {
+  rel.absolute = true;
+  return rel;
+}
+
+function makeLocationExpr2(dslash, rel) {
+  rel.absolute = true;
+  rel.prependStep(makeAbbrevStep(dslash.value));
+  return rel;
+}
+
+function makeLocationExpr3(slash) {
+  var ret = new LocationExpr();
+  ret.appendStep(makeAbbrevStep('.'));
+  ret.absolute = true;
+  return ret;
+}
+
+function makeLocationExpr4(dslash) {
+  var ret = new LocationExpr();
+  ret.absolute = true;
+  ret.appendStep(makeAbbrevStep(dslash.value));
+  return ret;
+}
+
+function makeLocationExpr5(step) {
+  var ret = new LocationExpr();
+  ret.appendStep(step);
+  return ret;
+}
+
+function makeLocationExpr6(rel, slash, step) {
+  rel.appendStep(step);
+  return rel;
+}
+
+function makeLocationExpr7(rel, dslash, step) {
+  rel.appendStep(makeAbbrevStep(dslash.value));
+  return rel;
+}
+
+function makeStepExpr1(dot) {
+  return makeAbbrevStep(dot.value);
+}
+
+function makeStepExpr2(ddot) {
+  return makeAbbrevStep(ddot.value);
+}
+
+function makeStepExpr3(axisname, axis, nodetest) {
+  return new StepExpr(axisname.value, nodetest);
+}
+
+function makeStepExpr4(at, nodetest) {
+  return new StepExpr('attribute', nodetest);
+}
+
+function makeStepExpr5(nodetest) {
+  return new StepExpr('child', nodetest);
+}
+
+function makeStepExpr6(step, predicate) {
+  step.appendPredicate(predicate);
+  return step;
+}
+
+function makeAbbrevStep(abbrev) {
+  switch (abbrev) {
+  case '//':
+    return new StepExpr('descendant-or-self', new NodeTestAny);
+
+  case '.':
+    return new StepExpr('self', new NodeTestAny);
+
+  case '..':
+    return new StepExpr('parent', new NodeTestAny);
+  }
+}
+
+function makeNodeTestExpr1(asterisk) {
+  return new NodeTestElement;
+}
+
+function makeNodeTestExpr2(ncname, colon, asterisk) {
+  return new NodeTestNC(ncname.value);
+}
+
+function makeNodeTestExpr3(qname) {
+  return new NodeTestName(qname.value);
+}
+
+function makeNodeTestExpr4(typeo, parenc) {
+  var type = typeo.value.replace(/\s*\($/, '');
+  switch(type) {
+  case 'node':
+    return new NodeTestAny;
+
+  case 'text':
+    return new NodeTestText;
+
+  case 'comment':
+    return new NodeTestComment;
+
+  case 'processing-instruction':
+    return new NodeTestPI;
+  }
+}
+
+function makeNodeTestExpr5(typeo, target, parenc) {
+  var type = typeo.replace(/\s*\($/, '');
+  if (type != 'processing-instruction') {
+    throw type + ' ' + Error().stack;
+  }
+  return new NodeTestPI(target.value);
+}
+
+function makePredicateExpr(pareno, expr, parenc) {
+  return new PredicateExpr(expr);
+}
+
+function makePrimaryExpr(pareno, expr, parenc) {
+  return expr;
+}
+
+function makeFunctionCallExpr1(name, pareno, parenc) {
+  return new FunctionCallExpr(name);
+}
+
+function makeFunctionCallExpr2(name, pareno, arg1, args, parenc) {
+  var ret = new FunctionCallExpr(name);
+  ret.appendArg(arg1);
+  for (var i = 0; i &lt; args.length; ++i) {
+    ret.appendArg(args[i]);
+  }
+  return ret;
+}
+
+function makeArgumentExpr(comma, expr) {
+  return expr;
+}
+
+function makeUnionExpr(expr1, pipe, expr2) {
+  return new UnionExpr(expr1, expr2);
+}
+
+function makePathExpr1(filter, slash, rel) {
+  return new PathExpr(filter, rel);
+}
+
+function makePathExpr2(filter, dslash, rel) {
+  rel.prependStep(makeAbbrevStep(dslash.value));
+  return new PathExpr(filter, rel);
+}
+
+function makeFilterExpr(expr, predicates) {
+  if (predicates.length &gt; 0) {
+    return new FilterExpr(expr, predicates);
+  } else {
+    return expr;
+  }
+}
+
+function makeUnaryMinusExpr(minus, expr) {
+  return new UnaryMinusExpr(expr);
+}
+
+function makeBinaryExpr(expr1, op, expr2) {
+  return new BinaryExpr(expr1, op, expr2);
+}
+
+function makeLiteralExpr(token) {
+  // remove quotes from the parsed value:
+  var value = token.value.substring(1, token.value.length - 1);
+  return new LiteralExpr(value);
+}
+
+function makeNumberExpr(token) {
+  return new NumberExpr(token.value);
+}
+
+function makeVariableReference(dollar, name) {
+  return new VariableExpr(name.value);
+}
+
+// Used before parsing for optimization of common simple cases. See
+// the begin of xpathParse() for which they are.
+function makeSimpleExpr(expr) {
+  if (expr.charAt(0) == '$') {
+    return new VariableExpr(expr.substr(1));
+  } else if (expr.charAt(0) == '@') {
+    var a = new NodeTestName(expr.substr(1));
+    var b = new StepExpr('attribute', a);
+    var c = new LocationExpr();
+    c.appendStep(b);
+    return c;
+  } else if (expr.match(/^[0-9]+$/)) {
+    return new NumberExpr(expr);
+  } else {
+    var a = new NodeTestName(expr);
+    var b = new StepExpr('child', a);
+    var c = new LocationExpr();
+    c.appendStep(b);
+    return c;
+  }
+}
+
+function makeSimpleExpr2(expr) {
+  var steps = expr.split('/');
+  var c = new LocationExpr();
+  for (var i = 0; i &lt; steps.length; i++) {
+    var a = new NodeTestName(steps[i]);
+    var b = new StepExpr('child', a);
+    c.appendStep(b);
+  }
+  return c;
+}
+
+// The axes of XPath expressions.
+
+var xpathAxis = {
+  ANCESTOR_OR_SELF: 'ancestor-or-self',
+  ANCESTOR: 'ancestor',
+  ATTRIBUTE: 'attribute',
+  CHILD: 'child',
+  DESCENDANT_OR_SELF: 'descendant-or-self',
+  DESCENDANT: 'descendant',
+  FOLLOWING_SIBLING: 'following-sibling',
+  FOLLOWING: 'following',
+  NAMESPACE: 'namespace',
+  PARENT: 'parent',
+  PRECEDING_SIBLING: 'preceding-sibling',
+  PRECEDING: 'preceding',
+  SELF: 'self'
+};
+
+var xpathAxesRe = [
+    xpathAxis.ANCESTOR_OR_SELF,
+    xpathAxis.ANCESTOR,
+    xpathAxis.ATTRIBUTE,
+    xpathAxis.CHILD,
+    xpathAxis.DESCENDANT_OR_SELF,
+    xpathAxis.DESCENDANT,
+    xpathAxis.FOLLOWING_SIBLING,
+    xpathAxis.FOLLOWING,
+    xpathAxis.NAMESPACE,
+    xpathAxis.PARENT,
+    xpathAxis.PRECEDING_SIBLING,
+    xpathAxis.PRECEDING,
+    xpathAxis.SELF
+].join('|');
+
+
+// The tokens of the language. The label property is just used for
+// generating debug output. The prec property is the precedence used
+// for shift/reduce resolution. Default precedence is 0 as a lookahead
+// token and 2 on the stack. TODO(mesch): this is certainly not
+// necessary and too complicated. Simplify this!
+
+// NOTE: tabular formatting is the big exception, but here it should
+// be OK.
+
+var TOK_PIPE =   { label: &quot;|&quot;,   prec:   17, re: new RegExp(&quot;^\\|&quot;) };
+var TOK_DSLASH = { label: &quot;//&quot;,  prec:   19, re: new RegExp(&quot;^//&quot;)  };
+var TOK_SLASH =  { label: &quot;/&quot;,   prec:   30, re: new RegExp(&quot;^/&quot;)   };
+var TOK_AXIS =   { label: &quot;::&quot;,  prec:   20, re: new RegExp(&quot;^::&quot;)  };
+var TOK_COLON =  { label: &quot;:&quot;,   prec: 1000, re: new RegExp(&quot;^:&quot;)  };
+var TOK_AXISNAME = { label: &quot;[axis]&quot;, re: new RegExp('^(' + xpathAxesRe + ')') };
+var TOK_PARENO = { label: &quot;(&quot;,   prec:   34, re: new RegExp(&quot;^\\(&quot;) };
+var TOK_PARENC = { label: &quot;)&quot;,               re: new RegExp(&quot;^\\)&quot;) };
+var TOK_DDOT =   { label: &quot;..&quot;,  prec:   34, re: new RegExp(&quot;^\\.\\.&quot;) };
+var TOK_DOT =    { label: &quot;.&quot;,   prec:   34, re: new RegExp(&quot;^\\.&quot;) };
+var TOK_AT =     { label: &quot;@&quot;,   prec:   34, re: new RegExp(&quot;^@&quot;)   };
+
+var TOK_COMMA =  { label: &quot;,&quot;,               re: new RegExp(&quot;^,&quot;) };
+
+var TOK_OR =     { label: &quot;or&quot;,  prec:   10, re: new RegExp(&quot;^or\\b&quot;) };
+var TOK_AND =    { label: &quot;and&quot;, prec:   11, re: new RegExp(&quot;^and\\b&quot;) };
+var TOK_EQ =     { label: &quot;=&quot;,   prec:   12, re: new RegExp(&quot;^=&quot;)   };
+var TOK_NEQ =    { label: &quot;!=&quot;,  prec:   12, re: new RegExp(&quot;^!=&quot;)  };
+var TOK_GE =     { label: &quot;&gt;=&quot;,  prec:   13, re: new RegExp(&quot;^&gt;=&quot;)  };
+var TOK_GT =     { label: &quot;&gt;&quot;,   prec:   13, re: new RegExp(&quot;^&gt;&quot;)   };
+var TOK_LE =     { label: &quot;&lt;=&quot;,  prec:   13, re: new RegExp(&quot;^&lt;=&quot;)  };
+var TOK_LT =     { label: &quot;&lt;&quot;,   prec:   13, re: new RegExp(&quot;^&lt;&quot;)   };
+var TOK_PLUS =   { label: &quot;+&quot;,   prec:   14, re: new RegExp(&quot;^\\+&quot;), left: true };
+var TOK_MINUS =  { label: &quot;-&quot;,   prec:   14, re: new RegExp(&quot;^\\-&quot;), left: true };
+var TOK_DIV =    { label: &quot;div&quot;, prec:   15, re: new RegExp(&quot;^div\\b&quot;), left: true };
+var TOK_MOD =    { label: &quot;mod&quot;, prec:   15, re: new RegExp(&quot;^mod\\b&quot;), left: true };
+
+var TOK_BRACKO = { label: &quot;[&quot;,   prec:   32, re: new RegExp(&quot;^\\[&quot;) };
+var TOK_BRACKC = { label: &quot;]&quot;,               re: new RegExp(&quot;^\\]&quot;) };
+var TOK_DOLLAR = { label: &quot;$&quot;,               re: new RegExp(&quot;^\\$&quot;) };
+
+var TOK_NCNAME = { label: &quot;[ncname]&quot;, re: new RegExp('^[a-z][-\\w]*','i') };
+
+var TOK_ASTERISK = { label: &quot;*&quot;, prec: 15, re: new RegExp(&quot;^\\*&quot;), left: true };
+var TOK_LITERALQ = { label: &quot;[litq]&quot;, prec: 20, re: new RegExp(&quot;^'[^\\']*'&quot;) };
+var TOK_LITERALQQ = {
+  label: &quot;[litqq]&quot;,
+  prec: 20,
+  re: new RegExp('^&quot;[^\\&quot;]*&quot;')
+};
+
+var TOK_NUMBER  = {
+  label: &quot;[number]&quot;,
+  prec: 35,
+  re: new RegExp('^\\d+(\\.\\d*)?') };
+
+var TOK_QNAME = {
+  label: &quot;[qname]&quot;,
+  re: new RegExp('^([a-z][-\\w]*:)?[a-z][-\\w]*','i')
+};
+
+var TOK_NODEO = {
+  label: &quot;[nodetest-start]&quot;,
+  re: new RegExp('^(processing-instruction|comment|text|node)\\(')
+};
+
+// The table of the tokens of our grammar, used by the lexer: first
+// column the tag, second column a regexp to recognize it in the
+// input, third column the precedence of the token, fourth column a
+// factory function for the semantic value of the token.
+//
+// NOTE: order of this list is important, because the first match
+// counts. Cf. DDOT and DOT, and AXIS and COLON.
+
+var xpathTokenRules = [
+    TOK_DSLASH,
+    TOK_SLASH,
+    TOK_DDOT,
+    TOK_DOT,
+    TOK_AXIS,
+    TOK_COLON,
+    TOK_AXISNAME,
+    TOK_NODEO,
+    TOK_PARENO,
+    TOK_PARENC,
+    TOK_BRACKO,
+    TOK_BRACKC,
+    TOK_AT,
+    TOK_COMMA,
+    TOK_OR,
+    TOK_AND,
+    TOK_NEQ,
+    TOK_EQ,
+    TOK_GE,
+    TOK_GT,
+    TOK_LE,
+    TOK_LT,
+    TOK_PLUS,
+    TOK_MINUS,
+    TOK_ASTERISK,
+    TOK_PIPE,
+    TOK_MOD,
+    TOK_DIV,
+    TOK_LITERALQ,
+    TOK_LITERALQQ,
+    TOK_NUMBER,
+    TOK_QNAME,
+    TOK_NCNAME,
+    TOK_DOLLAR
+];
+
+// All the nonterminals of the grammar. The nonterminal objects are
+// identified by object identity; the labels are used in the debug
+// output only.
+var XPathLocationPath = { label: &quot;LocationPath&quot; };
+var XPathRelativeLocationPath = { label: &quot;RelativeLocationPath&quot; };
+var XPathAbsoluteLocationPath = { label: &quot;AbsoluteLocationPath&quot; };
+var XPathStep = { label: &quot;Step&quot; };
+var XPathNodeTest = { label: &quot;NodeTest&quot; };
+var XPathPredicate = { label: &quot;Predicate&quot; };
+var XPathLiteral = { label: &quot;Literal&quot; };
+var XPathExpr = { label: &quot;Expr&quot; };
+var XPathPrimaryExpr = { label: &quot;PrimaryExpr&quot; };
+var XPathVariableReference = { label: &quot;Variablereference&quot; };
+var XPathNumber = { label: &quot;Number&quot; };
+var XPathFunctionCall = { label: &quot;FunctionCall&quot; };
+var XPathArgumentRemainder = { label: &quot;ArgumentRemainder&quot; };
+var XPathPathExpr = { label: &quot;PathExpr&quot; };
+var XPathUnionExpr = { label: &quot;UnionExpr&quot; };
+var XPathFilterExpr = { label: &quot;FilterExpr&quot; };
+var XPathDigits = { label: &quot;Digits&quot; };
+
+var xpathNonTerminals = [
+    XPathLocationPath,
+    XPathRelativeLocationPath,
+    XPathAbsoluteLocationPath,
+    XPathStep,
+    XPathNodeTest,
+    XPathPredicate,
+    XPathLiteral,
+    XPathExpr,
+    XPathPrimaryExpr,
+    XPathVariableReference,
+    XPathNumber,
+    XPathFunctionCall,
+    XPathArgumentRemainder,
+    XPathPathExpr,
+    XPathUnionExpr,
+    XPathFilterExpr,
+    XPathDigits
+];
+
+// Quantifiers that are used in the productions of the grammar.
+var Q_01 = { label: &quot;?&quot; };
+var Q_MM = { label: &quot;*&quot; };
+var Q_1M = { label: &quot;+&quot; };
+
+// Tag for left associativity (right assoc is implied by undefined).
+var ASSOC_LEFT = true;
+
+// The productions of the grammar. Columns of the table:
+//
+// - target nonterminal,
+// - pattern,
+// - precedence,
+// - semantic value factory
+//
+// The semantic value factory is a function that receives parse tree
+// nodes from the stack frames of the matched symbols as arguments and
+// returns an a node of the parse tree. The node is stored in the top
+// stack frame along with the target object of the rule. The node in
+// the parse tree is an expression object that has an evaluate() method
+// and thus evaluates XPath expressions.
+//
+// The precedence is used to decide between reducing and shifting by
+// comparing the precendence of the rule that is candidate for
+// reducing with the precedence of the look ahead token. Precedence of
+// -1 means that the precedence of the tokens in the pattern is used
+// instead. TODO: It shouldn't be necessary to explicitly assign
+// precedences to rules.
+
+var xpathGrammarRules =
+  [
+   [ XPathLocationPath, [ XPathRelativeLocationPath ], 18,
+     passExpr ],
+   [ XPathLocationPath, [ XPathAbsoluteLocationPath ], 18,
+     passExpr ],
+
+   [ XPathAbsoluteLocationPath, [ TOK_SLASH, XPathRelativeLocationPath ], 18, 
+     makeLocationExpr1 ],
+   [ XPathAbsoluteLocationPath, [ TOK_DSLASH, XPathRelativeLocationPath ], 18,
+     makeLocationExpr2 ],
+
+   [ XPathAbsoluteLocationPath, [ TOK_SLASH ], 0,
+     makeLocationExpr3 ],
+   [ XPathAbsoluteLocationPath, [ TOK_DSLASH ], 0,
+     makeLocationExpr4 ],
+
+   [ XPathRelativeLocationPath, [ XPathStep ], 31,
+     makeLocationExpr5 ],
+   [ XPathRelativeLocationPath,
+     [ XPathRelativeLocationPath, TOK_SLASH, XPathStep ], 31,
+     makeLocationExpr6 ],
+   [ XPathRelativeLocationPath,
+     [ XPathRelativeLocationPath, TOK_DSLASH, XPathStep ], 31,
+     makeLocationExpr7 ],
+
+   [ XPathStep, [ TOK_DOT ], 33,
+     makeStepExpr1 ],
+   [ XPathStep, [ TOK_DDOT ], 33,
+     makeStepExpr2 ],
+   [ XPathStep,
+     [ TOK_AXISNAME, TOK_AXIS, XPathNodeTest ], 33,
+     makeStepExpr3 ],
+   [ XPathStep, [ TOK_AT, XPathNodeTest ], 33,
+     makeStepExpr4 ],
+   [ XPathStep, [ XPathNodeTest ], 33,
+     makeStepExpr5 ],
+   [ XPathStep, [ XPathStep, XPathPredicate ], 33,
+     makeStepExpr6 ],
+
+   [ XPathNodeTest, [ TOK_ASTERISK ], 33,
+     makeNodeTestExpr1 ],
+   [ XPathNodeTest, [ TOK_NCNAME, TOK_COLON, TOK_ASTERISK ], 33,
+     makeNodeTestExpr2 ],
+   [ XPathNodeTest, [ TOK_QNAME ], 33,
+     makeNodeTestExpr3 ],
+   [ XPathNodeTest, [ TOK_NODEO, TOK_PARENC ], 33,
+     makeNodeTestExpr4 ],
+   [ XPathNodeTest, [ TOK_NODEO, XPathLiteral, TOK_PARENC ], 33,
+     makeNodeTestExpr5 ],
+
+   [ XPathPredicate, [ TOK_BRACKO, XPathExpr, TOK_BRACKC ], 33,
+     makePredicateExpr ],
+
+   [ XPathPrimaryExpr, [ XPathVariableReference ], 33,
+     passExpr ],
+   [ XPathPrimaryExpr, [ TOK_PARENO, XPathExpr, TOK_PARENC ], 33,
+     makePrimaryExpr ],
+   [ XPathPrimaryExpr, [ XPathLiteral ], 30,
+     passExpr ],
+   [ XPathPrimaryExpr, [ XPathNumber ], 30,
+     passExpr ],
+   [ XPathPrimaryExpr, [ XPathFunctionCall ], 30,
+     passExpr ],
+
+   [ XPathFunctionCall, [ TOK_QNAME, TOK_PARENO, TOK_PARENC ], -1,
+     makeFunctionCallExpr1 ],
+   [ XPathFunctionCall,
+     [ TOK_QNAME, TOK_PARENO, XPathExpr, XPathArgumentRemainder, Q_MM,
+       TOK_PARENC ], -1,
+     makeFunctionCallExpr2 ],
+   [ XPathArgumentRemainder, [ TOK_COMMA, XPathExpr ], -1,
+     makeArgumentExpr ],
+
+   [ XPathUnionExpr, [ XPathPathExpr ], 20,
+     passExpr ],
+   [ XPathUnionExpr, [ XPathUnionExpr, TOK_PIPE, XPathPathExpr ], 20,
+     makeUnionExpr ],
+
+   [ XPathPathExpr, [ XPathLocationPath ], 20, 
+     passExpr ], 
+   [ XPathPathExpr, [ XPathFilterExpr ], 19, 
+     passExpr ], 
+   [ XPathPathExpr, 
+     [ XPathFilterExpr, TOK_SLASH, XPathRelativeLocationPath ], 20,
+     makePathExpr1 ],
+   [ XPathPathExpr,
+     [ XPathFilterExpr, TOK_DSLASH, XPathRelativeLocationPath ], 20,
+     makePathExpr2 ],
+
+   [ XPathFilterExpr, [ XPathPrimaryExpr, XPathPredicate, Q_MM ], 20,
+     makeFilterExpr ], 
+
+   [ XPathExpr, [ XPathPrimaryExpr ], 16,
+     passExpr ],
+   [ XPathExpr, [ XPathUnionExpr ], 16,
+     passExpr ],
+
+   [ XPathExpr, [ TOK_MINUS, XPathExpr ], -1,
+     makeUnaryMinusExpr ],
+
+   [ XPathExpr, [ XPathExpr, TOK_OR, XPathExpr ], -1,
+     makeBinaryExpr ],
+   [ XPathExpr, [ XPathExpr, TOK_AND, XPathExpr ], -1,
+     makeBinaryExpr ],
+
+   [ XPathExpr, [ XPathExpr, TOK_EQ, XPathExpr ], -1,
+     makeBinaryExpr ],
+   [ XPathExpr, [ XPathExpr, TOK_NEQ, XPathExpr ], -1,
+     makeBinaryExpr ],
+
+   [ XPathExpr, [ XPathExpr, TOK_LT, XPathExpr ], -1,
+     makeBinaryExpr ],
+   [ XPathExpr, [ XPathExpr, TOK_LE, XPathExpr ], -1,
+     makeBinaryExpr ],
+   [ XPathExpr, [ XPathExpr, TOK_GT, XPathExpr ], -1,
+     makeBinaryExpr ],
+   [ XPathExpr, [ XPathExpr, TOK_GE, XPathExpr ], -1,
+     makeBinaryExpr ],
+
+   [ XPathExpr, [ XPathExpr, TOK_PLUS, XPathExpr ], -1,
+     makeBinaryExpr, ASSOC_LEFT ],
+   [ XPathExpr, [ XPathExpr, TOK_MINUS, XPathExpr ], -1,
+     makeBinaryExpr, ASSOC_LEFT ],
+
+   [ XPathExpr, [ XPathExpr, TOK_ASTERISK, XPathExpr ], -1,
+     makeBinaryExpr, ASSOC_LEFT ],
+   [ XPathExpr, [ XPathExpr, TOK_DIV, XPathExpr ], -1,
+     makeBinaryExpr, ASSOC_LEFT ],
+   [ XPathExpr, [ XPathExpr, TOK_MOD, XPathExpr ], -1,
+     makeBinaryExpr, ASSOC_LEFT ],
+
+   [ XPathLiteral, [ TOK_LITERALQ ], -1,
+     makeLiteralExpr ],
+   [ XPathLiteral, [ TOK_LITERALQQ ], -1,
+     makeLiteralExpr ],
+
+   [ XPathNumber, [ TOK_NUMBER ], -1,
+     makeNumberExpr ],
+
+   [ XPathVariableReference, [ TOK_DOLLAR, TOK_QNAME ], 200,
+     makeVariableReference ]
+   ];
+
+// That function computes some optimizations of the above data
+// structures and will be called right here. It merely takes the
+// counter variables out of the global scope.
+
+var xpathRules = [];
+
+function xpathParseInit() {
+  if (xpathRules.length) {
+    return;
+  }
+
+  // Some simple optimizations for the xpath expression parser: sort
+  // grammar rules descending by length, so that the longest match is
+  // first found.
+
+  xpathGrammarRules.sort(function(a,b) {
+    var la = a[1].length;
+    var lb = b[1].length;
+    if (la &lt; lb) {
+      return 1;
+    } else if (la &gt; lb) {
+      return -1;
+    } else {
+      return 0;
+    }
+  });
+
+  var k = 1;
+  for (var i = 0; i &lt; xpathNonTerminals.length; ++i) {
+    xpathNonTerminals[i].key = k++;
+  }
+
+  for (i = 0; i &lt; xpathTokenRules.length; ++i) {
+    xpathTokenRules[i].key = k++;
+  }
+
+  if (xpathdebug)
+  Log.write('XPath parse INIT: ' + k + ' rules');
+
+  // Another slight optimization: sort the rules into bins according
+  // to the last element (observing quantifiers), so we can restrict
+  // the match against the stack to the subest of rules that match the
+  // top of the stack.
+  //
+  // TODO(mesch): What we actually want is to compute states as in
+  // bison, so that we don't have to do any explicit and iterated
+  // match against the stack.
+
+  function push_(array, position, element) {
+    if (!array[position]) {
+      array[position] = [];
+    }
+    array[position].push(element);
+  }
+
+  for (i = 0; i &lt; xpathGrammarRules.length; ++i) {
+    var rule = xpathGrammarRules[i];
+    var pattern = rule[1];
+
+    for (var j = pattern.length - 1; j &gt;= 0; --j) {
+      if (pattern[j] == Q_1M) {
+        push_(xpathRules, pattern[j-1].key, rule);
+        break;
+        
+      } else if (pattern[j] == Q_MM || pattern[j] == Q_01) {
+        push_(xpathRules, pattern[j-1].key, rule);
+        --j;
+
+      } else {
+        push_(xpathRules, pattern[j].key, rule);
+        break;
+      }
+    }
+  }
+
+  if (xpathdebug)
+  Log.write('XPath parse INIT: ' + xpathRules.length + ' rule bins');
+  
+  var sum = 0;
+  mapExec(xpathRules, function(i) {
+    if (i) {
+      sum += i.length;
+    }
+  });
+  
+  if (xpathdebug)
+  Log.write('XPath parse INIT: ' + (sum / xpathRules.length) + ' average bin size');
+}
+
+// Local utility functions that are used by the lexer or parser.
+
+function xpathCollectDescendants(nodelist, node) {
+  for (var n = node.firstChild; n; n = n.nextSibling) {
+    nodelist.push(n);
+    arguments.callee(nodelist, n);
+  }
+}
+
+function xpathCollectDescendantsReverse(nodelist, node) {
+  for (var n = node.lastChild; n; n = n.previousSibling) {
+    nodelist.push(n);
+    arguments.callee(nodelist, n);
+  }
+}
+
+
+// The entry point for the library: match an expression against a DOM
+// node. Returns an XPath value.
+function xpathDomEval(expr, node) {
+  var expr1 = xpathParse(expr);
+  var ret = expr1.evaluate(new ExprContext(node));
+  return ret;
+}
+
+// Utility function to sort a list of nodes. Used by xsltSort() and
+// nxslSelect().
+function xpathSort(input, sort) {
+  if (sort.length == 0) {
+    return;
+  }
+
+  var sortlist = [];
+
+  for (var i = 0; i &lt; input.nodelist.length; ++i) {
+    var node = input.nodelist[i];
+    var sortitem = { node: node, key: [] };
+    var context = input.clone(node, 0, [ node ]);
+    
+    for (var j = 0; j &lt; sort.length; ++j) {
+      var s = sort[j];
+      var value = s.expr.evaluate(context);
+
+      var evalue;
+      if (s.type == 'text') {
+        evalue = value.stringValue();
+      } else if (s.type == 'number') {
+        evalue = value.numberValue();
+      }
+      sortitem.key.push({ value: evalue, order: s.order });
+    }
+
+    // Make the sort stable by adding a lowest priority sort by
+    // id. This is very convenient and furthermore required by the
+    // spec ([XSLT] - Section 10 Sorting).
+    sortitem.key.push({ value: i, order: 'ascending' });
+
+    sortlist.push(sortitem);
+  }
+
+  sortlist.sort(xpathSortByKey);
+
+  var nodes = [];
+  for (var i = 0; i &lt; sortlist.length; ++i) {
+    nodes.push(sortlist[i].node);
+  }
+  input.nodelist = nodes;
+  input.setNode(nodes[0], 0);
+}
+
+
+// Sorts by all order criteria defined. According to the JavaScript
+// spec ([ECMA] Section 11.8.5), the compare operators compare strings
+// as strings and numbers as numbers.
+//
+// NOTE: In browsers which do not follow the spec, this breaks only in
+// the case that numbers should be sorted as strings, which is very
+// uncommon.
+
+function xpathSortByKey(v1, v2) {
+  // NOTE: Sort key vectors of different length never occur in
+  // xsltSort.
+
+  for (var i = 0; i &lt; v1.key.length; ++i) {
+    var o = v1.key[i].order == 'descending' ? -1 : 1;
+    if (v1.key[i].value &gt; v2.key[i].value) {
+      return +1 * o;
+    } else if (v1.key[i].value &lt; v2.key[i].value) {
+      return -1 * o;
+    }
+  }
+
+  return 0;
+}
+
+
+// Copyright (c) 2005, Google Inc.
+// All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//         
+//  * Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 
+//  * Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the
+//    distribution.
+// 
+//  * Neither the name of Google Inc. nor the names of its contributors
+//    may be used to endorse or promote products derived from this
+//    software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Miscellania that support the ajaxslt implementation.
+//
+// Author: Steffen Meschkat &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/ydframework-devel">mesch at google.com</A>&gt;
+//
+
+function el(i) {
+  return document.getElementById(i);
+}
+
+function px(x) {
+  return x + 'px';
+}
+
+// Split a string s at all occurrences of character c. This is like
+// the split() method of the string object, but IE omits empty
+// strings, which violates the invariant (s.split(x).join(x) == s).
+function stringSplit(s, c) {
+  var a = s.indexOf(c);
+  if (a == -1) {
+    return [ s ];
+  }
+  
+  var parts = [];
+  parts.push(s.substr(0,a));
+  while (a != -1) {
+    var a1 = s.indexOf(c, a + 1);
+    if (a1 != -1) {
+      parts.push(s.substr(a + 1, a1 - a - 1));
+    } else {
+      parts.push(s.substr(a + 1));
+    } 
+    a = a1;
+  }
+
+  return parts;
+}
+
+// Returns the text value if a node; for nodes without children this
+// is the nodeValue, for nodes with children this is the concatenation
+// of the value of all children.
+function xmlValue(node) {
+  if (!node) {
+    return '';
+  }
+
+  var ret = '';
+  if (node.nodeType == DOM_TEXT_NODE ||
+      node.nodeType == DOM_CDATA_SECTION_NODE ||
+      node.nodeType == DOM_ATTRIBUTE_NODE) {
+    ret += node.nodeValue;
+
+  } else if (node.nodeType == DOM_ELEMENT_NODE ||
+             node.nodeType == DOM_DOCUMENT_NODE ||
+             node.nodeType == DOM_DOCUMENT_FRAGMENT_NODE) {
+    for (var i = 0; i &lt; node.childNodes.length; ++i) {
+      ret += arguments.callee(node.childNodes[i]);
+    }
+  }
+  return ret;
+}
+
+// Returns the representation of a node as XML text.
+function xmlText(node) {
+  var ret = '';
+  if (node.nodeType == DOM_TEXT_NODE) {
+    ret += xmlEscapeText(node.nodeValue);
+    
+  } else if (node.nodeType == DOM_ELEMENT_NODE) {
+    ret += '&lt;' + node.nodeName;
+    for (var i = 0; i &lt; node.attributes.length; ++i) {
+      var a = node.attributes[i];
+      if (a &amp;&amp; a.nodeName &amp;&amp; a.nodeValue) {
+        ret += ' ' + a.nodeName;
+        ret += '=&quot;' + xmlEscapeAttr(a.nodeValue) + '&quot;';
+      }
+    }
+
+    if (node.childNodes.length == 0) {
+      ret += '/&gt;';
+
+    } else {
+      ret += '&gt;';
+      for (var i = 0; i &lt; node.childNodes.length; ++i) {
+        ret += arguments.callee(node.childNodes[i]);
+      }
+      ret += '&lt;/' + node.nodeName + '&gt;';
+    }
+    
+  } else if (node.nodeType == DOM_DOCUMENT_NODE || 
+             node.nodeType == DOM_DOCUMENT_FRAGMENT_NODE) {
+    for (var i = 0; i &lt; node.childNodes.length; ++i) {
+      ret += arguments.callee(node.childNodes[i]);
+    }
+  }
+  
+  return ret;
+}
+
+// Applies the given function to each element of the array.
+function mapExec(array, func) {
+  for (var i = 0; i &lt; array.length; ++i) {
+    func(array[i]);
+  }
+}
+
+// Returns an array that contains the return value of the given
+// function applied to every element of the input array.
+function mapExpr(array, func) {
+  var ret = [];
+  for (var i = 0; i &lt; array.length; ++i) {
+    ret.push(func(array[i]));
+  }
+  return ret;
+};
+
+// Reverses the given array in place.
+function reverseInplace(array) {
+  for (var i = 0; i &lt; array.length / 2; ++i) {
+    var h = array[i];
+    var ii = array.length - i - 1;
+    array[i] = array[ii];
+    array[ii] = h;
+  }
+}
+
+// Shallow-copies an array.
+function copyArray(dst, src) { 
+  for (var i = 0; i &lt; src.length; ++i) {
+    dst.push(src[i]);
+  }
+}
+
+function assert(b) {
+  if (!b) {
+    throw 'assertion failed';
+  }
+}
+
+// Based on
+// &lt;<A HREF="http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-1950641247">http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-1950641247</A>&gt;
+var DOM_ELEMENT_NODE = 1;
+var DOM_ATTRIBUTE_NODE = 2;
+var DOM_TEXT_NODE = 3;
+var DOM_CDATA_SECTION_NODE = 4;
+var DOM_ENTITY_REFERENCE_NODE = 5;
+var DOM_ENTITY_NODE = 6;
+var DOM_PROCESSING_INSTRUCTION_NODE = 7;
+var DOM_COMMENT_NODE = 8;
+var DOM_DOCUMENT_NODE = 9;
+var DOM_DOCUMENT_TYPE_NODE = 10;
+var DOM_DOCUMENT_FRAGMENT_NODE = 11;
+var DOM_NOTATION_NODE = 12;
+
+
+var xpathdebug = false; // trace xpath parsing
+var xsltdebug = false; // trace xslt processing
+
+
+// Escape XML special markup chracters: tag delimiter &lt; &gt; and entity
+// reference start delimiter &amp;. The escaped string can be used in XML
+// text portions (i.e. between tags).
+function xmlEscapeText(s) {
+  return s.replace(/&amp;/g, '&amp;').replace(/&lt;/g, '&lt;').replace(/&gt;/g, '&gt;');
+}
+
+// Escape XML special markup characters: tag delimiter &lt; &gt; entity
+// reference start delimiter &amp; and quotes &quot;. The escaped string can be
+// used in double quoted XML attribute value portions (i.e. in
+// attributes within start tags).
+function xmlEscapeAttr(s) {
+  return xmlEscapeText(s).replace(/\&quot;/g, '&quot;');
+}
+
+// Escape markup in XML text, but don't touch entity references. The
+// escaped string can be used as XML text (i.e. between tags).
+function xmlEscapeTags(s) {
+  return s.replace(/&lt;/g, '&lt;').replace(/&gt;/g, '&gt;');
+}
+
+// An implementation of the debug log. 
+
+var logging__ = true;
+
+function Log() {};
+
+Log.lines = [];
+
+Log.write = function(s) {
+  if (logging__) {
+    this.lines.push(xmlEscapeText(s));
+    this.show();
+  }
+};
+
+// Writes the given XML with every tag on a new line.
+Log.writeXML = function(xml) {
+  if (logging__) {
+    var s0 = xml.replace(/&lt;/g, '\n&lt;');
+    var s1 = xmlEscapeText(s0);
+    var s2 = s1.replace(/\s*\n(\s|\n)*/g, '&lt;br/&gt;');
+    this.lines.push(s2);
+    this.show();
+  }
+}
+
+// Writes without any escaping
+Log.writeRaw = function(s) {
+  if (logging__) {
+    this.lines.push(s);
+    this.show();
+  }
+}
+
+Log.clear = function() {
+  if (logging__) {
+    var l = this.div();
+    l.innerHTML = '';
+    this.lines = [];
+  }
+}
+
+Log.show = function() {
+  var l = this.div();
+  l.innerHTML += this.lines.join('&lt;br/&gt;') + '&lt;br/&gt;';
+  this.lines = [];
+  l.scrollTop = l.scrollHeight;
+}
+
+Log.div = function() {
+  var l = document.getElementById('log');
+  if (!l) {
+    l = document.createElement('div');
+    l.id = 'log';
+    l.style.position = 'absolute';
+    l.style.right = '5px';
+    l.style.top = '5px';
+    l.style.width = '250px';
+    l.style.height = '150px';
+    l.style.overflow = 'auto';
+    l.style.backgroundColor = '#f0f0f0';
+    l.style.border = '1px solid gray';
+    l.style.fontSize = '10px';
+    l.style.padding = '5px';
+    document.body.appendChild(l);
+  }
+  return l;
+}
+
+
+function Timer() {}
+Timer.start = function() {}
+Timer.end = function() {}

Modified: YDFramework2.0/trunk/examples/index.tpl
===================================================================
--- YDFramework2.0/trunk/examples/index.tpl	2007-01-03 12:50:04 UTC (rev 2294)
+++ YDFramework2.0/trunk/examples/index.tpl	2007-01-03 12:51:22 UTC (rev 2295)
@@ -732,7 +732,7 @@
             &lt;td width=&quot;43%&quot;&gt;&lt;b&gt;&nbsp;&lt;/b&gt;&lt;/td&gt;
         &lt;/tr&gt;
         &lt;tr&gt;
-            &lt;td rowspan=&quot;16&quot; valign=&quot;top&quot;&gt;&nbsp;&lt;/td&gt;
+            &lt;td rowspan=&quot;17&quot; valign=&quot;top&quot;&gt;&nbsp;&lt;/td&gt;
             &lt;td valign=&quot;top&quot;&gt;&lt;a href=&quot;constants.php&quot;&gt;YDFramework2 constants&lt;/a&gt; &lt;/td&gt;
             &lt;td valign=&quot;top&quot;&gt;
                 &lt;a href=&quot;{$YD_SELF_SCRIPT}?do=source&amp;id=constants.php&quot;&gt;constants.php&lt;/a&gt;
@@ -804,6 +804,13 @@
             &lt;td valign=&quot;top&quot;&gt;
                 &lt;a href=&quot;{$YD_SELF_SCRIPT}?do=source&amp;id=akismet.php&quot;&gt;akismet.php&lt;/a&gt;            &lt;/td&gt;
         &lt;/tr&gt;
+        &lt;tr&gt;
+            &lt;td valign=&quot;top&quot;&gt;&lt;a href=&quot;adobe_spry/index.php&quot;&gt;Using Adobe Spry&lt;/a&gt;&lt;/td&gt;
+            &lt;td valign=&quot;top&quot;&gt;
+                &lt;a href=&quot;{$YD_SELF_SCRIPT}?do=source&amp;id=adobe_spry/index.php&quot;&gt;adobe_spry/index.php&lt;/a&gt;
+                &lt;a href=&quot;{$YD_SELF_SCRIPT}?do=source&amp;id=adobe_spry/index.tpl&quot;&gt;adobe_spry/index.tpl&lt;/a&gt;
+            &lt;/td&gt;
+        &lt;/tr&gt;
         &lt;/table&gt;
 
     {/if}


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000886.html">[ydf-devel] r2294 - YDFramework2.0/trunk/YDFramework2/YDClasses
</A></li>
	<LI>Next message: <A HREF="000888.html">[ydf-devel] r2296 - in YDFramework2.0/trunk/YDFramework2: .	YDClasses YDClasses/YDDatabaseDrivers
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#887">[ date ]</a>
              <a href="thread.html#887">[ thread ]</a>
              <a href="subject.html#887">[ subject ]</a>
              <a href="author.html#887">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/ydframework-devel">More information about the YDFramework-devel
mailing list</a><br>
</body></html>
