From ximian at mail.berlios.de  Tue Mar  6 00:54:36 2007
From: ximian at mail.berlios.de (ximian at mail.berlios.de)
Date: Tue, 6 Mar 2007 00:54:36 +0100
Subject: [ydf-devel] r2412 - YDFramework2.0/trunk/YDFramework2/YDClasses
Message-ID: <200703052354.l25NsaLJ027995@sheep.berlios.de>

Author: ximian
Date: 2007-03-06 00:54:09 +0100 (Tue, 06 Mar 2007)
New Revision: 2412

Modified:
   YDFramework2.0/trunk/YDFramework2/YDClasses/YDFileSystem.php
Log:
on YDFileSystem
  - feature: support for recursive max levels in YDFSDirectory::getFilesRecursively()

Modified: YDFramework2.0/trunk/YDFramework2/YDClasses/YDFileSystem.php
===================================================================
--- YDFramework2.0/trunk/YDFramework2/YDClasses/YDFileSystem.php	2007-02-27 23:07:13 UTC (rev 2411)
+++ YDFramework2.0/trunk/YDFramework2/YDClasses/YDFileSystem.php	2007-03-05 23:54:09 UTC (rev 2412)
@@ -1,1851 +1,1854 @@
-<?php
-
-    /*
-
-        Yellow Duck Framework version 2.1
-        (c) Copyright 2002-2007 Pieter Claerhout
-
-        This library is free software; you can redistribute it and/or
-        modify it under the terms of the GNU Lesser General Public
-        License as published by the Free Software Foundation; either
-        version 2.1 of the License, or (at your option) any later version.
-
-        This library is distributed in the hope that it will be useful,
-        but WITHOUT ANY WARRANTY; without even the implied warranty of
-        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
-        Lesser General Public License for more details.
-
-        You should have received a copy of the GNU Lesser General Public
-        License along with this library; if not, write to the Free Software
-        Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
-
-    */
-
-    /**
-     *  @addtogroup YDFramework Core
-     */
-
-    // Check if the framework is loaded
-    if ( ! defined( 'YD_FW_NAME' ) ) {
-        die( 'Yellow Duck Framework is not loaded.' );
-    }
-
-    // Includes
-    include_once( YD_DIR_HOME_CLS . '/YDUtil.php');
-    include_once( YD_DIR_HOME . '/3rdparty/bmp.php' );
-
-    // YDFSImage cropping specific constants
-    define( 'YD_FS_CROP_UNCHANGED', 1 );
-    define( 'YD_FS_CROP_ENLARGED',  2 );
-    define( 'YD_FS_CROP_BORDERED',  3 );
-
-    // Config when cropping smaller images
-    YDConfig::set( 'YD_FS_CROP', YD_FS_CROP_ENLARGED, false );
-
-    // The mime types mapping
-    $GLOBALS['YD_FS_MIME_MAPPING'] = array(
-        'ez' => 'application/andrew-inset',
-        'hqx' => 'application/mac-binhex40',
-        'cpt' => 'application/mac-compactpro',
-        'mathml' => 'application/mathml+xml',
-        'doc' => 'application/msword',
-        'oda' => 'application/oda',
-        'ogg' => 'application/ogg',
-        'pdf' => 'application/pdf',
-        'rdf' => 'application/rdf+xml',
-        'gram' => 'application/srgs',
-        'grxml' => 'application/srgs+xml',
-        'mif' => 'application/vnd.mif',
-        'xul' => 'application/vnd.mozilla.xul+xml',
-        'xls' => 'application/vnd.ms-excel',
-        'ppt' => 'application/vnd.ms-powerpoint',
-        'wbxml' => 'application/vnd.wap.wbxml',
-        'wmlc' => 'application/vnd.wap.wmlc',
-        'wmlsc' => 'application/vnd.wap.wmlscriptc',
-        'vxml' => 'application/voicexml+xml',
-        'bcpio' => 'application/x-bcpio',
-        'vcd' => 'application/x-cdlink',
-        'pgn' => 'application/x-chess-pgn',
-        'cpio' => 'application/x-cpio',
-        'csh' => 'application/x-csh',
-        'dvi' => 'application/x-dvi',
-        'spl' => 'application/x-futuresplash',
-        'gtar' => 'application/x-gtar',
-        'hdf' => 'application/x-hdf',
-        'js' => 'application/x-javascript',
-        'latex' => 'application/x-latex',
-        'sh' => 'application/x-sh',
-        'shar' => 'application/x-shar',
-        'swf' => 'application/x-shockwave-flash',
-        'sit' => 'application/x-stuffit',
-        'sv4cpio' => 'application/x-sv4cpio',
-        'sv4crc' => 'application/x-sv4crc',
-        'tar' => 'application/x-tar',
-        'tcl' => 'application/x-tcl',
-        'tex' => 'application/x-tex',
-        'man' => 'application/x-troff-man',
-        'me' => 'application/x-troff-me',
-        'ms' => 'application/x-troff-ms',
-        'ustar' => 'application/x-ustar',
-        'src' => 'application/x-wais-source',
-        'xslt' => 'application/xslt+xml',
-        'dtd' => 'application/xml-dtd',
-        'zip' => 'application/zip',
-        'm3u' => 'audio/x-mpegurl',
-        'rpm' => 'audio/x-pn-realaudio-plugin',
-        'ra' => 'audio/x-realaudio',
-        'wav' => 'audio/x-wav',
-        'pdb' => 'chemical/x-pdb',
-        'xyz' => 'chemical/x-xyz',
-        'bmp' => 'image/bmp',
-        'cgm' => 'image/cgm',
-        'gif' => 'image/gif',
-        'ief' => 'image/ief',
-        'png' => 'image/png',
-        'jpg' => 'image/jpeg',
-        'svg' => 'image/svg+xml',
-        'wbmp' => 'image/vnd.wap.wbmp',
-        'ras' => 'image/x-cmu-raster',
-        'ico' => 'image/x-icon',
-        'pnm' => 'image/x-portable-anymap',
-        'pbm' => 'image/x-portable-bitmap',
-        'pgm' => 'image/x-portable-graymap',
-        'ppm' => 'image/x-portable-pixmap',
-        'rgb' => 'image/x-rgb',
-        'xbm' => 'image/x-xbitmap',
-        'xpm' => 'image/x-xpixmap',
-        'xwd' => 'image/x-xwindowdump',
-        'css' => 'text/css',
-        'rtx' => 'text/richtext',
-        'rtf' => 'text/rtf',
-        'tsv' => 'text/tab-separated-values',
-        'wml' => 'text/vnd.wap.wml',
-        'wmls' => 'text/vnd.wap.wmlscript',
-        'etx' => 'text/x-setext',
-        'avi' => 'video/x-msvideo',
-        'movie' => 'video/x-sgi-movie',
-        'ice' => 'x-conference/x-cooltalk',
-        'php' => 'text/plain',
-    );
-
-    /**
-     *	This class houses all different path related functions.
-     *
-     *  @ingroup YDFramework
-     */
-    class YDPath extends YDBase {
-
-        /**
-         *	Provides a platform-specific character used to separate directory levels in a path string that reflects a
-         *	hierarchical file system organization.
-         *
-         *	@returns	String containing the directory separator
-         *
-         *	@static
-         */
-        function getDirectorySeparator() {
-            return ( YD_PATHDELIM == ':' ) ? '/' : '\\';
-        }
-
-        /**
-         *	A platform-specific separator character used to separate path strings in environment variables.
-         *
-         *	@returns	String containing the path separator
-         *
-         *	@static
-         */
-        function getPathSeparator() {
-            return YD_PATHDELIM;
-        }
-
-        /**
-         *	Provides a platform-specific volume separator character.
-         *
-         *	@returns	String containing the volume separator
-         *
-         *	@static
-         */
-        function getVolumeSeparator() {
-            if ( strtoupper( substr( PHP_OS, 0, 3 ) ) == 'WIN' || strtoupper( PHP_OS ) == 'DARWIN' ) {
-                return ':';
-            } else {
-                return '/';
-            }
-        }
-
-        /**
-         *	Changes the extension of a path string.
-         *
-         *	@param $path	Path of the file or directory.
-         *	@param $ext	The new extension.
-         *
-         *	@returns	String with the changed extension
-         *
-         *	@static
-         */
-        function changeExtension( $path, $ext ) {
-            if ( ! empty( $ext ) && substr( $ext, 0, 1 ) != '.' ) {
-                $ext = '.' . $ext;
-            }
-            return YDPath::getFilePathWithoutExtension( $path ) . $ext;
-        }
-
-        /**
-         *	@param $path	Path of the file or directory.
-         *
-         *	@returns	The directory information for the specified path string
-         *
-         *	@static
-         */
-        function getDirectoryName( $path ) {
-            return dirname( $path );
-        }
-
-        /**
-         *	@param $path	Path of the file or directory.
-         *
-         *	@param $format	(Optional) Boolean that defines if free space should be returned as bytes or formated
-         *
-         *	@param $decimals (Optional) Decimals to use when free space is formated
-         *
-         *	@returns	The number of bytes available on the specified path
-         *
-         *	@static
-         */
-        function getFreeSpace( $path, $format = false, $decimals = 1 ) {
-
-            // get free disk space on the path
-            $space = disk_free_space( $path );
-
-            // return number of bytes if we don't want to format
-            if ( $format == false ) return $space;
-
-            // include util lib
-            YDInclude( 'YDUtil.php' );
-
-            // return formated string
-            return YDStringUtil::formatFilesize( $space, $decimals );
-        }
-
-        /**
-         *	@param $path	Path of the file or directory.
-         *
-         *	@returns	The extension of the specified path string
-         *
-         *	@static
-         */
-        function getExtension( $path ) {
-            if ( strrchr( $path, '.' ) ) {
-                return substr( strrchr( $path, '.' ), 1 );
-            } else {
-                return '';
-            }
-        }
-
-        /**
-         *	@param $path	Path of the file or directory.
-         *
-         *	@returns	The file name and extension of the specified path string
-         *
-         *	@static
-         */
-        function getFileName( $path ) {
-            return basename( $path );
-        }
-
-        /**
-         *	@param $path	Path of the file or directory.
-         *
-         *	@returns	The file name of the specified path string without the extension
-         *
-         *	@static
-         */
-        function getFileNameWithoutExtension( $path ) {
-            return basename( $path, '.' . YDPath::getExtension( $path ) );
-        }
-
-        /**
-         *	@param $path	Path of the file or directory.
-         *
-         *	@returns	The file path and extension of the specified path string
-         *
-         *	@static
-         */
-        function getFilePath( $path ) {
-            return realpath( $path );
-        }
-
-        /**
-         *	@param $path	Path of the file or directory.
-         *
-         *	@returns	The file path of the specified path string without the extension
-         *
-         *	@static
-         */
-        function getFilePathWithoutExtension( $path ) {
-            return YDPath::getDirectoryName( $path ) . YDPath::getDirectorySeparator() . YDPath::getFileNameWithoutExtension( $path );
-        }
-
-        /**
-         *	@param $path	Path of the file or directory.
-         *
-         *	@returns	The absolute path for the specified path string
-         *
-         *	@static
-         */
-        function getFullPath( $path ) {
-            return realpath( $path );
-        }
-
-        /**
-         *	@returns	A uniquely named temporary file on disk and returns the full path to that file
-         *
-         *	@static
-         */
-        function getTempFileName() {
-            $tmpName = '';
-            for ($i=0;$i<rand(0,50);$i++) {
-                $tmpName .= "&#" . rand(33,255) . ";";
-            }
-            return YDPath::getTempPath() . YDPath::getDirectorySeparator() . md5( $tmpName ) . '.temp';
-        }
-
-        /**
-         *	@returns	The path of the current system's temporary folder.
-         *
-         *	@static
-         */
-        function getTempPath() {
-            return YD_DIR_TEMP;
-        }
-
-        /**
-         *	@param $path	Path of the file or directory.
-         *
-         *	@returns	Determines whether a path includes a file name extension
-         *
-         *	@static
-         */
-        function hasExtension( $path ) {
-            $ext = YDPath::getExtension( $path );
-            return empty( $ext ) ? false : true;
-        }
-
-        /**
-         *	This function will check if the path is an absolute path or not.
-         *
-         *	@param	$path	The path to check
-         *
-         *	@returns	Boolean indicating if the path is absolute or not.
-         *
-         *	@static
-         */
-        function isAbsolute( $path ) {
-            if ( strtoupper( substr( PHP_OS, 0, 3 ) ) == 'WIN' ) {
-                if ( strlen( $path ) > 3 && substr( $path, 1, 2 ) == ':\\' ) {
-                    return true;
-                } else {
-                    return false;
-                }
-            } else {
-                return ( substr( $path, 0, 1 ) == '/' );
-            }
-        }
-
-        /**
-         *	This function combines different file path elements to each other.
-         *
-         *	@code
-         *	join( 'C:\temp', 'subdir', 'file.html' )
-         *	@endcode
-         *
-         *	results in the following path:
-         *
-         *	@code
-         *	C:\temp\subdir\file.html
-         *	@endcode
-         *
-         *	@returns	The joined path.
-         *
-         *	@static
-         */
-        function join() {
-
-            // Get the arguments for this function
-            $args = func_get_args();
-
-            // Start with an empty path
-            $path = '';
-
-            // Loop over the different elements
-            foreach ( $args as $arg ) {
-
-                if ( ! strlen( $arg ) ) {
-                    continue;
-                }
-
-                // Normalize the path elements
-                $arg = str_replace( '/', YDPath::getDirectorySeparator(), $arg );
-                $arg = str_replace( '\\', YDPath::getDirectorySeparator(), $arg );
-
-                // Check for an absolute path
-                if ( YDPath::isAbsolute( $arg ) ) {
-                    $path = $arg;
-                } else {
-
-                    // Remove the trailing directory separator
-                    if ( substr( $arg, -1, 1 ) == YDPath::getDirectorySeparator() ) {
-                        $arg = substr( $arg, 0, -1 );
-                    }
-
-                    // Add it to the path
-                    if ( strlen( $path ) > 0 ) {
-                        if ( substr( $arg, 0, 1 ) != YDPath::getDirectorySeparator() ) {
-                            $path .= YDPath::getDirectorySeparator() . $arg;
-                        } else {
-                            $path .= $arg;
-                        }
-                    } else {
-                        $path .= $arg;
-                    }
-
-                }
-
-            }
-
-            // Return the joined path
-            return $path;
-
-        }
-
-        /**
-         *	Function to determine if the file is an image or not. This function will read the header of the file to
-         *	find out if it's an image or not.
-         *
-         *	@returns	Boolean indicating if the file is an image or not.
-         */
-        function isImage( $path ) {
-
-            // Return false if path doesn't exist
-            if ( ! realpath( $path ) ) {
-                return false;
-            }
-
-            // Check if we have an extension
-            $extension = strtolower( YDPath::getExtension( $path ) );
-            if ( $extension && $extension != 'tmn' ) {
-                if ( in_array( $extension, array( 'jpg', 'png', 'gif', 'jpeg' ) ) ) {
-                    return $extension;
-                }
-            }
-
-            // No extension, read the file
-            $fp = fopen( $path, 'rb' );
-            $header = fread( $fp, 8 );
-            fclose( $fp );
-            if ( substr( $header, 0, 6 ) == 'GIF87a' || substr( $header, 0, 6 ) == 'GIF89a' ) {
-                return 'gif';
-            }
-            if ( substr( $header, 6, 4 ) == 'JFIF' ) {
-                return 'jpeg';
-            }
-            if ( substr( $header, 0, 8 ) == "\211PNG\r\n\032\n" ) {
-                return 'png';
-            }
-            if ( substr( $header, 0, 2 ) == "BM" ) {
-                return 'bmp';
-            }
-
-            // Not an image
-            return false;
-
-        }
-
-    }
-
-    /**
-     *  This class defines a filesystem file.
-     *
-     *  @ingroup YDFramework
-     */
-    class YDFSFile extends YDBase {
-
-        /**
-         *  The class constructor of the YDFSFile class takes the path to the file as it's first argument.
-         *  It will then provide you with a number of functions to get the properties of the file.
-         *
-         *  @param $path    Path of the file.
-         *  @param $create  (optional) Force the creation of the file if it doesn't exist. Default: false.
-         */
-        function YDFSFile( $path, $create=false ) {
-
-            // Initialize YDBase
-            $this->YDBase();
-
-            // Check if the path if the file exists
-            if ( ! is_file( $path ) ) {
-
-                // Check if the file should be created
-                if ( $create ) {
-
-                    // Create a new YDFSDirectory object
-                    $dir = new YDFSDirectory( dirname( $path ) );
-
-                    // Create the file
-                    $dir->createFile( basename( $path ), ' ' );
-
-                } else {
-                    trigger_error( 'The file with path "' . $path . '" does not exist.', YD_ERROR );
-                }
-            }
-
-            // Save the path
-            $this->_path = realpath( $path );
-
-        }
-
-        /**
-         *	Function to get the filename of the object. This does not include the path information.
-         *
-         *	@returns	String containing the name of the object.
-         */
-        function getBasename() {
-            return YDPath::getFileName( $this->getAbsolutePath() );
-        }
-
-        /**
-         *	Function to get the filename of the object without the extension. This does not include the path information.
-         *
-         *	@returns	String containing the name of the object.
-         */
-        function getBasenameNoExt() {
-            return substr( YDPath::getFilePathWithoutExtension( $this->getBasename() ), 2 );
-        }
-
-        /**
-         *	Function to get the extension of the file.
-         *
-         *	@returns	String containing the extension of the file.
-         */
-        function getExtension() {
-            return YDPath::getExtension( $this->getAbsolutePath() );
-        }
-
-        /**
-         *	Function to get the full path of the object.
-         *
-         *	@returns	String containing the full path of the object.
-         */
-        function getPath() {
-            return YDPath::getDirectoryName( $this->getAbsolutePath() );
-        }
-
-        /**
-         *	Function to get the full absolute path of the object.
-         *
-         *	@returns	String containing the full absolute path of the object.
-         */
-        function getAbsolutePath() {
-            return YDPath::getFullPath( $this->_path );
-        }
-
-        /**
-         *	Function to get the last modification date of the object.
-         *
-         *  @param  $format (optional) The date format to use to format the date.
-         *  @param  $locale (optional) The locale to use for formatting the date.
-         *
-         *	@returns	String containing the last modification date of the object.
-         */
-        function getLastModified( $format = 'timestamp', $locale=null ) {
-            if ( $format == 'timestamp' ) {
-                return filemtime( $this->getAbsolutePath() );
-            }
-            return YDStringUtil::formatDate( filemtime( $this->getAbsolutePath() ), $format, $locale );
-        }
-
-        /**
-         *	Function to get the size of the file.
-         *
-         *  @param  $formatted  (optional) If set to true, the filesize will be returned in a human readable format.
-         *  @param  $decimals   (optional) The number of decimals to use for formatting the filesize.
-         *
-         *	@returns	Double containing the length of the file.
-         */
-        function getSize( $formatted = false, $decimals = 1 ) {
-            if ( ! $formatted ) {
-                return filesize( $this->getAbsolutePath() );
-            }
-            return YDStringUtil::formatFilesize( filesize( $this->getAbsolutePath() ), $decimals );
-        }
-
-        /**
-         *  Returns the total free space on the partition where this file lives
-         *
-         *	@param $format	 (Optional) Boolean that defines if free space should be returned as bytes or formated
-         *	@param $decimals (Optional) Decimals to use when free space is formated
-         *
-         *	@returns	The number of bytes available
-         *
-         *	@static
-         */
-        function getFreeSpace( $format = false, $decimals = 1 ) {
-            return YDPath::getFreeSpace( $this->_path, $format, $decimals );
-        }
-
-        /**
-         *	Function to get the contents of the file. Depending on the file contents, this will be returned as binary or
-         *	textual data.
-         *
-         *	@param $start	(optional) Byte to start reading from.
-         *	@param $length	(optional) Number of bytes to read.
-         *
-         *	@returns	String containing the contents of the file.
-         */
-        function getContents( $start=null, $length=null ) {
-
-            // Clear the stat cache
-            clearstatcache();
-
-            // Check the start byte
-            if ( $start == null ) {
-                $start = 0;
-            }
-
-            // No length given
-            if ( $length == null ) {
-                $length = filesize( $this->getAbsolutePath() ) - $start;
-            }
-
-            // Check that length is a positive integer
-            if ( $length < 1 ) {
-                trigger_error( 'getContents: Length should be a positive integer.', YD_ERROR );
-            }
-
-            // Variable to hold the return data
-            $result = '';
-
-            // Open the file in read binary mode
-            $file = fopen( $this->getAbsolutePath(), 'rb' );
-
-            // Check if we were able to open the file
-            if ( $file == false ) {
-                trigger_error( 'The file with path "' . $path . '" could not be read.', YD_ERROR );
-            }
-
-            // Find the start position
-            fseek( $file, $start );
-
-            // Get the contents of the file
-            $result = fread( $file, $length );
-
-            // Close the file handle
-            fclose( $file );
-
-            // Return the result
-            return $result;
-
-        }
-
-        /**
-         *	This function will create a new file in the current directory, and will write the specified contents to the
-         *	file. Once finished, it will return a new YDFSFile object pointing to the file. All directory paths are
-         *	relative to the current directory.
-         *
-         *	@param $contents	The contents of the new file.
-         *	@param $append		Boolean indicating if the content should be appended to the file or if the file contents
-         *						should be replaced.
-         */
-        function setContents( $contents, $append=false ) {
-
-            // Set the mode
-            $mode = ( $append === true ) ? 'ab' : 'wb';
-
-            // Open the file
-            $fp = fopen( $this->getAbsolutePath(), $mode );
-
-            // Save the contents to the file
-            $result = fwrite( $fp, $contents );
-
-            // Check for errors
-            if ( $result == false ) {
-                trigger_error(
-                    'Failed writing to the file "' . $this->getAbsolutePath() . '" in the directory called "' . $this->getPath() . '".',
-                    YD_ERROR
-                );
-            }
-
-            // Close the file
-            fclose( $fp );
-
-            // Clear the stat cache
-            clearstatcache();
-
-        }
-
-        /**
-         *	Function to determine if the file is an image or not. This function will read the header of the file to
-         *	find out if it's an image or not.
-         *
-         *	@returns	Boolean indicating if the file is an image or not.
-         */
-        function isImage() {
-            return YDPath::isImage( $this->getAbsolutePath() );
-        }
-
-        /**
-         *  This function returns true if the file is readable.
-         *
-         *  @returns    Returns true if the file is readable.
-         */
-        function isReadable(){
-            return is_readable( $this->getAbsolutePath() );
-        }
-
-        /**
-         *	This function will return true if the directory is writeable, otherwise, it will return false.
-         *
-         *	@remarks
-         *		This only works correctly on Unix based systems.
-         *
-         *	@returns	Boolean indicating if the directory is writeable or not.
-         */
-        function isWriteable() {
-            return is_writable( $this->getAbsolutePath() );
-        }
-
-        /**
-         *	This function will force the browser to download the file.
-         *
-         *	@param $name	(optional) The name of the file download should show in the browser. By default, this is the
-         *					same as the filename.
-         *  @param $inline  (optional) If set to true, the download is inline, otherwise, a download will be forced by
-         *                  the browser. Default is false.
-         */
-        function download( $name=null, $inline=false ) {
-
-            // Get the name of the file
-            if ( is_null( $name ) ) {
-                $name = $this->getBasename();
-            }
-
-            // Force download or do inline
-            if ( ! $inline ) {
-                header( 'Content-Type: application/force-download; name="' . $name . '"');
-                header( 'Content-Disposition: attachment; filename="' . $name . ' "');
-            } else {
-                header( 'Content-Type: ' . $this->getMimeType() );
-                header( 'Content-Disposition: inline; filename="' . $name . ' "');
-            }
-
-            // Add the rest of the headers
-            header( 'Cache-Control: public' );
-            header( 'Content-Transfer-Encoding: binary' );
-            header( 'Content-length: ' . $this->getSize() );
-
-            // Send the file contents
-            readfile( $this->getAbsolutePath() );
-
-            // Stop the execution
-            die();
-
-        }
-
-        /**
-         *	This function will delete a file from the current directory.
-         *
-         *	@param $failOnError	(optional) Indicate if a fatal error needs to be raised if deleting the file failed.
-         *
-         *	@return	There are three possible return values for this function. True indicates that the file exists and
-         *			is deleted successfully. False indicates the file exists but could not be deleted. Null indicates
-         *			the file didn't exist and therefor could not be deleted.
-         */
-        function delete( $failOnError=false ) {
-
-            // Set the filename
-            $filename = $this->getAbsolutePath();
-
-            // Set the directory of this object as the working directory
-            chdir( $this->getPath() );
-
-            // Check if the file exists
-            if ( file_exists( $filename ) ) {
-
-                // Try to delete the file
-                $result = unlink( $filename );
-
-                // Check for errors
-                if ( $result == false ) {
-
-                    // Check if we need to raise an error
-                    if ( $failOnError == true ) {
-                        trigger_error(
-                            'Failed deleting the file "' . $filename . '" from the directory "' . $this->getPath() . '".',
-                            YD_ERROR
-                        );
-                    }
-
-                }
-
-                // Return if the file was deleted or not
-                return $result;
-
-            }
-
-            // Return null if the file doesn't exist
-            return null;
-
-        }
-
-        /**
-         *  This function will rename the file to the specified file path.
-         *
-         *  @param  $new_path   The new path of the file.
-         *
-         *  @returns    True on success, false on failure.
-         */
-        function rename( $new_path ) {
-            @unlink( $new_path );
-            $result = rename( $this->getAbsolutePath(), $new_path );
-            if ( $result === true ) {
-                $this->_path = realpath( $new_path );
-            }
-            return $result;
-        }
-
-        /**
-         *	This function will return true if the filesystem object is a directory. In all other cases, it will return
-         *	false.
-         *
-         *	@returns	Boolean indicating if the object is a directory or not.
-         */
-        function isDirectory() {
-            return false;
-        }
-
-        /**
-         *  This function returns the mime type for the file object.
-         *
-         *  @returns    The mime type for the document. If the mime type is not known, it will use the
-         *              application/octet-stream mime type.
-         */
-        function getMimeType() {
-            $extension = strtolower( $this->getExtension() );
-            if ( isset( $GLOBALS['YD_FS_MIME_MAPPING'][$extension] ) ) {
-                return $GLOBALS['YD_FS_MIME_MAPPING'][$extension];
-            } else {
-                return 'application/octet-stream';
-            }
-        }
-
-        /**
-         *	@internal
-         */
-        function _getImageType() {
-            return YDPath::isImage( $this->getAbsolutePath() );
-        }
-
-        /**
-         *	This function will move the file to the specified path and update the object accordingly.
-         *
-         *	@param	$path	Target path.
-         *
-         *	@returns	False on a failure, true on success.
-         */
-        function move( $path ) {
-            $result = rename( $this->getAbsolutePath(), $path );
-            if ( $result ) {
-                $this->_path = realpath( $path );
-            }
-            return $result;
-        }
-
-    }
-
-    /**
-     *	This class defines an image file.
-     *
-     *  @ingroup YDFramework
-     */
-    class YDFSImage extends YDFSFile {
-
-        /**
-         *	The class constructor of the YDImage class takes the path to the image as it's only argument. It will then
-         *	provide you with a number of functions to get the properties of the image and also provides some actions
-         *	like generating thumbnails.
-         *
-         *	@param $path	Path of the image.
-         *  @param $create  (optional) Force the creation of the file if it doesn't exist. Default: false.
-         */
-        function YDFSImage( $path, $create=false ) {
-
-            // Initialize the parent
-            $this->YDFSFile( $path, $create );
-
-            // Get the image size
-            $this->image_size = null;
-
-        }
-
-        /**
-         *  Function determine the image size. This is just a helper function for the other ones.
-         *
-         *  @internal
-         */
-        function _initImageSize() {
-
-            // Check for the getimagesize function
-            if ( ! function_exists( 'getimagesize' ) ) {
-                trigger_error(
-                    'The "getimagesize" function does not exists. Make sure that the GD libraries are loaded before '
-                    . 'using the YDFSImage::getImageSize function.', YD_ERROR
-                );
-            }
-
-            if ( is_null( $this->image_size ) ) {
-                $this->image_size = getimagesize( $this->getAbsolutePath() );
-            }
-       }
-
-        /**
-         *	Function to output the thumbnail of an image. The function directly outputs the thumbnail to the client
-         *	including the right headers needed to display the image.
-         *
-         *	This function can cache the thumbnails and regenerate them on the fly if needed. The cached thumbnails are
-         *	stored in the temp directory of the Yellow Duck framework and have the extension "tmn". You can delete these
-         *	automatically as they will be recreated on the fly if needed.
-         *
-         *	@param $width	The maximum width of the thumbnail.
-         *	@param $height	The maximum height of the thumbnail.
-         *	@param $cache	(optional) Indicate if the thumbnail should be cached. By default, caching is turned on.
-         *	@param $crop	(optional) Indicate if the thumbnail should be cropped to the exact size. By default, false.
-         */
-        function outputThumbnail( $width, $height, $cache=true, $crop=false ) {
-
-            // Output right headers
-            $content_type = $this->getMimeType();
-            header( 'Content-type: ' . $content_type );
-
-            // Output the thumbnail
-            die( $this->_createThumbnail( $width, $height, $cache, $crop ) );
-
-        }
-
-        /**
-         *	This function will create a thumbnail and save the thumbnail to disk.
-         *
-         *	@param $width	The maximum width of the thumbnail.
-         *	@param $height	The maximum height of the thumbnail.
-         *	@param $file	The filename to save the thumbnail to.
-         *	@param $crop	(optional) Indicate if the thumbnail should be cropped to the exact size. By default, false.
-         *
-         *  @returns    A new YDFSImage object for the thumbnail.
-         */
-        function saveThumbnail( $width, $height, $file, $crop=false ) {
-
-            // Create the thumbnail
-            $thumb = $this->_createThumbnail( $width, $height, false, $crop );
-
-            // Save it to a file
-            $f = new YDFSImage( $file, true );
-            $f->setContents( $thumb );
-
-            // Return the thumbnail
-            return $f;
-
-        }
-
-        /**
-         *	This function will return the size of the image in pixels.
-         *
-         *	@returns	The imagesize in pixels. This is returned as an array of which the first element is the width,
-         *				the second element is the height in pixels.
-         */
-        function getImageSize() {
-
-            // Init image_size
-            $this->_initImageSize();
-
-            // Get the first two elements
-            $imgSize = array_slice( $this->image_size, 0, 2 );
-
-            // Return the image size
-            return $imgSize;
-
-        }
-
-        /**
-         *	This function will return the width of the image in pixels.
-         *
-         *	@returns	The width in pixels.
-         */
-        function getWidth() {
-            $this->_initImageSize();
-            return $this->image_size[0];
-        }
-
-        /**
-         *	This function will return the height of the image in pixels.
-         *
-         *	@returns	The height in pixels.
-         */
-        function getHeight() {
-            $this->_initImageSize();
-            return $this->image_size[1];
-        }
-
-        /**
-         *	Function that returns the type of the image. Currently, it supports GIF, JPG and PNG.
-         *
-         *	@returns	The type of the image, which is either jpg, png or gif.
-         */
-        function getImageType() {
-
-            // Get the image type
-            $type = $this->_getImageType();
-
-            // Raise error about unsupported image type
-            if ( $type === false ) {
-                trigger_error(
-                    'The getImageType function does not support the file format of the file "'
-                    . $this->getAbsolutePath() . '".', YD_ERROR
-                );
-            } else {
-                return $type;
-            }
-
-         }
-
-        /**
-         *	This function is used to output an error image.
-         *
-         *	@param $name	(optional) Name of the error image. Default image that is shown is the generic
-         *					"YD_ydfsimage_fatal_error".
-         *
-         *	@internal
-         */
-        function _error( $name='YD_ydfsimage_fatal_error' ) {
-            $img = new YDFSImage( YD_DIR_HOME . '/images/' . $name . '.gif' );
-            header( 'Content-type: ' . $img->getMimeType() );
-            echo( $img->getContents() );
-            die();
-        }
-
-        /**
-         *	This function will do the actual work of creating a thumbnail image.
-         *
-         *	@param $width	The maximum width of the thumbnail.
-         *	@param $height	The maximum height of the thumbnail.
-         *	@param $cache	(optional) Indicate if the thumbnails should be cached. By default, caching is turned off.
-         *	@param $crop	(optional) Indicate if the thumbnails should be cropped to the exact size. By default, false.
-         *
-         *	@internal
-         */
-        function & _createThumbnail( $width, $height, $cache=true, $crop=false ) {
-
-            // Check if the GD library is loaded.
-            if ( ! extension_loaded( 'gd' ) ) {
-                $this->_error( 'YD_gd_not_installed' );
-            }
-
-            // Width and height should be positive integer
-            if ( $width < 1 || $height < 1 ) {
-                $this->_error();
-            }
-
-            // Get the cache filename
-            $cacheFName = YD_DIR_TEMP . '/' . $this->_createThumbnailName( $width, $height, $crop );
-
-            // Check if caching is enabled
-            if ( $cache === true ) {
-
-                // Output the cached version if any
-                if ( is_file( $cacheFName ) ) {
-                    readfile( $cacheFName );
-                    die();
-                }
-
-            }
-
-            // Check the extension
-            $img_type = $this->isImage();
-
-            // Open the source image
-            if ( $img_type == 'gif' ) {
-                if ( ! function_exists( 'imagecreatefromgif' ) ) {
-                    $this->_error();
-                }
-                $src_img = imagecreatefromgif( $this->getAbsolutePath() );
-            } elseif ( $img_type == 'png' ) {
-                $src_img = imagecreatefrompng( $this->getAbsolutePath() );
-            } elseif ( $img_type == 'bmp' ) {
-                $src_img = imagecreatefrombmp( $this->getAbsolutePath() );
-            } else {
-                $src_img = imagecreatefromjpeg( $this->getAbsolutePath() );
-            }
-
-            // Get the current image size
-            $ori_width  = imageSX( $src_img );
-            $ori_height = imageSY( $src_img );
-
-            // Calculate the new image size
-            if ( $crop ) {
-
-                if ( $ori_width > $ori_height ) {
-                    $thumb_w = ceil( $ori_width * ( $height / $ori_height ) );
-                    $thumb_h = $height;
-                }
-                if ( $ori_width < $ori_height ) {
-                    $thumb_w = $width;
-                    $thumb_h = ceil( $ori_height * ( $width / $ori_width ) );
-                }
-
-            } else {
-
-                if ( $ori_width > $ori_height ) {
-                    $thumb_w = $width;
-                    $thumb_h = ceil( $ori_height * ( $width / $ori_width ) );
-                }
-                if ( $ori_width < $ori_height ) {
-                    $thumb_w = ceil( $ori_width * ( $height / $ori_height ) );
-                    $thumb_h = $height;
-                }
-
-            }
-
-            if ( $ori_width == $ori_height ) {
-                $thumb_w = $width;
-                $thumb_h = $height;
-            }
-
-            if ( ( $width >= $ori_width || $height >= $ori_height ) && ( ! $crop || ( $crop && YDConfig::get( 'YD_FS_CROP' ) != YD_FS_CROP_ENLARGED ) ) ) {
-
-                if ( $width >= $ori_width && $height < $ori_height ) {
-                    $thumb_w = ceil( $ori_width * ( $height / $ori_height ) );
-                    $thumb_h = $height;
-                } else if ( $width < $ori_width && $height >= $ori_height ) {
-                    $thumb_w = $width;
-                    $thumb_h = ceil( $ori_height * ( $width / $ori_width ) );
-                } else {
-                    $thumb_w = $ori_width;
-                    $thumb_h = $ori_height;
-                }
-
-            }
-
-            // Resample the image
-            $dst_img = imagecreatetruecolor( $thumb_w, $thumb_h );
-            if ( $img_type == 'png' ) {
-                imagecopyresized( $dst_img, $src_img, 0, 0, 0, 0, $thumb_w, $thumb_h, $ori_width, $ori_height );
-            } else {
-                imagecopyresampled( $dst_img, $src_img, 0, 0, 0, 0, $thumb_w, $thumb_h, $ori_width, $ori_height );
-            }
-
-            if ( $crop && ( $width != $thumb_w || $height != $thumb_h ) ) {
-
-                $x = ceil( abs( $thumb_w-$width  ) / 2 );
-                $y = ceil( abs( $thumb_h-$height ) / 2 );
-
-                $default = true;
-
-                if ( $ori_width < $width || $ori_height < $height ) {
-
-                    switch ( YDConfig::get( 'YD_FS_CROP', YD_FS_CROP_ENLARGED ) ) {
-
-                        case YD_FS_CROP_UNCHANGED:
-
-                            if ( $ori_width < $width && $ori_height < $height ) {
-                                $crp_img = $dst_img;
-                                $default = false;
-                            } else if ( $ori_width < $width ) {
-                                $x = 0;
-                                $width = $ori_width;
-                            } else if ( $ori_height < $height ) {
-                                $y = 0;
-                                $height = $ori_height;
-                            }
-                            break;
-
-                        case YD_FS_CROP_ENLARGED:
-                        case YD_FS_CROP_BORDERED:
-                            break;
-
-                    }
-
-                }
-
-                if ( $default ) {
-
-                    $crp_img = imagecreatetruecolor( $width, $height );
-
-                    if ( $img_type == 'png' ) {
-                        imagecopyresized( $crp_img, $dst_img, 0, 0, $x, $y, $width, $height, $width, $height );
-                    } else {
-                        imagecopyresampled( $crp_img, $dst_img, 0, 0, $x, $y, $width, $height, $width, $height );
-                    }
-
-                }
-
-                $dst_img = $crp_img;
-
-            }
-
-            // Get the resulting image
-            ob_start();
-            if ( $img_type == 'gif' ) {
-                if ( ! function_exists( 'imagegif' ) ) {
-                    imagepng( $dst_img );
-                } else {
-                    imagegif( $dst_img );
-                }
-            } elseif ( $img_type == 'png' ) {
-                imagepng( $dst_img );
-            } else {
-                imagejpeg( $dst_img );
-            }
-            $image_data = ob_get_contents();
-            ob_end_clean();
-
-            // Destroy the images
-            imagedestroy( $dst_img );
-            imagedestroy( $src_img );
-
-            // Save the cache if needed
-            if ( $cache == true ) {
-                $f = new YDFSFile( $cacheFName, true );
-                $f->setContents( $image_data );
-            }
-
-            // Return the image data
-            return $image_data;
-
-        }
-
-        /**
-         *  This function creates the cache name for thumbnails.
-         *
-         *	@param $width	The maximum width of the thumbnail.
-         *	@param $height	The maximum height of the thumbnail.
-         *	@param $crop	Indicate if is the cropped version.
-         */
-        function _createThumbnailName( $width, $height, $crop ) {
-            $cacheFName = $this->getAbsolutePath() . '/' . $width . '/' . $height . '/' . strval( $crop ) . $this->getLastModified();
-            $cacheFName = YD_TMP_PRE . 'N_' . md5( $cacheFName ) . '.' . strtolower( $this->getExtension() );
-            return $cacheFName;
-        }
-
-    }
-
-    /**
-     *  This class defines a filesystem directory.
-     *
-     *  @ingroup YDFramework
-     */
-    class YDFSDirectory extends YDBase {
-
-        /**
-         *	This is the class constructor of the YDDirectory class.
-         *
-         *	@param $path	(optional) Path of the directory. Default is the current directory.
-         */
-        function YDFSDirectory( $path='.' ) {
-
-            // Initialize YDBase
-            $this->YDBase();
-
-            // Fail if directory
-            if ( ! is_dir( $path ) ) {
-                trigger_error( 'The directory with path "' . $path . '" does not exist.', YD_ERROR );
-            }
-
-            // Save the path
-            $this->_path = realpath( $path );
-
-        }
-
-        /**
-         *	Function to get the basename of the directory. This does not include the path information.
-         *
-         *	@returns	String containing the name of the object.
-         */
-        function getBasename() {
-            return YDPath::getFileName( $this->getAbsolutePath() );
-        }
-
-        /**
-         *	Function to get the full absolute path of the object.
-         *
-         *	@returns	String containing the full absolute path of the object.
-         */
-        function getAbsolutePath() {
-            return $this->getPath();
-        }
-
-        /**
-         *  This function return the number of files that are in the directory.
-         *
-         *  @returns    The number of files in the directory.
-         */
-        function getFileCount(){
-            $total = 0;
-            $dirHandle = opendir( $this->getPath() );
-            while ( false !== ( $file = readdir( $dirHandle ) ) ) {
-                if ( $file != '.' && $file != '..' && is_file( $this->getPath() .'/'. $file ) ) {
-                   $total++;
-                }
-            }
-            closedir( $dirHandle );
-            return $total;
-        }
-
-        /**
-         *  This function return the number of directories that are in the directory.
-         *
-         *  @returns    The number of directories in the directory.
-         */
-        function getDirectoryCount(){
-            $total = 0;
-            $dirHandle = opendir( $this->getPath() );
-            while ( false !== ( $file = readdir( $dirHandle ) ) ) {
-            if ( $file != '.' && $file != '..' && is_dir( $this->getPath() .'/'. $file ) ) {
-                    $total++;
-                }
-            }
-            closedir( $dirHandle );
-            return $total;
-        }
-
-        /**
-         *  Returns the total size of the directory.
-         *
-         *  @param  $recursive  (optional) Recurse into the subdirectories. Default is false.
-         *  @param  $formatted  (optional) If set to true, the filesize will be returned in a human readable format.
-         *  @param  $decimals   (optional) The number of decimals to use for formatting the filesize.
-         *
-         *  @returns    The total size of the directory.
-         */
-        function getSize( $recursive = false, $formatted = false, $decimals = 1 ) {
-            $total = 0;
-            $dirHandle = opendir( $this->getPath() );
-            while ( false !== ( $file = readdir( $dirHandle ) ) ) {
-                if ( $file == '.' || $file == '..') {
-                    continue;
-                }
-                if ( is_file( $this->getPath() .'/'. $file ) ) {
-                    $total += filesize( $this->getPath() .'/'. $file );
-                } else if ( $recursive && is_dir( $this->getPath() .'/'. $file ) ) {
-                    $subdir = new YDFSDirectory( $this->getPath() .'/'. $file );
-                    $total += $subdir->getSize(true, false, $decimals);
-                }
-            }
-            closedir( $dirHandle );
-            if ( ! $formatted ) {
-                return $total;
-            }
-            return YDStringUtil::formatFilesize( $total, $decimals );
-        }
-
-        /**
-         *  Returns the total free space on the partition where this directory lives
-         *
-         *	@param $format	 (Optional) Boolean that defines if free space should be returned as bytes or formated
-         *	@param $decimals (Optional) Decimals to use when free space is formated
-         *
-         *	@returns	The number of bytes available
-         *
-         *	@static
-         */
-        function getFreeSpace( $format = false, $decimals = 1 ) {
-            return YDPath::getFreeSpace( $this->_path, $format, $decimals );
-        }
-
-        /**
-         *	This function will get a file list using a pattern. You can compare this function with the dir command from
-         *	DOS or the ls command from Unix. The pattern syntax is the same as well.
-         *
-         *	@remarks
-         *		This will not work recursively on the subdirectories.
-         *
-         *	@param $pattern	(optional) Pattern to which the files should match. If you want multiple items, you can also
-         *					pass them as an array. If the pattern is prefixed with an exclamation mark, the files that
-         *					match this pattern will not be included in the result.
-         *	@param $class	(optional) If you specify a not null value for this option, this function will return the
-         *					items in the directory as the indicated class. If an empty string is given, it will return
-         *					the list of filenames instead of objects. If a string 'fullpath' is given, it will return
-         *					the list of filenames using the fullpath. If a string 'hash' is given, it will return a list 
-         *					of filenames as a associative array with filename basename has key and filename fullpath has value.
-         *	@param $classes	(optional) An array with the classes to include. Standard, it includes YDFSImage, YDFSFile
-         *					and YDFSDirectory classes. If you only need a single class, you can also specify it as a
-         *					string.
-         *  @param $sort_by_date (optional) Sorts the items by date. Default is false.
-         *  @param $sort_order    (optional) Whether the sort direction is ascending or descending. Default is "ASC".
-         *
-         *	@returns	Array of YDFile objects for the files that match the pattern.
-         */
-        function getContents( $pattern='', $class=null, $classes=array( 'YDFSFile', 'YDFSImage', 'YDFSDirectory' ), $sort_by_date=false, $sort_order='asc' ) {
-
-            // Start with an empty list
-            $fileList = array();
-            $fileListMatch = array();
-
-            // Get the list of patterns
-            if ( ! is_array( $pattern ) ) {
-                $pattern = array( $pattern );
-            }
-
-            // Check if there other patterns than exceptions
-            $hasMoreThanExceptions = false;
-            foreach ( $pattern as $patternitem ) {
-                if ( ! empty( $patternitem ) && substr( $patternitem, 0, 1 ) != '!' ) {
-                    $hasMoreThanExceptions = true;
-                    break;
-                }
-            }
-
-            // Get the files that match
-            if ( $hasMoreThanExceptions == true ) {
-                foreach ( $pattern as $patternitem ) {
-                    if ( ! empty( $patternitem ) && substr( $patternitem, 0, 1 ) != '!' ) {
-                        $glob_files = glob( $this->getAbsolutePath() . '/' . $patternitem );
-                        if ( $glob_files !== false ) {
-                            foreach ( $glob_files as $file ) {
-                                $file = basename( $file );
-                                $fileListMatch[ $file ] = $file;
-                            }
-                        }
-                    } else if ( empty( $patternitem ) ) {
-                        $glob_files = glob( $this->getAbsolutePath() . '/*' );
-                        if ( $glob_files !== false ) {
-                            foreach ( glob( $this->getAbsolutePath() . '/*' ) as $file ) {
-                                $file = basename( $file );
-                                $fileListMatch[ $file ] = $file;
-                            }
-                        }
-                    }
-                }
-            } else {
-                $glob_files = glob( $this->getAbsolutePath() . '/' . '*' );
-                if ( $glob_files !== false ) {
-                    foreach ( $glob_files as $file ) {
-                        $file = basename( $file );
-                        $fileListMatch[ $file ] = $file;
-                    }
-                }
-            }
-            $fileList = & $fileListMatch;
-
-            // Remove the files that don't match
-            foreach ( $pattern as $patternitem ) {
-                if ( ! empty( $patternitem ) && substr( $patternitem, 0, 1 ) == '!' ) {
-                    $glob_files = glob( $this->getAbsolutePath() . '/' . substr( $patternitem, 1 ) );
-                    if ( $glob_files !== false ) {
-                        foreach ( $glob_files as $file ) {
-                            $file = basename( $file );
-                            unset( $fileList[ $file ] );
-                        }
-                    }
-                }
-            }
-
-            // Get the values
-            $fileList = array_values( $fileList );
-
-            // Convert the list of a list of YDFile objects
-            $fileList2 = array();
-            foreach ( $fileList as $file ) {
-                $file = $this->getPath() . '/' . $file;
-                if ( ! is_null( $class ) && $class != '' && $class != 'fullpath' && $class != 'hash' ) {
-                    $fileObj = new $class( $file );
-                } else {
-                    if ( is_dir( $file ) ) {
-                        $fileObj = new YDFSDirectory( $file );
-                    } else {
-                        if ( YDPath::isImage( $file ) ) {
-                            $fileObj = new YDFSImage( $file );
-                        } else {
-                            $fileObj = new YDFSFile( $file );
-                        }
-                    }
-                }
-                if ( $sort_by_date === true ) {
-                    $fileList2[ filectime( $file ) . strtolower( $file ) ] = $fileObj;
-                } else {
-                    $fileList2[ strtolower( $file ) ] = $fileObj;
-                }
-            }
-
-            // Sort the list of files
-            if ( strtolower( $sort_order ) != 'desc' ) {
-                ksort( $fileList2 );
-            } else {
-                krsort( $fileList2 );
-            }
-            $fileList2 = array_values( $fileList2 );
-
-            // Remove the unsupported classes
-            if ( ! is_array( $classes ) ) {
-                $classes = array( $classes );
-            }
-            if ( sizeof( $classes ) == 0 ) {
-                return array();
-            }
-            foreach ( $classes as $key => $val ) {
-                $classes[ $key ] = strtolower( $val );
-            }
-            foreach ( $fileList2 as $key=>$val ) {
-                if ( ! in_array( strtolower( get_class( $val ) ), $classes ) ) {
-                    unset( $fileList2[ $key ] );
-                }
-            }
-
-            // Return a simple list if needed
-            if ( is_string( $class ) ) {
-
-                // Initialize a list for the files only
-                $fileOnlyList = array();
-
-                // Add the files
-                foreach ( $fileList2 as $file ) {
-                    $filename = $class === '' ? basename( $file->_path ) : realpath( $file->_path );
-
-                    if ( $class === 'hash' ){
-                        $fileOnlyList[ basename( $file->_path ) ] = $filename;
-                    }else{
-                        $fileOnlyList[] = $filename;
-                    }
-                }
-
-                // Return the fileOnlyList array
-                return $fileOnlyList;
-
-            }
-
-            // Return the file list
-            return $fileList2;
-
-        }
-
-        /**
-         *  This function will list all the files in this directory, but will also recurse into the subdirectories.
-         *
-         *	@param $pattern	(optional) Pattern to which the files should match. If you want multiple items, you can also
-         *					pass them as an array. If the pattern is prefixed with an exclamation mark, the files that
-         *					match this pattern will not be included in the result.
-         *	@param $class	(optional) If you specify a not null value for this option, this function will return the
-         *					items in the directory as the indicated class. If an empty string is given, it will return
-         *					the list of filenames instead of objects. If a string 'fullpath' is given, it will return
-         *					the list of filenames using the fullpath. If a string 'hash' is given, it will return a list 
-         *					of filenames as a associative array with filename basename has key and filename fullpath has value.
-         *	@param $classes	(optional) An array with the classes to include. Standard, it includes YDFSImage and
-         *					YDFSFile classes. If you only need a single class, you can also specify it as a string.
-         *  @param $sort_by_date (optional) Sorts the items by date. Default is false.
-         *  @param $sort_order    (optional) Whether the sort direction is ascending or descending. Default is "ASC".
-         *
-         *	@returns	Array of YDFile objects for the files that match the pattern.
-         */
-        function getFilesRecursively( $pattern='', $class=null, $classes=array( 'YDFSFile', 'YDFSImage' ), $sort_by_date=false, $sort_order='asc') {
-            $files = array();
-            foreach ( $this->_getSubdirectories( $this->_path ) as $dir ) {
-                $dir = new YDFSDirectory( $dir );
-                $files = array_merge( $files, $dir->getContents( $pattern, $class, $classes, $sort_by_date, $sort_order ) );
-            }
-            return $files;
-        }
-
-        /**
-         *	Helper function to get the contents of a directory recursively.
-         *
-         *  @param  $path   The path to get the subdirectories from.
-         *
-         *  @returns    The list of subdirectories of the given path.
-         *
-         *  @internal
-         */
-        function _getSubdirectories( $path ) {
-            $dirlist = array( $path );
-            $dirHandle = opendir( $path );
-            while ( false !== ( $file = readdir( $dirHandle ) ) ) {
-                if ( $file != '.' && $file != '..' ) {
-                    if ( is_dir( $path . '/' . $file ) ) {
-                        array_push( $dirlist, $path . '/' . $file );
-                        $dirlist = array_merge( $dirlist, $this->_getSubdirectories( $path . '/' . $file ) );
-                    }
-                }
-            }
-            sort( $dirlist );
-            return array_unique( $dirlist );
-        }
-
-        /**
-         *	Function to get the full path of the directory.
-         *
-         *	@returns	String containing the full path of the directory.
-         */
-        function getPath() {
-            return YDPath::getFullPath( $this->_path );
-        }
-
-        /**
-         *  This function returns true if the directory is readable.
-         *
-         *  @returns    Returns true if the directory is readable.
-         */
-        function isReadable(){
-            return is_readable( $this->getPath() );
-        }
-
-        /**
-         *	This function will return true if the directory is writeable, otherwise, it will return false.
-         *
-         *	@remarks
-         *		This only works correctly on Unix based systems.
-         *
-         *	@returns	Boolean indicating if the directory is writeable or not.
-         */
-        function isWriteable() {
-            return is_writable( $this->getPath() );
-        }
-
-        /**
-         *	This function will create a new file in the current directory, and will write the specified contents to the
-         *	file. Once finished, it will return a new YDFSFile object pointing to the file. All directory paths are
-         *	relative to the current directory.
-         *
-         *	@param $filename	The filename of the new file.
-         *	@param $contents	The contents of the new file.
-         *
-         *	@returns	YDFSFile or YDFSImage object pointing to the new file.
-         */
-        function createFile( $filename, $contents ) {
-
-            // Set the directory of this object as the working directory
-            chdir( $this->getPath() );
-
-            // Create the new file
-            $fp = fopen( $filename, 'wb' );
-
-            // Save the contents to the file
-            $result = fwrite( $fp, $contents );
-
-            // Check for errors
-            if ( $result == false ) {
-                trigger_error(
-                    'Failed writing to the file "' . $filename . '" in the directory called "' . $this->getPath() . '".',
-                    YD_ERROR
-                );
-            }
-
-            // Close the file
-            fclose( $fp );
-
-            // Create the YDFSFile object
-            $obj = new YDFSFile( $filename );
-
-            // Check if it's an image
-            if ( $obj->isImage() ) {
-                $obj = new YDFSImage( $filename );
-            }
-
-            // Return the file object
-            return $obj;
-
-        }
-
-        /**
-         *	This function will delete a file from the current directory.
-         *
-         *	@param $filename	The file you want to delete.
-         *	@param $failOnError	(optional) Indicate if a fatal error needs to be raised if deleting the file failed.
-         *
-         *	@return	There are three possible return values for this function. True indicates that the file exists and
-         *			is deleted successfully. False indicates the file exists but could not be deleted. Null indicates
-         *			the file didn't exist and therefor could not be deleted.
-         */
-        function deleteFile( $filename, $failOnError=false ) {
-
-            // Set the directory of this object as the working directory
-            chdir( $this->getPath() );
-
-            // Check if the file exists
-            if ( file_exists( $filename ) ) {
-
-                // Try to delete the file
-                $result = unlink( $filename );
-
-                // Check for errors
-                if ( $result == false ) {
-
-                    // Check if we need to raise an error
-                    if ( $failOnError == true ) {
-                        trigger_error(
-                            'Failed deleting the file "' . $file . '" from the directory "' . $this->getPath() . '".',
-                            YD_ERROR
-                        );
-                    }
-
-                }
-
-
-                // Return if the file was deleted or not
-                return $result;
-
-            }
-
-            // Return null if the file doesn't exist
-            return null;
-
-        }
-
-        /**
-         *	This function will create a new subdirectory in the given directory.
-         *
-         *	@param $directory	Directory to create.
-         *	@param $mode		(optional) The mode for the directory. By default, this is 0700.
-         *
-         *	@returns	False on failure, otherwise, it will return a YDFSDirectory object for the new directory.
-         */
-        function createDirectory( $directory, $mode=0700 ) {
-            $directory = YDPath::join( $this->getAbsolutePath(), $directory );
-            if ( is_dir( $directory ) || mkdir( $directory, $mode ) ) {
-                return new YDFSDirectory( $directory );
-            } else {
-                return false;
-            }
-        }
-
-
-        /**
-         *  This function will recursively create the directories
-         *	@param $directory	Directory to create.
-         *	@param $mode		(optional) The mode for the directory. By default, this is 0700.
-         *
-         *	@returns	False on failure, otherwise, it will return a YDFSDirectory object for the new directory.
-         *
-         *  @static
-         */
-        function createDirectories( $directory, $mode=0700 ) {
-            if ( is_null( $directory ) || $directory === '' ) {
-                return false;
-            }
-            if ( is_dir( $directory ) || $directory === '/' ) {
-                return true;
-            }
-            if ( YDFSDirectory::createDirectories( dirname( $directory ), $mode ) ) {
-                return mkdir( $directory, $mode );
-            }
-            return false;
-        }
-
-        /**
-         *	This function will recursively delete a directory. It will delete the directory and the complete
-         *	contents of that directory! Be careful I would say!
-         *
-         *	@param $directory	Directory to be removed.
-         *
-         *	@return	Boolean indicating if the directory could be deleted or not.
-         */
-        function deleteDirectory( $directory ) {
-            $directory = YDPath::join( $this->getAbsolutePath(), $directory );
-            if ( ! is_dir( $directory ) ) {
-                return false;
-            }
-            return YDFSDirectory::_delete( $directory );
-        }
-
-        /**
-         *	This function will return true if the filesystem object is a directory. In all other cases, it will return
-         *	false.
-         *
-         *	@returns	Boolean indicating if the object is a directory or not.
-         */
-        function isDirectory() {
-            return true;
-        }
-
-        /**
-         *	This function will return true if the filesystem object is an image. In all other cases, it will return
-         *	false.
-         *
-         *	@returns	Boolean indicating if the object is an image or not.
-         */
-        function isImage() {
-            return false;
-        }
-
-        /**
-         *	This function will move the directory to the specified path and update the object accordingly.
-         *
-         *	@param	$path	Target path.
-         *
-         *	@returns	False on a failure, true on success.
-         */
-        function moveDirectory( $path ) {
-            $result = rename( $this->getAbsolutePath(), $path );
-            if ( $result ) {
-                $this->_path = realpath( $path );
-            }
-            return $result;
-        }
-
-        /**
-         *  This function will check if the specified file/or directory exists in the current path.
-         *
-         *  @param $obj     The file or directory you are looking for.
-         *	@param $classes	(optional) An array with the classes to include. Standard, it includes YDFSImage, YDFSFile
-         *					and YDFSDirectory classes. If you only need a single class, you can also specify it as a
-         *					string.
-         *
-         *	@returns	Array of YDFile objects for the files that match the pattern.
-         */
-        function has( $obj, $classes=array( 'YDFSFile', 'YDFSImage', 'YDFSDirectory' ) ) {
-
-            // Get the contents
-            $contents = $this->getContents( $obj, '', $classes );
-
-            // Return the result
-            return ( sizeof( $contents ) == 0 ) ? false : true;
-
-        }
-
-        /**
-         *	Function to recursively delete a directory.
-         *
-         *	@param $dirname	Directory to be removed.
-         *
-         *	@return	Boolean indicating if the directory could be deleted or not.
-         *
-         *	@internal
-         */
-        function _delete( $dirname ) {
-
-            // Simple delete for a file
-            if ( is_file( $dirname ) ) {
-                return unlink( $dirname );
-            }
-
-            // Loop through the folder
-            $dir = dir( $dirname );
-            while ( false !== $entry = $dir->read() ) {
-
-                // Skip pointers
-                if ( $entry == '.' || $entry == '..' ) {
-                    continue;
-                }
-
-                // Deep delete directories
-                if ( is_dir( "$dirname/$entry" ) ) {
-                    YDFSDirectory::_delete( "$dirname/$entry" );
-                } else {
-                    unlink( "$dirname/$entry" );
-                }
-            }
-
-            // Clean up
-            $dir->close();
-            return rmdir( $dirname );
-
-        }
-
-    }
-
+<?php
+
+    /*
+
+        Yellow Duck Framework version 2.1
+        (c) Copyright 2002-2007 Pieter Claerhout
+
+        This library is free software; you can redistribute it and/or
+        modify it under the terms of the GNU Lesser General Public
+        License as published by the Free Software Foundation; either
+        version 2.1 of the License, or (at your option) any later version.
+
+        This library is distributed in the hope that it will be useful,
+        but WITHOUT ANY WARRANTY; without even the implied warranty of
+        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+        Lesser General Public License for more details.
+
+        You should have received a copy of the GNU Lesser General Public
+        License along with this library; if not, write to the Free Software
+        Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+
+    */
+
+    /**
+     *  @addtogroup YDFramework Core
+     */
+
+    // Check if the framework is loaded
+    if ( ! defined( 'YD_FW_NAME' ) ) {
+        die( 'Yellow Duck Framework is not loaded.' );
+    }
+
+    // Includes
+    include_once( YD_DIR_HOME_CLS . '/YDUtil.php');
+    include_once( YD_DIR_HOME . '/3rdparty/bmp.php' );
+
+    // YDFSImage cropping specific constants
+    define( 'YD_FS_CROP_UNCHANGED', 1 );
+    define( 'YD_FS_CROP_ENLARGED',  2 );
+    define( 'YD_FS_CROP_BORDERED',  3 );
+
+    // Config when cropping smaller images
+    YDConfig::set( 'YD_FS_CROP', YD_FS_CROP_ENLARGED, false );
+
+    // The mime types mapping
+    $GLOBALS['YD_FS_MIME_MAPPING'] = array(
+        'ez' => 'application/andrew-inset',
+        'hqx' => 'application/mac-binhex40',
+        'cpt' => 'application/mac-compactpro',
+        'mathml' => 'application/mathml+xml',
+        'doc' => 'application/msword',
+        'oda' => 'application/oda',
+        'ogg' => 'application/ogg',
+        'pdf' => 'application/pdf',
+        'rdf' => 'application/rdf+xml',
+        'gram' => 'application/srgs',
+        'grxml' => 'application/srgs+xml',
+        'mif' => 'application/vnd.mif',
+        'xul' => 'application/vnd.mozilla.xul+xml',
+        'xls' => 'application/vnd.ms-excel',
+        'ppt' => 'application/vnd.ms-powerpoint',
+        'wbxml' => 'application/vnd.wap.wbxml',
+        'wmlc' => 'application/vnd.wap.wmlc',
+        'wmlsc' => 'application/vnd.wap.wmlscriptc',
+        'vxml' => 'application/voicexml+xml',
+        'bcpio' => 'application/x-bcpio',
+        'vcd' => 'application/x-cdlink',
+        'pgn' => 'application/x-chess-pgn',
+        'cpio' => 'application/x-cpio',
+        'csh' => 'application/x-csh',
+        'dvi' => 'application/x-dvi',
+        'spl' => 'application/x-futuresplash',
+        'gtar' => 'application/x-gtar',
+        'hdf' => 'application/x-hdf',
+        'js' => 'application/x-javascript',
+        'latex' => 'application/x-latex',
+        'sh' => 'application/x-sh',
+        'shar' => 'application/x-shar',
+        'swf' => 'application/x-shockwave-flash',
+        'sit' => 'application/x-stuffit',
+        'sv4cpio' => 'application/x-sv4cpio',
+        'sv4crc' => 'application/x-sv4crc',
+        'tar' => 'application/x-tar',
+        'tcl' => 'application/x-tcl',
+        'tex' => 'application/x-tex',
+        'man' => 'application/x-troff-man',
+        'me' => 'application/x-troff-me',
+        'ms' => 'application/x-troff-ms',
+        'ustar' => 'application/x-ustar',
+        'src' => 'application/x-wais-source',
+        'xslt' => 'application/xslt+xml',
+        'dtd' => 'application/xml-dtd',
+        'zip' => 'application/zip',
+        'm3u' => 'audio/x-mpegurl',
+        'rpm' => 'audio/x-pn-realaudio-plugin',
+        'ra' => 'audio/x-realaudio',
+        'wav' => 'audio/x-wav',
+        'pdb' => 'chemical/x-pdb',
+        'xyz' => 'chemical/x-xyz',
+        'bmp' => 'image/bmp',
+        'cgm' => 'image/cgm',
+        'gif' => 'image/gif',
+        'ief' => 'image/ief',
+        'png' => 'image/png',
+        'jpg' => 'image/jpeg',
+        'svg' => 'image/svg+xml',
+        'wbmp' => 'image/vnd.wap.wbmp',
+        'ras' => 'image/x-cmu-raster',
+        'ico' => 'image/x-icon',
+        'pnm' => 'image/x-portable-anymap',
+        'pbm' => 'image/x-portable-bitmap',
+        'pgm' => 'image/x-portable-graymap',
+        'ppm' => 'image/x-portable-pixmap',
+        'rgb' => 'image/x-rgb',
+        'xbm' => 'image/x-xbitmap',
+        'xpm' => 'image/x-xpixmap',
+        'xwd' => 'image/x-xwindowdump',
+        'css' => 'text/css',
+        'rtx' => 'text/richtext',
+        'rtf' => 'text/rtf',
+        'tsv' => 'text/tab-separated-values',
+        'wml' => 'text/vnd.wap.wml',
+        'wmls' => 'text/vnd.wap.wmlscript',
+        'etx' => 'text/x-setext',
+        'avi' => 'video/x-msvideo',
+        'movie' => 'video/x-sgi-movie',
+        'ice' => 'x-conference/x-cooltalk',
+        'php' => 'text/plain',
+    );
+
+    /**
+     *	This class houses all different path related functions.
+     *
+     *  @ingroup YDFramework
+     */
+    class YDPath extends YDBase {
+
+        /**
+         *	Provides a platform-specific character used to separate directory levels in a path string that reflects a
+         *	hierarchical file system organization.
+         *
+         *	@returns	String containing the directory separator
+         *
+         *	@static
+         */
+        function getDirectorySeparator() {
+            return ( YD_PATHDELIM == ':' ) ? '/' : '\\';
+        }
+
+        /**
+         *	A platform-specific separator character used to separate path strings in environment variables.
+         *
+         *	@returns	String containing the path separator
+         *
+         *	@static
+         */
+        function getPathSeparator() {
+            return YD_PATHDELIM;
+        }
+
+        /**
+         *	Provides a platform-specific volume separator character.
+         *
+         *	@returns	String containing the volume separator
+         *
+         *	@static
+         */
+        function getVolumeSeparator() {
+            if ( strtoupper( substr( PHP_OS, 0, 3 ) ) == 'WIN' || strtoupper( PHP_OS ) == 'DARWIN' ) {
+                return ':';
+            } else {
+                return '/';
+            }
+        }
+
+        /**
+         *	Changes the extension of a path string.
+         *
+         *	@param $path	Path of the file or directory.
+         *	@param $ext	The new extension.
+         *
+         *	@returns	String with the changed extension
+         *
+         *	@static
+         */
+        function changeExtension( $path, $ext ) {
+            if ( ! empty( $ext ) && substr( $ext, 0, 1 ) != '.' ) {
+                $ext = '.' . $ext;
+            }
+            return YDPath::getFilePathWithoutExtension( $path ) . $ext;
+        }
+
+        /**
+         *	@param $path	Path of the file or directory.
+         *
+         *	@returns	The directory information for the specified path string
+         *
+         *	@static
+         */
+        function getDirectoryName( $path ) {
+            return dirname( $path );
+        }
+
+        /**
+         *	@param $path	Path of the file or directory.
+         *
+         *	@param $format	(Optional) Boolean that defines if free space should be returned as bytes or formated
+         *
+         *	@param $decimals (Optional) Decimals to use when free space is formated
+         *
+         *	@returns	The number of bytes available on the specified path
+         *
+         *	@static
+         */
+        function getFreeSpace( $path, $format = false, $decimals = 1 ) {
+
+            // get free disk space on the path
+            $space = disk_free_space( $path );
+
+            // return number of bytes if we don't want to format
+            if ( $format == false ) return $space;
+
+            // include util lib
+            YDInclude( 'YDUtil.php' );
+
+            // return formated string
+            return YDStringUtil::formatFilesize( $space, $decimals );
+        }
+
+        /**
+         *	@param $path	Path of the file or directory.
+         *
+         *	@returns	The extension of the specified path string
+         *
+         *	@static
+         */
+        function getExtension( $path ) {
+            if ( strrchr( $path, '.' ) ) {
+                return substr( strrchr( $path, '.' ), 1 );
+            } else {
+                return '';
+            }
+        }
+
+        /**
+         *	@param $path	Path of the file or directory.
+         *
+         *	@returns	The file name and extension of the specified path string
+         *
+         *	@static
+         */
+        function getFileName( $path ) {
+            return basename( $path );
+        }
+
+        /**
+         *	@param $path	Path of the file or directory.
+         *
+         *	@returns	The file name of the specified path string without the extension
+         *
+         *	@static
+         */
+        function getFileNameWithoutExtension( $path ) {
+            return basename( $path, '.' . YDPath::getExtension( $path ) );
+        }
+
+        /**
+         *	@param $path	Path of the file or directory.
+         *
+         *	@returns	The file path and extension of the specified path string
+         *
+         *	@static
+         */
+        function getFilePath( $path ) {
+            return realpath( $path );
+        }
+
+        /**
+         *	@param $path	Path of the file or directory.
+         *
+         *	@returns	The file path of the specified path string without the extension
+         *
+         *	@static
+         */
+        function getFilePathWithoutExtension( $path ) {
+            return YDPath::getDirectoryName( $path ) . YDPath::getDirectorySeparator() . YDPath::getFileNameWithoutExtension( $path );
+        }
+
+        /**
+         *	@param $path	Path of the file or directory.
+         *
+         *	@returns	The absolute path for the specified path string
+         *
+         *	@static
+         */
+        function getFullPath( $path ) {
+            return realpath( $path );
+        }
+
+        /**
+         *	@returns	A uniquely named temporary file on disk and returns the full path to that file
+         *
+         *	@static
+         */
+        function getTempFileName() {
+            $tmpName = '';
+            for ($i=0;$i<rand(0,50);$i++) {
+                $tmpName .= "&#" . rand(33,255) . ";";
+            }
+            return YDPath::getTempPath() . YDPath::getDirectorySeparator() . md5( $tmpName ) . '.temp';
+        }
+
+        /**
+         *	@returns	The path of the current system's temporary folder.
+         *
+         *	@static
+         */
+        function getTempPath() {
+            return YD_DIR_TEMP;
+        }
+
+        /**
+         *	@param $path	Path of the file or directory.
+         *
+         *	@returns	Determines whether a path includes a file name extension
+         *
+         *	@static
+         */
+        function hasExtension( $path ) {
+            $ext = YDPath::getExtension( $path );
+            return empty( $ext ) ? false : true;
+        }
+
+        /**
+         *	This function will check if the path is an absolute path or not.
+         *
+         *	@param	$path	The path to check
+         *
+         *	@returns	Boolean indicating if the path is absolute or not.
+         *
+         *	@static
+         */
+        function isAbsolute( $path ) {
+            if ( strtoupper( substr( PHP_OS, 0, 3 ) ) == 'WIN' ) {
+                if ( strlen( $path ) > 3 && substr( $path, 1, 2 ) == ':\\' ) {
+                    return true;
+                } else {
+                    return false;
+                }
+            } else {
+                return ( substr( $path, 0, 1 ) == '/' );
+            }
+        }
+
+        /**
+         *	This function combines different file path elements to each other.
+         *
+         *	@code
+         *	join( 'C:\temp', 'subdir', 'file.html' )
+         *	@endcode
+         *
+         *	results in the following path:
+         *
+         *	@code
+         *	C:\temp\subdir\file.html
+         *	@endcode
+         *
+         *	@returns	The joined path.
+         *
+         *	@static
+         */
+        function join() {
+
+            // Get the arguments for this function
+            $args = func_get_args();
+
+            // Start with an empty path
+            $path = '';
+
+            // Loop over the different elements
+            foreach ( $args as $arg ) {
+
+                if ( ! strlen( $arg ) ) {
+                    continue;
+                }
+
+                // Normalize the path elements
+                $arg = str_replace( '/', YDPath::getDirectorySeparator(), $arg );
+                $arg = str_replace( '\\', YDPath::getDirectorySeparator(), $arg );
+
+                // Check for an absolute path
+                if ( YDPath::isAbsolute( $arg ) ) {
+                    $path = $arg;
+                } else {
+
+                    // Remove the trailing directory separator
+                    if ( substr( $arg, -1, 1 ) == YDPath::getDirectorySeparator() ) {
+                        $arg = substr( $arg, 0, -1 );
+                    }
+
+                    // Add it to the path
+                    if ( strlen( $path ) > 0 ) {
+                        if ( substr( $arg, 0, 1 ) != YDPath::getDirectorySeparator() ) {
+                            $path .= YDPath::getDirectorySeparator() . $arg;
+                        } else {
+                            $path .= $arg;
+                        }
+                    } else {
+                        $path .= $arg;
+                    }
+
+                }
+
+            }
+
+            // Return the joined path
+            return $path;
+
+        }
+
+        /**
+         *	Function to determine if the file is an image or not. This function will read the header of the file to
+         *	find out if it's an image or not.
+         *
+         *	@returns	Boolean indicating if the file is an image or not.
+         */
+        function isImage( $path ) {
+
+            // Return false if path doesn't exist
+            if ( ! realpath( $path ) ) {
+                return false;
+            }
+
+            // Check if we have an extension
+            $extension = strtolower( YDPath::getExtension( $path ) );
+            if ( $extension && $extension != 'tmn' ) {
+                if ( in_array( $extension, array( 'jpg', 'png', 'gif', 'jpeg' ) ) ) {
+                    return $extension;
+                }
+            }
+
+            // No extension, read the file
+            $fp = fopen( $path, 'rb' );
+            $header = fread( $fp, 8 );
+            fclose( $fp );
+            if ( substr( $header, 0, 6 ) == 'GIF87a' || substr( $header, 0, 6 ) == 'GIF89a' ) {
+                return 'gif';
+            }
+            if ( substr( $header, 6, 4 ) == 'JFIF' ) {
+                return 'jpeg';
+            }
+            if ( substr( $header, 0, 8 ) == "\211PNG\r\n\032\n" ) {
+                return 'png';
+            }
+            if ( substr( $header, 0, 2 ) == "BM" ) {
+                return 'bmp';
+            }
+
+            // Not an image
+            return false;
+
+        }
+
+    }
+
+    /**
+     *  This class defines a filesystem file.
+     *
+     *  @ingroup YDFramework
+     */
+    class YDFSFile extends YDBase {
+
+        /**
+         *  The class constructor of the YDFSFile class takes the path to the file as it's first argument.
+         *  It will then provide you with a number of functions to get the properties of the file.
+         *
+         *  @param $path    Path of the file.
+         *  @param $create  (optional) Force the creation of the file if it doesn't exist. Default: false.
+         */
+        function YDFSFile( $path, $create=false ) {
+
+            // Initialize YDBase
+            $this->YDBase();
+
+            // Check if the path if the file exists
+            if ( ! is_file( $path ) ) {
+
+                // Check if the file should be created
+                if ( $create ) {
+
+                    // Create a new YDFSDirectory object
+                    $dir = new YDFSDirectory( dirname( $path ) );
+
+                    // Create the file
+                    $dir->createFile( basename( $path ), ' ' );
+
+                } else {
+                    trigger_error( 'The file with path "' . $path . '" does not exist.', YD_ERROR );
+                }
+            }
+
+            // Save the path
+            $this->_path = realpath( $path );
+
+        }
+
+        /**
+         *	Function to get the filename of the object. This does not include the path information.
+         *
+         *	@returns	String containing the name of the object.
+         */
+        function getBasename() {
+            return YDPath::getFileName( $this->getAbsolutePath() );
+        }
+
+        /**
+         *	Function to get the filename of the object without the extension. This does not include the path information.
+         *
+         *	@returns	String containing the name of the object.
+         */
+        function getBasenameNoExt() {
+            return substr( YDPath::getFilePathWithoutExtension( $this->getBasename() ), 2 );
+        }
+
+        /**
+         *	Function to get the extension of the file.
+         *
+         *	@returns	String containing the extension of the file.
+         */
+        function getExtension() {
+            return YDPath::getExtension( $this->getAbsolutePath() );
+        }
+
+        /**
+         *	Function to get the full path of the object.
+         *
+         *	@returns	String containing the full path of the object.
+         */
+        function getPath() {
+            return YDPath::getDirectoryName( $this->getAbsolutePath() );
+        }
+
+        /**
+         *	Function to get the full absolute path of the object.
+         *
+         *	@returns	String containing the full absolute path of the object.
+         */
+        function getAbsolutePath() {
+            return YDPath::getFullPath( $this->_path );
+        }
+
+        /**
+         *	Function to get the last modification date of the object.
+         *
+         *  @param  $format (optional) The date format to use to format the date.
+         *  @param  $locale (optional) The locale to use for formatting the date.
+         *
+         *	@returns	String containing the last modification date of the object.
+         */
+        function getLastModified( $format = 'timestamp', $locale=null ) {
+            if ( $format == 'timestamp' ) {
+                return filemtime( $this->getAbsolutePath() );
+            }
+            return YDStringUtil::formatDate( filemtime( $this->getAbsolutePath() ), $format, $locale );
+        }
+
+        /**
+         *	Function to get the size of the file.
+         *
+         *  @param  $formatted  (optional) If set to true, the filesize will be returned in a human readable format.
+         *  @param  $decimals   (optional) The number of decimals to use for formatting the filesize.
+         *
+         *	@returns	Double containing the length of the file.
+         */
+        function getSize( $formatted = false, $decimals = 1 ) {
+            if ( ! $formatted ) {
+                return filesize( $this->getAbsolutePath() );
+            }
+            return YDStringUtil::formatFilesize( filesize( $this->getAbsolutePath() ), $decimals );
+        }
+
+        /**
+         *  Returns the total free space on the partition where this file lives
+         *
+         *	@param $format	 (Optional) Boolean that defines if free space should be returned as bytes or formated
+         *	@param $decimals (Optional) Decimals to use when free space is formated
+         *
+         *	@returns	The number of bytes available
+         *
+         *	@static
+         */
+        function getFreeSpace( $format = false, $decimals = 1 ) {
+            return YDPath::getFreeSpace( $this->_path, $format, $decimals );
+        }
+
+        /**
+         *	Function to get the contents of the file. Depending on the file contents, this will be returned as binary or
+         *	textual data.
+         *
+         *	@param $start	(optional) Byte to start reading from.
+         *	@param $length	(optional) Number of bytes to read.
+         *
+         *	@returns	String containing the contents of the file.
+         */
+        function getContents( $start=null, $length=null ) {
+
+            // Clear the stat cache
+            clearstatcache();
+
+            // Check the start byte
+            if ( $start == null ) {
+                $start = 0;
+            }
+
+            // No length given
+            if ( $length == null ) {
+                $length = filesize( $this->getAbsolutePath() ) - $start;
+            }
+
+            // Check that length is a positive integer
+            if ( $length < 1 ) {
+                trigger_error( 'getContents: Length should be a positive integer.', YD_ERROR );
+            }
+
+            // Variable to hold the return data
+            $result = '';
+
+            // Open the file in read binary mode
+            $file = fopen( $this->getAbsolutePath(), 'rb' );
+
+            // Check if we were able to open the file
+            if ( $file == false ) {
+                trigger_error( 'The file with path "' . $path . '" could not be read.', YD_ERROR );
+            }
+
+            // Find the start position
+            fseek( $file, $start );
+
+            // Get the contents of the file
+            $result = fread( $file, $length );
+
+            // Close the file handle
+            fclose( $file );
+
+            // Return the result
+            return $result;
+
+        }
+
+        /**
+         *	This function will create a new file in the current directory, and will write the specified contents to the
+         *	file. Once finished, it will return a new YDFSFile object pointing to the file. All directory paths are
+         *	relative to the current directory.
+         *
+         *	@param $contents	The contents of the new file.
+         *	@param $append		Boolean indicating if the content should be appended to the file or if the file contents
+         *						should be replaced.
+         */
+        function setContents( $contents, $append=false ) {
+
+            // Set the mode
+            $mode = ( $append === true ) ? 'ab' : 'wb';
+
+            // Open the file
+            $fp = fopen( $this->getAbsolutePath(), $mode );
+
+            // Save the contents to the file
+            $result = fwrite( $fp, $contents );
+
+            // Check for errors
+            if ( $result == false ) {
+                trigger_error(
+                    'Failed writing to the file "' . $this->getAbsolutePath() . '" in the directory called "' . $this->getPath() . '".',
+                    YD_ERROR
+                );
+            }
+
+            // Close the file
+            fclose( $fp );
+
+            // Clear the stat cache
+            clearstatcache();
+
+        }
+
+        /**
+         *	Function to determine if the file is an image or not. This function will read the header of the file to
+         *	find out if it's an image or not.
+         *
+         *	@returns	Boolean indicating if the file is an image or not.
+         */
+        function isImage() {
+            return YDPath::isImage( $this->getAbsolutePath() );
+        }
+
+        /**
+         *  This function returns true if the file is readable.
+         *
+         *  @returns    Returns true if the file is readable.
+         */
+        function isReadable(){
+            return is_readable( $this->getAbsolutePath() );
+        }
+
+        /**
+         *	This function will return true if the directory is writeable, otherwise, it will return false.
+         *
+         *	@remarks
+         *		This only works correctly on Unix based systems.
+         *
+         *	@returns	Boolean indicating if the directory is writeable or not.
+         */
+        function isWriteable() {
+            return is_writable( $this->getAbsolutePath() );
+        }
+
+        /**
+         *	This function will force the browser to download the file.
+         *
+         *	@param $name	(optional) The name of the file download should show in the browser. By default, this is the
+         *					same as the filename.
+         *  @param $inline  (optional) If set to true, the download is inline, otherwise, a download will be forced by
+         *                  the browser. Default is false.
+         */
+        function download( $name=null, $inline=false ) {
+
+            // Get the name of the file
+            if ( is_null( $name ) ) {
+                $name = $this->getBasename();
+            }
+
+            // Force download or do inline
+            if ( ! $inline ) {
+                header( 'Content-Type: application/force-download; name="' . $name . '"');
+                header( 'Content-Disposition: attachment; filename="' . $name . ' "');
+            } else {
+                header( 'Content-Type: ' . $this->getMimeType() );
+                header( 'Content-Disposition: inline; filename="' . $name . ' "');
+            }
+
+            // Add the rest of the headers
+            header( 'Cache-Control: public' );
+            header( 'Content-Transfer-Encoding: binary' );
+            header( 'Content-length: ' . $this->getSize() );
+
+            // Send the file contents
+            readfile( $this->getAbsolutePath() );
+
+            // Stop the execution
+            die();
+
+        }
+
+        /**
+         *	This function will delete a file from the current directory.
+         *
+         *	@param $failOnError	(optional) Indicate if a fatal error needs to be raised if deleting the file failed.
+         *
+         *	@return	There are three possible return values for this function. True indicates that the file exists and
+         *			is deleted successfully. False indicates the file exists but could not be deleted. Null indicates
+         *			the file didn't exist and therefor could not be deleted.
+         */
+        function delete( $failOnError=false ) {
+
+            // Set the filename
+            $filename = $this->getAbsolutePath();
+
+            // Set the directory of this object as the working directory
+            chdir( $this->getPath() );
+
+            // Check if the file exists
+            if ( file_exists( $filename ) ) {
+
+                // Try to delete the file
+                $result = unlink( $filename );
+
+                // Check for errors
+                if ( $result == false ) {
+
+                    // Check if we need to raise an error
+                    if ( $failOnError == true ) {
+                        trigger_error(
+                            'Failed deleting the file "' . $filename . '" from the directory "' . $this->getPath() . '".',
+                            YD_ERROR
+                        );
+                    }
+
+                }
+
+                // Return if the file was deleted or not
+                return $result;
+
+            }
+
+            // Return null if the file doesn't exist
+            return null;
+
+        }
+
+        /**
+         *  This function will rename the file to the specified file path.
+         *
+         *  @param  $new_path   The new path of the file.
+         *
+         *  @returns    True on success, false on failure.
+         */
+        function rename( $new_path ) {
+            @unlink( $new_path );
+            $result = rename( $this->getAbsolutePath(), $new_path );
+            if ( $result === true ) {
+                $this->_path = realpath( $new_path );
+            }
+            return $result;
+        }
+
+        /**
+         *	This function will return true if the filesystem object is a directory. In all other cases, it will return
+         *	false.
+         *
+         *	@returns	Boolean indicating if the object is a directory or not.
+         */
+        function isDirectory() {
+            return false;
+        }
+
+        /**
+         *  This function returns the mime type for the file object.
+         *
+         *  @returns    The mime type for the document. If the mime type is not known, it will use the
+         *              application/octet-stream mime type.
+         */
+        function getMimeType() {
+            $extension = strtolower( $this->getExtension() );
+            if ( isset( $GLOBALS['YD_FS_MIME_MAPPING'][$extension] ) ) {
+                return $GLOBALS['YD_FS_MIME_MAPPING'][$extension];
+            } else {
+                return 'application/octet-stream';
+            }
+        }
+
+        /**
+         *	@internal
+         */
+        function _getImageType() {
+            return YDPath::isImage( $this->getAbsolutePath() );
+        }
+
+        /**
+         *	This function will move the file to the specified path and update the object accordingly.
+         *
+         *	@param	$path	Target path.
+         *
+         *	@returns	False on a failure, true on success.
+         */
+        function move( $path ) {
+            $result = rename( $this->getAbsolutePath(), $path );
+            if ( $result ) {
+                $this->_path = realpath( $path );
+            }
+            return $result;
+        }
+
+    }
+
+    /**
+     *	This class defines an image file.
+     *
+     *  @ingroup YDFramework
+     */
+    class YDFSImage extends YDFSFile {
+
+        /**
+         *	The class constructor of the YDImage class takes the path to the image as it's only argument. It will then
+         *	provide you with a number of functions to get the properties of the image and also provides some actions
+         *	like generating thumbnails.
+         *
+         *	@param $path	Path of the image.
+         *  @param $create  (optional) Force the creation of the file if it doesn't exist. Default: false.
+         */
+        function YDFSImage( $path, $create=false ) {
+
+            // Initialize the parent
+            $this->YDFSFile( $path, $create );
+
+            // Get the image size
+            $this->image_size = null;
+
+        }
+
+        /**
+         *  Function determine the image size. This is just a helper function for the other ones.
+         *
+         *  @internal
+         */
+        function _initImageSize() {
+
+            // Check for the getimagesize function
+            if ( ! function_exists( 'getimagesize' ) ) {
+                trigger_error(
+                    'The "getimagesize" function does not exists. Make sure that the GD libraries are loaded before '
+                    . 'using the YDFSImage::getImageSize function.', YD_ERROR
+                );
+            }
+
+            if ( is_null( $this->image_size ) ) {
+                $this->image_size = getimagesize( $this->getAbsolutePath() );
+            }
+       }
+
+        /**
+         *	Function to output the thumbnail of an image. The function directly outputs the thumbnail to the client
+         *	including the right headers needed to display the image.
+         *
+         *	This function can cache the thumbnails and regenerate them on the fly if needed. The cached thumbnails are
+         *	stored in the temp directory of the Yellow Duck framework and have the extension "tmn". You can delete these
+         *	automatically as they will be recreated on the fly if needed.
+         *
+         *	@param $width	The maximum width of the thumbnail.
+         *	@param $height	The maximum height of the thumbnail.
+         *	@param $cache	(optional) Indicate if the thumbnail should be cached. By default, caching is turned on.
+         *	@param $crop	(optional) Indicate if the thumbnail should be cropped to the exact size. By default, false.
+         */
+        function outputThumbnail( $width, $height, $cache=true, $crop=false ) {
+
+            // Output right headers
+            $content_type = $this->getMimeType();
+            header( 'Content-type: ' . $content_type );
+
+            // Output the thumbnail
+            die( $this->_createThumbnail( $width, $height, $cache, $crop ) );
+
+        }
+
+        /**
+         *	This function will create a thumbnail and save the thumbnail to disk.
+         *
+         *	@param $width	The maximum width of the thumbnail.
+         *	@param $height	The maximum height of the thumbnail.
+         *	@param $file	The filename to save the thumbnail to.
+         *	@param $crop	(optional) Indicate if the thumbnail should be cropped to the exact size. By default, false.
+         *
+         *  @returns    A new YDFSImage object for the thumbnail.
+         */
+        function saveThumbnail( $width, $height, $file, $crop=false ) {
+
+            // Create the thumbnail
+            $thumb = $this->_createThumbnail( $width, $height, false, $crop );
+
+            // Save it to a file
+            $f = new YDFSImage( $file, true );
+            $f->setContents( $thumb );
+
+            // Return the thumbnail
+            return $f;
+
+        }
+
+        /**
+         *	This function will return the size of the image in pixels.
+         *
+         *	@returns	The imagesize in pixels. This is returned as an array of which the first element is the width,
+         *				the second element is the height in pixels.
+         */
+        function getImageSize() {
+
+            // Init image_size
+            $this->_initImageSize();
+
+            // Get the first two elements
+            $imgSize = array_slice( $this->image_size, 0, 2 );
+
+            // Return the image size
+            return $imgSize;
+
+        }
+
+        /**
+         *	This function will return the width of the image in pixels.
+         *
+         *	@returns	The width in pixels.
+         */
+        function getWidth() {
+            $this->_initImageSize();
+            return $this->image_size[0];
+        }
+
+        /**
+         *	This function will return the height of the image in pixels.
+         *
+         *	@returns	The height in pixels.
+         */
+        function getHeight() {
+            $this->_initImageSize();
+            return $this->image_size[1];
+        }
+
+        /**
+         *	Function that returns the type of the image. Currently, it supports GIF, JPG and PNG.
+         *
+         *	@returns	The type of the image, which is either jpg, png or gif.
+         */
+        function getImageType() {
+
+            // Get the image type
+            $type = $this->_getImageType();
+
+            // Raise error about unsupported image type
+            if ( $type === false ) {
+                trigger_error(
+                    'The getImageType function does not support the file format of the file "'
+                    . $this->getAbsolutePath() . '".', YD_ERROR
+                );
+            } else {
+                return $type;
+            }
+
+         }
+
+        /**
+         *	This function is used to output an error image.
+         *
+         *	@param $name	(optional) Name of the error image. Default image that is shown is the generic
+         *					"YD_ydfsimage_fatal_error".
+         *
+         *	@internal
+         */
+        function _error( $name='YD_ydfsimage_fatal_error' ) {
+            $img = new YDFSImage( YD_DIR_HOME . '/images/' . $name . '.gif' );
+            header( 'Content-type: ' . $img->getMimeType() );
+            echo( $img->getContents() );
+            die();
+        }
+
+        /**
+         *	This function will do the actual work of creating a thumbnail image.
+         *
+         *	@param $width	The maximum width of the thumbnail.
+         *	@param $height	The maximum height of the thumbnail.
+         *	@param $cache	(optional) Indicate if the thumbnails should be cached. By default, caching is turned off.
+         *	@param $crop	(optional) Indicate if the thumbnails should be cropped to the exact size. By default, false.
+         *
+         *	@internal
+         */
+        function & _createThumbnail( $width, $height, $cache=true, $crop=false ) {
+
+            // Check if the GD library is loaded.
+            if ( ! extension_loaded( 'gd' ) ) {
+                $this->_error( 'YD_gd_not_installed' );
+            }
+
+            // Width and height should be positive integer
+            if ( $width < 1 || $height < 1 ) {
+                $this->_error();
+            }
+
+            // Get the cache filename
+            $cacheFName = YD_DIR_TEMP . '/' . $this->_createThumbnailName( $width, $height, $crop );
+
+            // Check if caching is enabled
+            if ( $cache === true ) {
+
+                // Output the cached version if any
+                if ( is_file( $cacheFName ) ) {
+                    readfile( $cacheFName );
+                    die();
+                }
+
+            }
+
+            // Check the extension
+            $img_type = $this->isImage();
+
+            // Open the source image
+            if ( $img_type == 'gif' ) {
+                if ( ! function_exists( 'imagecreatefromgif' ) ) {
+                    $this->_error();
+                }
+                $src_img = imagecreatefromgif( $this->getAbsolutePath() );
+            } elseif ( $img_type == 'png' ) {
+                $src_img = imagecreatefrompng( $this->getAbsolutePath() );
+            } elseif ( $img_type == 'bmp' ) {
+                $src_img = imagecreatefrombmp( $this->getAbsolutePath() );
+            } else {
+                $src_img = imagecreatefromjpeg( $this->getAbsolutePath() );
+            }
+
+            // Get the current image size
+            $ori_width  = imageSX( $src_img );
+            $ori_height = imageSY( $src_img );
+
+            // Calculate the new image size
+            if ( $crop ) {
+
+                if ( $ori_width > $ori_height ) {
+                    $thumb_w = ceil( $ori_width * ( $height / $ori_height ) );
+                    $thumb_h = $height;
+                }
+                if ( $ori_width < $ori_height ) {
+                    $thumb_w = $width;
+                    $thumb_h = ceil( $ori_height * ( $width / $ori_width ) );
+                }
+
+            } else {
+
+                if ( $ori_width > $ori_height ) {
+                    $thumb_w = $width;
+                    $thumb_h = ceil( $ori_height * ( $width / $ori_width ) );
+                }
+                if ( $ori_width < $ori_height ) {
+                    $thumb_w = ceil( $ori_width * ( $height / $ori_height ) );
+                    $thumb_h = $height;
+                }
+
+            }
+
+            if ( $ori_width == $ori_height ) {
+                $thumb_w = $width;
+                $thumb_h = $height;
+            }
+
+            if ( ( $width >= $ori_width || $height >= $ori_height ) && ( ! $crop || ( $crop && YDConfig::get( 'YD_FS_CROP' ) != YD_FS_CROP_ENLARGED ) ) ) {
+
+                if ( $width >= $ori_width && $height < $ori_height ) {
+                    $thumb_w = ceil( $ori_width * ( $height / $ori_height ) );
+                    $thumb_h = $height;
+                } else if ( $width < $ori_width && $height >= $ori_height ) {
+                    $thumb_w = $width;
+                    $thumb_h = ceil( $ori_height * ( $width / $ori_width ) );
+                } else {
+                    $thumb_w = $ori_width;
+                    $thumb_h = $ori_height;
+                }
+
+            }
+
+            // Resample the image
+            $dst_img = imagecreatetruecolor( $thumb_w, $thumb_h );
+            if ( $img_type == 'png' ) {
+                imagecopyresized( $dst_img, $src_img, 0, 0, 0, 0, $thumb_w, $thumb_h, $ori_width, $ori_height );
+            } else {
+                imagecopyresampled( $dst_img, $src_img, 0, 0, 0, 0, $thumb_w, $thumb_h, $ori_width, $ori_height );
+            }
+
+            if ( $crop && ( $width != $thumb_w || $height != $thumb_h ) ) {
+
+                $x = ceil( abs( $thumb_w-$width  ) / 2 );
+                $y = ceil( abs( $thumb_h-$height ) / 2 );
+
+                $default = true;
+
+                if ( $ori_width < $width || $ori_height < $height ) {
+
+                    switch ( YDConfig::get( 'YD_FS_CROP', YD_FS_CROP_ENLARGED ) ) {
+
+                        case YD_FS_CROP_UNCHANGED:
+
+                            if ( $ori_width < $width && $ori_height < $height ) {
+                                $crp_img = $dst_img;
+                                $default = false;
+                            } else if ( $ori_width < $width ) {
+                                $x = 0;
+                                $width = $ori_width;
+                            } else if ( $ori_height < $height ) {
+                                $y = 0;
+                                $height = $ori_height;
+                            }
+                            break;
+
+                        case YD_FS_CROP_ENLARGED:
+                        case YD_FS_CROP_BORDERED:
+                            break;
+
+                    }
+
+                }
+
+                if ( $default ) {
+
+                    $crp_img = imagecreatetruecolor( $width, $height );
+
+                    if ( $img_type == 'png' ) {
+                        imagecopyresized( $crp_img, $dst_img, 0, 0, $x, $y, $width, $height, $width, $height );
+                    } else {
+                        imagecopyresampled( $crp_img, $dst_img, 0, 0, $x, $y, $width, $height, $width, $height );
+                    }
+
+                }
+
+                $dst_img = $crp_img;
+
+            }
+
+            // Get the resulting image
+            ob_start();
+            if ( $img_type == 'gif' ) {
+                if ( ! function_exists( 'imagegif' ) ) {
+                    imagepng( $dst_img );
+                } else {
+                    imagegif( $dst_img );
+                }
+            } elseif ( $img_type == 'png' ) {
+                imagepng( $dst_img );
+            } else {
+                imagejpeg( $dst_img );
+            }
+            $image_data = ob_get_contents();
+            ob_end_clean();
+
+            // Destroy the images
+            imagedestroy( $dst_img );
+            imagedestroy( $src_img );
+
+            // Save the cache if needed
+            if ( $cache == true ) {
+                $f = new YDFSFile( $cacheFName, true );
+                $f->setContents( $image_data );
+            }
+
+            // Return the image data
+            return $image_data;
+
+        }
+
+        /**
+         *  This function creates the cache name for thumbnails.
+         *
+         *	@param $width	The maximum width of the thumbnail.
+         *	@param $height	The maximum height of the thumbnail.
+         *	@param $crop	Indicate if is the cropped version.
+         */
+        function _createThumbnailName( $width, $height, $crop ) {
+            $cacheFName = $this->getAbsolutePath() . '/' . $width . '/' . $height . '/' . strval( $crop ) . $this->getLastModified();
+            $cacheFName = YD_TMP_PRE . 'N_' . md5( $cacheFName ) . '.' . strtolower( $this->getExtension() );
+            return $cacheFName;
+        }
+
+    }
+
+    /**
+     *  This class defines a filesystem directory.
+     *
+     *  @ingroup YDFramework
+     */
+    class YDFSDirectory extends YDBase {
+
+        /**
+         *	This is the class constructor of the YDDirectory class.
+         *
+         *	@param $path	(optional) Path of the directory. Default is the current directory.
+         */
+        function YDFSDirectory( $path='.' ) {
+
+            // Initialize YDBase
+            $this->YDBase();
+
+            // Fail if directory
+            if ( ! is_dir( $path ) ) {
+                trigger_error( 'The directory with path "' . $path . '" does not exist.', YD_ERROR );
+            }
+
+            // Save the path
+            $this->_path = realpath( $path );
+
+        }
+
+        /**
+         *	Function to get the basename of the directory. This does not include the path information.
+         *
+         *	@returns	String containing the name of the object.
+         */
+        function getBasename() {
+            return YDPath::getFileName( $this->getAbsolutePath() );
+        }
+
+        /**
+         *	Function to get the full absolute path of the object.
+         *
+         *	@returns	String containing the full absolute path of the object.
+         */
+        function getAbsolutePath() {
+            return $this->getPath();
+        }
+
+        /**
+         *  This function return the number of files that are in the directory.
+         *
+         *  @returns    The number of files in the directory.
+         */
+        function getFileCount(){
+            $total = 0;
+            $dirHandle = opendir( $this->getPath() );
+            while ( false !== ( $file = readdir( $dirHandle ) ) ) {
+                if ( $file != '.' && $file != '..' && is_file( $this->getPath() .'/'. $file ) ) {
+                   $total++;
+                }
+            }
+            closedir( $dirHandle );
+            return $total;
+        }
+
+        /**
+         *  This function return the number of directories that are in the directory.
+         *
+         *  @returns    The number of directories in the directory.
+         */
+        function getDirectoryCount(){
+            $total = 0;
+            $dirHandle = opendir( $this->getPath() );
+            while ( false !== ( $file = readdir( $dirHandle ) ) ) {
+            if ( $file != '.' && $file != '..' && is_dir( $this->getPath() .'/'. $file ) ) {
+                    $total++;
+                }
+            }
+            closedir( $dirHandle );
+            return $total;
+        }
+
+        /**
+         *  Returns the total size of the directory.
+         *
+         *  @param  $recursive  (optional) Recurse into the subdirectories. Default is false.
+         *  @param  $formatted  (optional) If set to true, the filesize will be returned in a human readable format.
+         *  @param  $decimals   (optional) The number of decimals to use for formatting the filesize.
+         *
+         *  @returns    The total size of the directory.
+         */
+        function getSize( $recursive = false, $formatted = false, $decimals = 1 ) {
+            $total = 0;
+            $dirHandle = opendir( $this->getPath() );
+            while ( false !== ( $file = readdir( $dirHandle ) ) ) {
+                if ( $file == '.' || $file == '..') {
+                    continue;
+                }
+                if ( is_file( $this->getPath() .'/'. $file ) ) {
+                    $total += filesize( $this->getPath() .'/'. $file );
+                } else if ( $recursive && is_dir( $this->getPath() .'/'. $file ) ) {
+                    $subdir = new YDFSDirectory( $this->getPath() .'/'. $file );
+                    $total += $subdir->getSize(true, false, $decimals);
+                }
+            }
+            closedir( $dirHandle );
+            if ( ! $formatted ) {
+                return $total;
+            }
+            return YDStringUtil::formatFilesize( $total, $decimals );
+        }
+
+        /**
+         *  Returns the total free space on the partition where this directory lives
+         *
+         *	@param $format	 (Optional) Boolean that defines if free space should be returned as bytes or formated
+         *	@param $decimals (Optional) Decimals to use when free space is formated
+         *
+         *	@returns	The number of bytes available
+         *
+         *	@static
+         */
+        function getFreeSpace( $format = false, $decimals = 1 ) {
+            return YDPath::getFreeSpace( $this->_path, $format, $decimals );
+        }
+
+        /**
+         *	This function will get a file list using a pattern. You can compare this function with the dir command from
+         *	DOS or the ls command from Unix. The pattern syntax is the same as well.
+         *
+         *	@remarks
+         *		This will not work recursively on the subdirectories.
+         *
+         *	@param $pattern	(optional) Pattern to which the files should match. If you want multiple items, you can also
+         *					pass them as an array. If the pattern is prefixed with an exclamation mark, the files that
+         *					match this pattern will not be included in the result.
+         *	@param $class	(optional) If you specify a not null value for this option, this function will return the
+         *					items in the directory as the indicated class. If an empty string is given, it will return
+         *					the list of filenames instead of objects. If a string 'fullpath' is given, it will return
+         *					the list of filenames using the fullpath. If a string 'hash' is given, it will return a list 
+         *					of filenames as a associative array with filename basename has key and filename fullpath has value.
+         *	@param $classes	(optional) An array with the classes to include. Standard, it includes YDFSImage, YDFSFile
+         *					and YDFSDirectory classes. If you only need a single class, you can also specify it as a
+         *					string.
+         *  @param $sort_by_date (optional) Sorts the items by date. Default is false.
+         *  @param $sort_order    (optional) Whether the sort direction is ascending or descending. Default is "ASC".
+         *
+         *	@returns	Array of YDFile objects for the files that match the pattern.
+         */
+        function getContents( $pattern='', $class=null, $classes=array( 'YDFSFile', 'YDFSImage', 'YDFSDirectory' ), $sort_by_date=false, $sort_order='asc' ) {
+
+            // Start with an empty list
+            $fileList = array();
+            $fileListMatch = array();
+
+            // Get the list of patterns
+            if ( ! is_array( $pattern ) ) {
+                $pattern = array( $pattern );
+            }
+
+            // Check if there other patterns than exceptions
+            $hasMoreThanExceptions = false;
+            foreach ( $pattern as $patternitem ) {
+                if ( ! empty( $patternitem ) && substr( $patternitem, 0, 1 ) != '!' ) {
+                    $hasMoreThanExceptions = true;
+                    break;
+                }
+            }
+
+            // Get the files that match
+            if ( $hasMoreThanExceptions == true ) {
+                foreach ( $pattern as $patternitem ) {
+                    if ( ! empty( $patternitem ) && substr( $patternitem, 0, 1 ) != '!' ) {
+                        $glob_files = glob( $this->getAbsolutePath() . '/' . $patternitem );
+                        if ( $glob_files !== false ) {
+                            foreach ( $glob_files as $file ) {
+                                $file = basename( $file );
+                                $fileListMatch[ $file ] = $file;
+                            }
+                        }
+                    } else if ( empty( $patternitem ) ) {
+                        $glob_files = glob( $this->getAbsolutePath() . '/*' );
+                        if ( $glob_files !== false ) {
+                            foreach ( glob( $this->getAbsolutePath() . '/*' ) as $file ) {
+                                $file = basename( $file );
+                                $fileListMatch[ $file ] = $file;
+                            }
+                        }
+                    }
+                }
+            } else {
+                $glob_files = glob( $this->getAbsolutePath() . '/' . '*' );
+                if ( $glob_files !== false ) {
+                    foreach ( $glob_files as $file ) {
+                        $file = basename( $file );
+                        $fileListMatch[ $file ] = $file;
+                    }
+                }
+            }
+            $fileList = & $fileListMatch;
+
+            // Remove the files that don't match
+            foreach ( $pattern as $patternitem ) {
+                if ( ! empty( $patternitem ) && substr( $patternitem, 0, 1 ) == '!' ) {
+                    $glob_files = glob( $this->getAbsolutePath() . '/' . substr( $patternitem, 1 ) );
+                    if ( $glob_files !== false ) {
+                        foreach ( $glob_files as $file ) {
+                            $file = basename( $file );
+                            unset( $fileList[ $file ] );
+                        }
+                    }
+                }
+            }
+
+            // Get the values
+            $fileList = array_values( $fileList );
+
+            // Convert the list of a list of YDFile objects
+            $fileList2 = array();
+            foreach ( $fileList as $file ) {
+                $file = $this->getPath() . '/' . $file;
+                if ( ! is_null( $class ) && $class != '' && $class != 'fullpath' && $class != 'hash' ) {
+                    $fileObj = new $class( $file );
+                } else {
+                    if ( is_dir( $file ) ) {
+                        $fileObj = new YDFSDirectory( $file );
+                    } else {
+                        if ( YDPath::isImage( $file ) ) {
+                            $fileObj = new YDFSImage( $file );
+                        } else {
+                            $fileObj = new YDFSFile( $file );
+                        }
+                    }
+                }
+                if ( $sort_by_date === true ) {
+                    $fileList2[ filectime( $file ) . strtolower( $file ) ] = $fileObj;
+                } else {
+                    $fileList2[ strtolower( $file ) ] = $fileObj;
+                }
+            }
+
+            // Sort the list of files
+            if ( strtolower( $sort_order ) != 'desc' ) {
+                ksort( $fileList2 );
+            } else {
+                krsort( $fileList2 );
+            }
+            $fileList2 = array_values( $fileList2 );
+
+            // Remove the unsupported classes
+            if ( ! is_array( $classes ) ) {
+                $classes = array( $classes );
+            }
+            if ( sizeof( $classes ) == 0 ) {
+                return array();
+            }
+            foreach ( $classes as $key => $val ) {
+                $classes[ $key ] = strtolower( $val );
+            }
+            foreach ( $fileList2 as $key=>$val ) {
+                if ( ! in_array( strtolower( get_class( $val ) ), $classes ) ) {
+                    unset( $fileList2[ $key ] );
+                }
+            }
+
+            // Return a simple list if needed
+            if ( is_string( $class ) ) {
+
+                // Initialize a list for the files only
+                $fileOnlyList = array();
+
+                // Add the files
+                foreach ( $fileList2 as $file ) {
+                    $filename = $class === '' ? basename( $file->_path ) : realpath( $file->_path );
+
+                    if ( $class === 'hash' ){
+                        $fileOnlyList[ basename( $file->_path ) ] = $filename;
+                    }else{
+                        $fileOnlyList[] = $filename;
+                    }
+                }
+
+                // Return the fileOnlyList array
+                return $fileOnlyList;
+
+            }
+
+            // Return the file list
+            return $fileList2;
+
+        }
+
+        /**
+         *  This function will list all the files in this directory, but will also recurse into the subdirectories.
+         *
+         *	@param $pattern	(optional) Pattern to which the files should match. If you want multiple items, you can also
+         *					pass them as an array. If the pattern is prefixed with an exclamation mark, the files that
+         *					match this pattern will not be included in the result.
+         *	@param $class	(optional) If you specify a not null value for this option, this function will return the
+         *					items in the directory as the indicated class. If an empty string is given, it will return
+         *					the list of filenames instead of objects. If a string 'fullpath' is given, it will return
+         *					the list of filenames using the fullpath. If a string 'hash' is given, it will return a list 
+         *					of filenames as a associative array with filename basename has key and filename fullpath has value.
+         *	@param $classes	(optional) An array with the classes to include. Standard, it includes YDFSImage and
+         *					YDFSFile classes. If you only need a single class, you can also specify it as a string.
+         *  @param $sort_by_date (optional) Sorts the items by date. Default is false.
+         *  @param $sort_order    (optional) Whether the sort direction is ascending or descending. Default is "ASC".
+         *  @param $levels        (optional) Integer that defines how deep should the cycle go. Default: -1 (infinite).
+         *
+         *	@returns	Array of YDFile objects for the files that match the pattern.
+         */
+        function getFilesRecursively( $pattern='', $class=null, $classes=array( 'YDFSFile', 'YDFSImage' ), $sort_by_date=false, $sort_order='asc', $levels = -1 ) {
+            $files = array();
+            foreach ( $this->_getSubdirectories( $this->_path, $levels ) as $dir ) {
+                $dir = new YDFSDirectory( $dir );
+                $files = array_merge( $files, $dir->getContents( $pattern, $class, $classes, $sort_by_date, $sort_order ) );
+            }
+            return $files;
+        }
+
+        /**
+         *	Helper function to get the contents of a directory recursively.
+         *
+         *  @param  $path   The path to get the subdirectories from.
+         *  @param  $levels (optional) Integer that defines how deep should the cycle go. Default: -1 (infinite).
+         *
+         *  @returns    The list of subdirectories of the given path.
+         *
+         *  @internal
+         */
+        function _getSubdirectories( $path, $levels = -1 ) {
+            $dirlist = array( $path );
+            if ( $levels == 0 ) return $dirlist;
+            $dirHandle = opendir( $path );
+            while ( false !== ( $file = readdir( $dirHandle ) ) ) {
+                if ( $file != '.' && $file != '..' ) {
+                    if ( is_dir( $path . '/' . $file ) ) {
+                        array_push( $dirlist, $path . '/' . $file );
+                        $dirlist = array_merge( $dirlist, $this->_getSubdirectories( $path . '/' . $file, $levels - 1 ) );
+                    }
+                }
+            }
+            sort( $dirlist );
+            return array_unique( $dirlist );
+        }
+
+        /**
+         *	Function to get the full path of the directory.
+         *
+         *	@returns	String containing the full path of the directory.
+         */
+        function getPath() {
+            return YDPath::getFullPath( $this->_path );
+        }
+
+        /**
+         *  This function returns true if the directory is readable.
+         *
+         *  @returns    Returns true if the directory is readable.
+         */
+        function isReadable(){
+            return is_readable( $this->getPath() );
+        }
+
+        /**
+         *	This function will return true if the directory is writeable, otherwise, it will return false.
+         *
+         *	@remarks
+         *		This only works correctly on Unix based systems.
+         *
+         *	@returns	Boolean indicating if the directory is writeable or not.
+         */
+        function isWriteable() {
+            return is_writable( $this->getPath() );
+        }
+
+        /**
+         *	This function will create a new file in the current directory, and will write the specified contents to the
+         *	file. Once finished, it will return a new YDFSFile object pointing to the file. All directory paths are
+         *	relative to the current directory.
+         *
+         *	@param $filename	The filename of the new file.
+         *	@param $contents	The contents of the new file.
+         *
+         *	@returns	YDFSFile or YDFSImage object pointing to the new file.
+         */
+        function createFile( $filename, $contents ) {
+
+            // Set the directory of this object as the working directory
+            chdir( $this->getPath() );
+
+            // Create the new file
+            $fp = fopen( $filename, 'wb' );
+
+            // Save the contents to the file
+            $result = fwrite( $fp, $contents );
+
+            // Check for errors
+            if ( $result == false ) {
+                trigger_error(
+                    'Failed writing to the file "' . $filename . '" in the directory called "' . $this->getPath() . '".',
+                    YD_ERROR
+                );
+            }
+
+            // Close the file
+            fclose( $fp );
+
+            // Create the YDFSFile object
+            $obj = new YDFSFile( $filename );
+
+            // Check if it's an image
+            if ( $obj->isImage() ) {
+                $obj = new YDFSImage( $filename );
+            }
+
+            // Return the file object
+            return $obj;
+
+        }
+
+        /**
+         *	This function will delete a file from the current directory.
+         *
+         *	@param $filename	The file you want to delete.
+         *	@param $failOnError	(optional) Indicate if a fatal error needs to be raised if deleting the file failed.
+         *
+         *	@return	There are three possible return values for this function. True indicates that the file exists and
+         *			is deleted successfully. False indicates the file exists but could not be deleted. Null indicates
+         *			the file didn't exist and therefor could not be deleted.
+         */
+        function deleteFile( $filename, $failOnError=false ) {
+
+            // Set the directory of this object as the working directory
+            chdir( $this->getPath() );
+
+            // Check if the file exists
+            if ( file_exists( $filename ) ) {
+
+                // Try to delete the file
+                $result = unlink( $filename );
+
+                // Check for errors
+                if ( $result == false ) {
+
+                    // Check if we need to raise an error
+                    if ( $failOnError == true ) {
+                        trigger_error(
+                            'Failed deleting the file "' . $file . '" from the directory "' . $this->getPath() . '".',
+                            YD_ERROR
+                        );
+                    }
+
+                }
+
+
+                // Return if the file was deleted or not
+                return $result;
+
+            }
+
+            // Return null if the file doesn't exist
+            return null;
+
+        }
+
+        /**
+         *	This function will create a new subdirectory in the given directory.
+         *
+         *	@param $directory	Directory to create.
+         *	@param $mode		(optional) The mode for the directory. By default, this is 0700.
+         *
+         *	@returns	False on failure, otherwise, it will return a YDFSDirectory object for the new directory.
+         */
+        function createDirectory( $directory, $mode=0700 ) {
+            $directory = YDPath::join( $this->getAbsolutePath(), $directory );
+            if ( is_dir( $directory ) || mkdir( $directory, $mode ) ) {
+                return new YDFSDirectory( $directory );
+            } else {
+                return false;
+            }
+        }
+
+
+        /**
+         *  This function will recursively create the directories
+         *	@param $directory	Directory to create.
+         *	@param $mode		(optional) The mode for the directory. By default, this is 0700.
+         *
+         *	@returns	False on failure, otherwise, it will return a YDFSDirectory object for the new directory.
+         *
+         *  @static
+         */
+        function createDirectories( $directory, $mode=0700 ) {
+            if ( is_null( $directory ) || $directory === '' ) {
+                return false;
+            }
+            if ( is_dir( $directory ) || $directory === '/' ) {
+                return true;
+            }
+            if ( YDFSDirectory::createDirectories( dirname( $directory ), $mode ) ) {
+                return mkdir( $directory, $mode );
+            }
+            return false;
+        }
+
+        /**
+         *	This function will recursively delete a directory. It will delete the directory and the complete
+         *	contents of that directory! Be careful I would say!
+         *
+         *	@param $directory	Directory to be removed.
+         *
+         *	@return	Boolean indicating if the directory could be deleted or not.
+         */
+        function deleteDirectory( $directory ) {
+            $directory = YDPath::join( $this->getAbsolutePath(), $directory );
+            if ( ! is_dir( $directory ) ) {
+                return false;
+            }
+            return YDFSDirectory::_delete( $directory );
+        }
+
+        /**
+         *	This function will return true if the filesystem object is a directory. In all other cases, it will return
+         *	false.
+         *
+         *	@returns	Boolean indicating if the object is a directory or not.
+         */
+        function isDirectory() {
+            return true;
+        }
+
+        /**
+         *	This function will return true if the filesystem object is an image. In all other cases, it will return
+         *	false.
+         *
+         *	@returns	Boolean indicating if the object is an image or not.
+         */
+        function isImage() {
+            return false;
+        }
+
+        /**
+         *	This function will move the directory to the specified path and update the object accordingly.
+         *
+         *	@param	$path	Target path.
+         *
+         *	@returns	False on a failure, true on success.
+         */
+        function moveDirectory( $path ) {
+            $result = rename( $this->getAbsolutePath(), $path );
+            if ( $result ) {
+                $this->_path = realpath( $path );
+            }
+            return $result;
+        }
+
+        /**
+         *  This function will check if the specified file/or directory exists in the current path.
+         *
+         *  @param $obj     The file or directory you are looking for.
+         *	@param $classes	(optional) An array with the classes to include. Standard, it includes YDFSImage, YDFSFile
+         *					and YDFSDirectory classes. If you only need a single class, you can also specify it as a
+         *					string.
+         *
+         *	@returns	Array of YDFile objects for the files that match the pattern.
+         */
+        function has( $obj, $classes=array( 'YDFSFile', 'YDFSImage', 'YDFSDirectory' ) ) {
+
+            // Get the contents
+            $contents = $this->getContents( $obj, '', $classes );
+
+            // Return the result
+            return ( sizeof( $contents ) == 0 ) ? false : true;
+
+        }
+
+        /**
+         *	Function to recursively delete a directory.
+         *
+         *	@param $dirname	Directory to be removed.
+         *
+         *	@return	Boolean indicating if the directory could be deleted or not.
+         *
+         *	@internal
+         */
+        function _delete( $dirname ) {
+
+            // Simple delete for a file
+            if ( is_file( $dirname ) ) {
+                return unlink( $dirname );
+            }
+
+            // Loop through the folder
+            $dir = dir( $dirname );
+            while ( false !== $entry = $dir->read() ) {
+
+                // Skip pointers
+                if ( $entry == '.' || $entry == '..' ) {
+                    continue;
+                }
+
+                // Deep delete directories
+                if ( is_dir( "$dirname/$entry" ) ) {
+                    YDFSDirectory::_delete( "$dirname/$entry" );
+                } else {
+                    unlink( "$dirname/$entry" );
+                }
+            }
+
+            // Clean up
+            $dir->close();
+            return rmdir( $dirname );
+
+        }
+
+    }
+
 ?>
\ No newline at end of file



From ximian at mail.berlios.de  Mon Mar 19 17:59:40 2007
From: ximian at mail.berlios.de (ximian at mail.berlios.de)
Date: Mon, 19 Mar 2007 17:59:40 +0100
Subject: [ydf-devel] r2413 - YDFramework2.0/trunk/YDFramework2/YDClasses
Message-ID: <200703191659.l2JGxe0V022646@sheep.berlios.de>

Author: ximian
Date: 2007-03-19 17:59:03 +0100 (Mon, 19 Mar 2007)
New Revision: 2413

Modified:
   YDFramework2.0/trunk/YDFramework2/YDClasses/YDUtil.php
Log:
feature: on YDArrayUtil::convertToNested is now possible to define if we want to append or replace values. Default: append

Modified: YDFramework2.0/trunk/YDFramework2/YDClasses/YDUtil.php
===================================================================
--- YDFramework2.0/trunk/YDFramework2/YDClasses/YDUtil.php	2007-03-05 23:54:09 UTC (rev 2412)
+++ YDFramework2.0/trunk/YDFramework2/YDClasses/YDUtil.php	2007-03-19 16:59:03 UTC (rev 2413)
@@ -1,1339 +1,1346 @@
-<?php
-
-    /*
-
-        Yellow Duck Framework version 2.1
-        (c) Copyright 2002-2007 Pieter Claerhout
-
-        This library is free software; you can redistribute it and/or
-        modify it under the terms of the GNU Lesser General Public
-        License as published by the Free Software Foundation; either
-        version 2.1 of the License, or (at your option) any later version.
-
-        This library is distributed in the hope that it will be useful,
-        but WITHOUT ANY WARRANTY; without even the implied warranty of
-        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
-        Lesser General Public License for more details.
-
-        You should have received a copy of the GNU Lesser General Public
-        License along with this library; if not, write to the Free Software
-        Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
-
-    */
-
-    /**
-     *  @addtogroup YDFramework Core
-     */
-
-    // Check if the framework is loaded
-    if ( ! defined( 'YD_FW_NAME' ) ) {
-        die( 'Yellow Duck Framework is not loaded.' );
-    }
-
-    /**
-     *	This is a general timer class that starts counting when it's instantiated, and which returns the elapsed time as
-     *	soon as the finish method is called.
-     *
-     *  @ingroup YDFramework
-     */
-    class YDTimer extends YDBase {
-
-        /**
-         *	This is the class constructor of the YDTimer class.
-         */
-        function YDTimer() {
-
-            // Initialize YDBase
-            $this->YDBase();
-
-            // Get the start time
-            $this->startTime = $this->_getMicroTime();
-
-            // Keep a list of intermediate times
-            $this->markers = array();
-
-        }
-
-        /**
-         *	This function returns the current microtime as a double.
-         *
-         *	@returns	Double containing the current time.
-         *
-         *	@internal
-         */
-        function _getMicroTime() {
-            $time = explode ( ' ', microtime() );
-            return ( doubleval( $time[0] ) + $time[1] );
-        }
-
-        /**
-         *	This will add a named marker.
-         *
-         *	@param $name	The name to use for the marker
-         */
-        function addMarker( $name ) {
-            array_push( $this->markers, array( $name, $this->getElapsed() ) );
-        }
-
-        /**
-         *	Finish the timer.
-         */
-        function finish() {
-            $this->addMarker( '** Finish' );
-        }
-
-        /**
-         *	This function will return the number of seconds elapsed since the timer was instantiated.
-         *
-         *	@returns	The total elapsed time
-         */
-        function getElapsed() {
-            $endTime = $this->_getMicroTime();
-            return intval( ( $endTime - $this->startTime ) * 1000 );
-        }
-
-        /**
-         *	This function returns a report as an array, with each row containing the following info: elapsed time,
-         *	difference with previous marker and marker name.
-         *
-         *	@returns	Array with the elapsed times, differences and marker names.
-         */
-        function getReport() {
-            $report = array();
-            $report[] = array( 0, 0, '** Start' );
-            $previous = 0;
-            foreach ( $this->markers as $marker ) {
-                $report[] = array( $marker[1], $marker[1]-$previous, $marker[0] );
-                $previous = $marker[1];
-            }
-            return $report;
-        }
-
-    }
-
-    /**
-     *  This class houses all the array related utility functions. All the methods are implemented as static methods and
-     *	do not require you to create a class instance in order to use them.
-     *
-     *  @ingroup YDFramework
-     */
-    class YDArrayUtil extends YDBase {
-
-        /**
-         *  This function will convert a single dimension array to a multi dimension array with the indicated number of
-         *	colums. If the number of columns is 1, it will return the original array.
-         *
-         *  If you enable the $fillLastRow option, it will fill the last row with null values to match the number of
-         *	columns.
-         *
-         *  @param $array		    The single dimension array you want to convert.
-         *  @param $columns		    The number of columns the table should have.
-         *  @param $fillLastRow	    (optional) If true, the last row will be filled with null values so that it matches
-         *						    the number of columns.
-         *  @param $horizontal  	(optional) If true, rows will be filled first, then it will create an new row
-         *
-         *  @returns	A multi-dimension array with the contents of the original array converted to a table with the
-         *				indicated number of colums.
-         *
-         *	@static
-         */
-        function convertToTable( $array, $columns, $fillLastRow=false, $horizontal=true ) {
-
-            // If the number of columns is 1, return the original array
-            if ( $columns == 1 ) {
-                return $array;
-            }
-
-            // Return original array if empty
-            if ( sizeof( $array ) == 0 ) {
-                return $array;
-            }
-
-            // Convert horizontally or vertically
-            if ( $horizontal ) {
-
-                // Use the array_chunk function to convert to a table
-                $newArray = @array_chunk( $array, $columns );
-                if ( $newArray == null ) {
-                    trigger_error( 'Failed to split the array in chunks.', YD_ERROR );
-                }
-
-                // Pad the last row
-                if ( $fillLastRow ) {
-                    $lastRow = $newArray[sizeof( $newArray )-1];
-                    $numMissing = $columns - sizeof( $lastRow );
-                    for ( $i = 0; $i < $numMissing; $i++ ) {
-                        array_push( $newArray[sizeof( $newArray )-1], null );
-                    }
-
-                }
-
-            } else {
-
-                // Get only the values of the array
-                $array = array_values( $array );
-
-                // Check how many rows we will have
-                $rows = ceil( sizeof( $array ) / $columns );
-
-                // Keep track of the current row
-                $currentItem = 0;
-                $currentCol  = 0;
-
-                // Start with a new empty array
-                $newArray = array();
-
-                // Loop over the rows
-                while ( $currentCol < $columns ) {
-                    foreach ( range( 0, $rows-1 ) as $row ) {
-                        $newArray[$row][$currentCol] = isset( $array[$currentItem] ) ? $array[$currentItem] : null;
-                        $currentItem++;
-                    }
-                    $currentCol++;
-                }
-
-            }
-
-            // Return the array
-            return $newArray;
-
-        }
-
-        /**
-         *	This function will create a new array which is a nested using the given column name.
-         *
-         *	@param $array	The array to convert.
-         *	@param $key		The column to use as the key name.
-         *
-         *	@returns	A new array which is a nested using the given column name.
-         *
-         *	@static
-         */
-        function convertToNested( $array, $key ) {
-
-            // Start with the a new array
-            $new = array();
-
-            // Loop over the original array
-            foreach ( $array as $item ) {
-                if ( ! array_key_exists( $key, $item ) ) {
-                    trigger_error( 'YDArrayUtil::convertToNested: key "' . $key . '" not found', YD_ERROR );
-                }
-                if ( ! isset( $new[ $item[ $key ] ] ) ) { $new[ $item[ $key ] ] = array(); }
-                array_push( $new[ $item[ $key ] ], $item );
-            }
-
-            // Return the new array
-            return $new;
-
-        }
-
-        /**
-         *	This function will create a new array which is grouped by a given key and mapped according to a given array.
-         *
-         *	@param $input	The array to convert.
-         *	@param $key		The column to use as the key name.
-         *	@param $map		The array or string which indicates how values of the children arrays should be mapped in
-         *                  the parent array.
-         *
-         *	@returns		The array resulting from the mapping.
-         *
-         *	@static
-         */
-        function map( $input, $key, $map ) {
-
-            // Starting with new array
-            $output = array();
-
-            // Loop over the original array
-            foreach ( $input as $inputFragment ) {
-                if ( isset( $inputFragment[ $key ] ) ) {
-                    if ( is_array($map)) {
-                        foreach ( $map as $mapKey => $mapValue ) {
-                            if ( ! array_key_exists( $key, $inputFragment ) ) {
-                                trigger_error( 'YDArrayUtil::map: key "' . $key . '" not found', YD_ERROR );
-                            }
-                            if ( isset( $inputFragment[ $mapKey ] ) && isset( $inputFragment[ $mapValue ] ) ) {
-                                $output[ $inputFragment[ $key ] ][ $inputFragment[ $mapKey ] ] = $inputFragment[ $mapValue ];
-                            }
-                            else {
-                                $output[ $inputFragment[ $key ] ][ $inputFragment[ $mapKey ] ] = NULL;
-                            }
-                        }
-                    }
-                    else {
-                        $output[ $inputFragment[ $key ] ] = $inputFragment[ $map ];
-                    }
-                }
-            }
-
-            // Return the new array
-            return $output;
-        }
-
-        /**
-         *  This function will implode a 1-level array in a string.
-         *
-         *  @param $input      The array to implode.
-         *  @param $glue       (optional) The key/value glue. Default: =
-         *  @param $separator  (optional) The items separator. Default: ,
-         *
-         *  @returns       The imploded string.
-         *
-         *  @static
-         */
-        function implode( $input, $glue='=', $separator=',' ) {
-            $return = '';
-            foreach ( $input as $k => $v ) {
-                $return .= $separator . $k . $glue . $v;
-            }
-            return substr( $return, 1 );
-        }
-
-        /**
-         *  This function will initialize the indicated array if it doesn't exist yet.
-         *
-         *  @param  $where  Where to instantiate the array in.
-         *  @param  $name   The name of the array to create.
-         *
-         *  @static
-         */
-        function createIfNeeded( & $where, $name ) {
-            if ( ! isset( $where[$name] ) ) {
-                $where[$name] = array();
-            }
-        }
-
-
-        /**
-         *  This function will return a array with gmts.
-         *
-         *  @param $format      Format to return
-         *
-         *  @returns	Array. If format is NULL returns complete array.
-         *                                  'simple' returns: array( -11 => '(GMT -11:00)', -10 => ...
-         *                                  'full'   returns: array( -11 => '(GMT -11:00) Nome, Midway Island, Samoa', -10 => ...
-         *  @static
-         */
-        function getGMT( $format = null ){
-            $gmts = array(
-                '-11'   => array( '(GMT -11:00)', 'Nome, Midway Island, Samoa' ),
-                '-10'   => array( '(GMT -10:00)', 'Hawaii' ),
-                 '-9'   => array( '(GMT  -9:00)', 'Alaska' ),
-                 '-8'   => array( '(GMT  -8:00)', 'Pacific Time' ),
-                 '-7'   => array( '(GMT  -7:00)', 'Mountain Time' ),
-                 '-6'   => array( '(GMT  -6:00)', 'Central Time, Mexico City' ),
-                 '-5'   => array( '(GMT  -5:00)', 'Eastern Time, Bogota, Lima, Quito' ),
-                 '-4'   => array( '(GMT  -4:00)', 'Atlantic Time, Caracas, La Paz' ),
-                 '-3.5' => array( '(GMT  -3:30)', 'Newfoundland' ),
-                 '-3'   => array( '(GMT  -3:00)', 'Brazil, Buenos Aires, Georgetown, Falkland Is.' ),
-                 '-2'   => array( '(GMT  -2:00)', 'Mid-Atlantic, Ascention Is., St Helena' ),
-                 '-1'   => array( '(GMT  -1:00)', 'Azores, Cape Verde Islands' ),
-                  '0'   => array( '(GMT   0:00)', 'Casablanca, Dublin, Edinburgh, London, Lisbon, Monrovia' ),
-                  '1'   => array( '(GMT  +1:00)', 'Berlin, Brussels, Copenhagen, Madrid, Paris, Rome' ),
-                  '2'   => array( '(GMT  +2:00)', 'Kaliningrad, South Africa, Warsaw' ),
-                  '3'   => array( '(GMT  +3:00)', 'Baghdad, Riyadh, Moscow, Nairobi' ),
-                  '2.5' => array( '(GMT  +3:30)', 'Tehran' ),
-                  '4'   => array( '(GMT  +4:00)', 'Abu Dhabi, Baku, Muscat, Tbilisi' ),
-                  '4.5' => array( '(GMT  +4:30)', 'Kabul' ),
-                  '5'   => array( '(GMT  +5:00)', 'Islamabad, Karachi, Tashkent' ),
-                  '5.5' => array( '(GMT  +5:30)', 'Bombay, Calcutta, Madras, New Delhi' ),
-                  '6'   => array( '(GMT  +6:00)', 'Almaty, Colombo, Dhaka' ),
-                  '7'   => array( '(GMT  +7:00)', 'Bangkok, Hanoi, Jakarta' ),
-                  '8'   => array( '(GMT  +8:00)', 'Beijing, Hong Kong, Perth, Singapore, Taipei' ),
-                  '9'   => array( '(GMT  +9:00)', 'Osaka, Sapporo, Seoul, Tokyo, Yakutsk' ),
-                  '9.5' => array( '(GMT  +9:30)', 'Adelaide, Darwin' ),
-                 '10'   => array( '(GMT +10:00)', 'Melbourne, Papua New Guinea, Sydney, Vladivostok' ),
-                 '11'   => array( '(GMT +11:00)', 'Magadan, New Caledonia, Solomon Islands' ),
-                 '12'   => array( '(GMT +12:00)', 'Auckland, Wellington, Fiji, Marshall Island' )
-            );
-            if ( is_null( $format ) ) {
-                return $gmts;
-            }
-            foreach( $gmts as $t => $arr ){
-                if ( $format == 'simple' ) $gmts[ $t ] = $arr[ 0 ];
-                else                       $gmts[ $t ] = $arr[ 0 ] . ' ' . $arr[ 1 ];
-            }
-            return $gmts;
-        }
-
-        /**
-         *  This function will convert a database result array to XML
-         *
-         *  @param $array      The input array.
-         *
-         *  @returns       The array as an XML string.
-         *
-         *  @static
-         */
-        function toXml( $array ) {
-            $out = '';
-            foreach ( $array as $record ) {
-                $out .= sprintf( '<row>' );
-                foreach ( $record as $key=>$val ) {
-                    if ( is_numeric( $val ) ) {
-                        $out .= sprintf( '<%s>%s</%s>', $key, $val, $key );
-                    } else {
-                        $out .= sprintf( '<%s><![CDATA[%s]]></%s>', $key, $val, $key );
-                    }
-                }
-                $out .= sprintf( '</row>' );
-            }
-            $out = sprintf( '<root>%s</root>', $out );
-            return '<?xml version="1.0" encoding="utf-8"?>' . $out;
-        }
-
-    }
-
-    /**
-     *	This class houses all the debug related utility functions. All the methods are implemented as static methods and
-     *	do not require you to create a class instance in order to use them.
-     *
-     *  @ingroup YDFramework
-     */
-    class YDDebugUtil extends YDBase {
-
-        /**
-         *  Trigger an error
-         *
-         *  @param  $msg    The error to raise.
-         *  @param  $sql    (optional) The SQL statement to log with the error.
-         *  @param  $level  (optional) The type of error to be raised. Default is YD_ERROR.
-         */
-        function error( $msg, $sql=null, $level=YD_ERROR ) {
-            echo( '<p><b><font color="red">An error occured</font></b></p>' );
-            echo( '<b>Stacktrace:</b> <pre>' . YDDebugUtil::getStackTrace() . '</pre>' );
-            if ( ! empty( $sql ) ) {
-                echo( '<b>SQL Statement:</b> <pre>' . $this->formatSql( $sql ) . '</pre>' );
-            }
-            trigger_error( $msg, $level );
-        }
-
-        /**
-         *	Function to output a debug message. These message are only shown if the constant YD_DEBUG is set to 1. You
-         *	can turn on debugging by specifying the YD_DEBUG parameter in the url and assigning it the value 1.
-         *
-         *	Example url with debugging turned on: http://localhost/index.php?YD_DEBUG=1
-         *
-         *	This function accepts a variable amount of arguments which are all concatenated using a space in between.
-         *	All debug messages will be shown as HTML comments with the prefix "[ YD_DEBUG ]".
-         *
-         *	@static
-         */
-        function debug() {
-            $args = func_get_args();
-            if ( YDConfig::get( 'YD_DEBUG' ) == 1 ) {
-                echo( YD_CRLF . '<!-- [ YD_DEBUG ] ' . implode( ' ', $args ) . '-->' . YD_CRLF );
-            }
-            if ( YDConfig::get( 'YD_DEBUG' ) == 2 ) {
-                echo( '<table border="0" cellspacing="0" cellpadding="4"><tr>' );
-                echo( '<td bgcolor="#FFCC00">' );
-                echo( '<b>' . YD_FW_NAME . ' Debug Information</b> ' );
-                echo( '<pre>' . htmlspecialchars( trim( implode( ' ', $args ) ) ) . '</pre>' );
-                echo( '</td></tr></table>' );
-            }
-        }
-
-        /**
-         *	Function to dump the contents of pretty much anything. This is the same as the var_dump function in PHP, but
-         *	has a nicer and more readable output.
-         *
-         *	@param $obj		Object you want to dump.
-         *	@param $label	The label for the dump.
-         *
-         *	@static
-         */
-        function dump( $obj, $label='' ) {
-            echo( YDDebugUtil::r_dump( $obj, true, $label ) );
-        }
-
-        /**
-         *	Function to return the contents of pretty much anything. This is the same as the var_export function in PHP.
-         *
-         *	@param $obj		Object you want to dump.
-         *	@param $html	(optional) If you want to have everything returned as HTML or text. The default is false,
-         *					returning text.
-         *	@param $label	The label for the dump.
-         *
-         *	@returns	Text representation of the object.
-         *
-         *	@static
-         */
-        function r_dump( $obj, $html=false, $label='' ) {
-            $data = var_export( $obj, true );
-            if ( $html == true ) {
-                $data = stripslashes( htmlentities( $data ) );
-                $style = ' style="text-align: left; font-size: 10pt;"';
-                if ( ! empty( $label ) ) {
-                    $data = '<pre' . $style . '><b style="color: navy">' . $label . '</b><br>' . $data . '</pre>';
-                } else {
-                    $data = '<pre' . $style . '>' . $data . '</pre>';
-                }
-            } else {
-                $data = $label . YD_CRLF . $data;
-            }
-            return $data;
-        }
-
-        /**
-         *	This function will print a stack trace.
-         *
-         *	@static
-         */
-        function stackTrace() {
-            if ( YDConfig::get( 'YD_DEBUG' ) == 1 || YDConfig::get( 'YD_DEBUG' ) == 2 ) {
-                $err = 'URI: ' . YD_SELF_URI . YD_CRLF . YDDebugUtil::getStackTrace();
-                if ( ini_get( 'display_errors' ) == 1 ) {
-                    echo( '<pre>' . YD_CRLF . htmlentities( $err ) . '</pre>' );
-                }
-                error_log( $err, 0 );
-            }
-        }
-
-        /**
-         *	Function to get a formatted stack trace.
-         *
-         *	@static
-         */
-        function getStackTrace() {
-            $err = '';
-            $err .= 'Debug backtrace:' . YD_CRLF;
-            foreach( debug_backtrace() as $t ) {
-                $err .= '    @ ';
-                if ( isset( $t['file'] ) ) {
-                    $err .= basename( $t['file'] ) . ':' . $t['line'];
-                } else {
-                    $err .= basename( YD_SELF_FILE );
-                }
-                $err .= ' -- ';
-                if ( isset( $t['class'] ) ) {
-                    $err .= $t['class'] . $t['type'];
-                }
-                $err .= $t['function'];
-                if ( isset( $t['args'] ) && sizeof( $t['args'] ) > 0 ) {
-                    $err .= '(...)';
-                } else {
-                    $err .= '()';
-                }
-                $err .= YD_CRLF;
-            }
-            return $err;
-        }
-
-    }
-
-    /**
-     *	This class houses all the object and class related utility functions. All the methods are implemented as static
-     *	methods and do not require you to create a class instance in order to use them.
-     *
-     *  @ingroup YDFramework
-     */
-    class YDObjectUtil extends YDBase {
-
-        /**
-         *	This function checks if an object instance is of a specific class or is based on a derived class of the
-         *	given class. The class name is case insensitive.
-         *
-         *	@param $obj		The object instance to check.
-         *	@param $class	The object type you want to check against.
-         *
-         *	@returns	Boolean indicating if the object is of the specified class.
-         *
-         *	@static
-         */
-        function isSubClass( $obj, $class ) {
-            $class = strtolower( $class );
-            if ( function_exists( 'is_a' ) ) {
-                return is_a( $obj, $class );
-            } else {
-                if ( is_object( $obj ) ) {
-                    if ( strtolower( get_class( $obj ) ) == strtolower( $class ) ) return true;
-                    if ( is_subclass_of( $obj, $class ) ) return true;
-                }
-            }
-            return false;
-        }
-
-        /**
-         *	Function to get all the ancestors of a class. The list will contain the parent class first, and then it's
-         *	parent class, etc. You can pass both the name of the class or an object instance to this function
-         *
-         *	@param $classname	Name of the class or object.
-         *
-         *	@returns	Array with all the ancestors.
-         *
-         *	@static
-         */
-        function getAncestors( $classname ) {
-            if ( is_object( $classname ) ) {
-                $classname = strtolower( get_class( $classname ) );
-            }
-            $ancestors = array();
-            $father = get_parent_class( $classname );
-            if ( $father != '' ) {
-                $ancestors = YDObjectUtil::getAncestors( $father );
-                $ancestors[] = $father;
-            }
-            return array_reverse( $ancestors );
-        }
-
-        /**
-         *	This function will serialize an object.
-         *
-         *	@param $obj	Object to serialize.
-         *
-         *	@static
-         */
-        function serialize( $obj ) {
-            $obj = serialize( $obj );
-            if ( ! $obj ) {
-                trigger_error( 'Failed serializing the object', YD_ERROR );
-            }
-            return $obj;
-        }
-
-        /**
-         *	This function will unserialize an object.
-         *
-         *	@param $obj	Object to unserialize.
-         *
-         *	@static
-         */
-        function unserialize( $obj ) {
-            $obj = unserialize( $obj );
-            if ( ! $obj ) {
-                trigger_error( 'Failed unserializing the object', YD_ERROR );
-            }
-            return $obj;
-        }
-
-    }
-
-    /**
-     *	This class houses all the string related utility functions. All the methods are implemented as static methods
-     *	and do not require you to create a class instance in order to use them.
-     *
-     *  @ingroup YDFramework
-     */
-    class YDStringUtil extends YDBase {
-
-        /**
-         *	Function to format a file size to a meaningful value.
-         *
-         *	@param $bytes		The file size to format.
-         *	@param $decimals	(optional) The number of decimals that should be returned.
-         *
-         *	@returns String containing the formatted file size.
-         *
-         *	@static
-         */
-        function formatFilesize( $bytes, $decimals=1 ) {
-
-            // Convert the bytes to a string
-            $bytes = strval( $bytes );
-
-            // The different units
-            $units = array(
-                '1152921504606846976'	=> 'EB',
-                '1125899906842624'		=> 'PB',
-                '1099511627776'			=> 'TB',
-                '1073741824'			=> 'GB',
-                '1048576'				=> 'MB',
-                '1024'					=> 'KB'
-            );
-
-            // If smaller than 1024, return it as bytes
-            if ( $bytes <= 1024 ) {
-                return $bytes . ' bytes';
-            }
-
-            // Check the right format
-            foreach ( $units as $base=>$title ) {
-                if ( floor( $bytes / $base ) != 0 ) {
-                    return number_format( $bytes / $base, $decimals, '.', "'" ) . ' ' . $title;
-                }
-            }
-
-        }
-
-        /**
-         *  This function will format a timestamp using the strftime function.
-         *
-         *  @param  $timestamp  The timestamp to format. It can also be a date/time form object.
-         *  @param  $format     The strftime format to use. You can also use the predefined options date, time and
-         *                      datetime.
-         *  @param  $locale     (optional) The locale to use to format the date.
-         *
-         *  @returns    A formatted timestamp
-         *
-         *  @static
-         */
-        function formatDate( $timestamp, $format, $locale=null ) {
-
-            // Check if the timestamp is an object and has the getTimeStamp function
-            if ( is_object( $timestamp ) && method_exists( $timestamp, 'getTimeStamp' ) ) {
-                $timestamp = $timestamp->getTimeStamp();
-            }
-
-            // Convert to an integer
-            if ( is_numeric( $timestamp ) ) {
-                $timestamp = intval( $timestamp );
-            }
-
-            // If text, convert to number
-            if ( is_string( $timestamp ) ) {
-                $timestamp = strtotime( $timestamp );
-            }
-
-            // If array, is a date YDForm element value
-            if ( is_array( $timestamp ) ) {
-
-                // check if timestamp exists. otherwise create it
-                $hours   = isset( $timestamp[ 'hours' ] ) ?   $timestamp[ 'hours' ] : 0;
-                $minutes = isset( $timestamp[ 'minutes' ] ) ? $timestamp[ 'minutes' ] : 0;
-                $seconds = isset( $timestamp[ 'seconds' ] ) ? $timestamp[ 'seconds' ] : 0;
-                $month   = isset( $timestamp[ 'month' ] ) ?   $timestamp[ 'month' ] : 1;
-                $day     = isset( $timestamp[ 'day' ] ) ?     $timestamp[ 'day' ] : 1;
-                $year    = isset( $timestamp[ 'year' ] ) ?    $timestamp[ 'year' ] : 1970;
-                $timestamp = mktime( $hours, $minutes, $seconds, $month, $day, $year );
-            }
-
-            // Check the standard formats
-            if ( strtolower( $format ) == 'date' ) {
-                $format = '%d %B %Y';
-            }
-            if ( strtolower( $format ) == 'datetime' ) {
-                $format = '%d %B %Y %H:%M';
-            }
-            if ( strtolower( $format ) == 'datetimesql' ) {
-                $format = '%Y-%m-%d %H:%M:%S';
-            }
-            if ( strtolower( $format ) == 'time' ) {
-                $format = '%H:%M';
-            }
-            if ( strtolower( $format ) == 'file' ) {
-                $format = '%d-%m-%Y %H:%M';
-            }
-
-            // Set the new locale
-            if ( ! is_null( $locale ) ) {
-                $currentLocale = YDLocale::get();
-                YDLocale::set( $locale );
-            }
-
-            // Return the formatted date
-            $timestamp = strftime( $format, $timestamp );
-
-            // Reset the old locale
-            if ( ! is_null( $locale ) ) {
-                YDLocale::set( $currentLocale );
-            }
-
-            // Return the timestamp
-            return $timestamp;
-
-        }
-
-        /**
-         *	This function will encode all characters which have an ordinal bigger than 128 to numeric HTML entities,
-         *	which can be safely included in e.g. XML output.
-         *
-         *	@param $string	The original string to encode.
-         *	@param $htmlent	Boolean indicating if the result should be HTML encoded or not.
-         *
-         *	@returns	String with all the characters with an ordinal bigger than 128 converted to numeric entities.
-         *
-         *	@static
-         */
-        function encodeString( $string, $htmlent=false ) {
-            $trans = array_flip( get_html_translation_table( HTML_ENTITIES ) );
-            $string = strtr( $string, $trans );
-            $trans = get_html_translation_table( HTML_ENTITIES, ENT_NOQUOTES );
-            foreach ( $trans as $key => $value ) {
-                if ( ord( $key ) == 60 || ord( $key ) == 62 || ord( $key ) == 38 ) {
-                    unset( $trans[$key] );
-                } else {
-                    $trans[$key] = '&#' . ord( $key ) . ';';
-                }
-            }
-            $string = strtr( $string, $trans );
-            if ( $htmlent == true ) {
-                $string = htmlentities( $string );
-            }
-            return $string;
-        }
-
-        /**
-         *   This function will encode all characters in a string to it's ASCII value.
-         *
-         *   @param $string   The original string to encode.
-         *
-         *   @returns   The encoded string.
-         *
-         *   @static
-         */
-        function encodeToAscii( $string ) {
-            $result = '';
-            for ( $i=0; $i < strlen( $string ); $i++ ) {
-                $result .= "&#" . ord( substr( $string, $i, 1) ) . ';';
-            }
-            return $result;
-        }
-
-        /**
-         *	This function will truncate a string.
-         *
-         *	@param $string		String to truncate.
-         *	@param $length		(optional) The length to truncate to. Default length is 80 characters.
-         *	@param $etc			(optional) The string to append if the item gets trunctated. Default is '...'.
-         *	@param $break_words	(optional) Break in the middle of words or not. Default is false.
-         *
-         *	@static
-         */
-        function truncate( $string, $length=80, $etc='...', $break_words=false ) {
-            if ( $length == 0 ) { return ''; }
-            if ( strlen( $string ) > $length ) {
-                $string = html_entity_decode( strip_tags( $string ) );
-                $length -= strlen( $etc );
-                if ( ! $break_words ) {
-                    $string = preg_replace( '/\s+?(\S+)?$/', '', substr( $string, 0, $length+1 ) );
-                }
-                return htmlentities( substr( $string, 0, $length ) . $etc );
-            } else {
-                return $string;
-            }
-        }
-
-        /**
-         *	This function normalizes all the newlines to the correct newline character for the current platform.
-         *
-         *	@param $string		String to normalize the newlines from.
-         *
-         *	@returns	The original string with normalized newlines.
-         *
-         *	@static
-         */
-        function normalizeNewlines( $string ) {
-
-            // First, change all to \n
-            $string = str_replace( "\r\n", "\n",    $string );
-            $string = str_replace( "\r",   "\n",    $string );
-
-            // Now, change everything to the correct one
-            $string = str_replace( "\n",   YD_CRLF, $string );
-
-            // Return the changed string
-            return $string;
-
-        }
-
-        /**
-         *	This function will remove all newlines and all spaces at the beginning and end of each line.
-         *
-         *	@param $string		String to remove the whitespace from.
-         *
-         *	@returns	The original string without the newlines and spaces at the beginning and end of each line.
-         *
-         *	@static
-         */
-        function removeWhiteSpace( $string ) {
-
-            // First, normalize the newlines
-            $string = YDStringUtil::normalizeNewLines( $string );
-
-            // Now, remove the whitespace
-            $string = implode( ' ', array_map( 'trim', explode( YD_CRLF, $string ) ) );
-
-            // Return the changed string
-            return $string;
-
-        }
-
-        /**
-         *   This function will compare two network ip addresses
-         *
-         *   @param $ip1      First ip
-         *
-         *   @param $ip2      Second ip
-         *
-         *   @returns    Returns < 0 if ip1 is less than ip2; > 0 if str1 is greater than ip2, and 0 if they are equal.
-         *
-         *   @static
-         */
-        function ipcmp( $ip1, $ip2 ){
-
-            // get 4 elements from the network address
-            $ip1 = explode(".", $ip1);
-            $ip2 = explode(".", $ip2);
-
-            // get an integer that represents the numeric value of the address
-            $ip1 = $ip1[0]*256^3 + $ip1[1]*256^2 + $ip1[2]*256 + $ip1[3];
-            $ip2 = $ip2[0]*256^3 + $ip2[1]*256^2 + $ip2[2]*256 + $ip2[3];
-
-            // return diference
-            return $ip1 - $ip2;
-
-        }
-
-        /**
-         *  This function will replace all special characters to normal ASCII characters. This is very useful when you
-         *  want to rename uploaded files and strip out the special characters.
-         *
-         *  @param  $data   The data to strip the special characters from.
-         *
-         *  @returns    The data with the special characters replaced.
-         *
-         *  @static
-         */
-        function stripSpecialCharacters( $data ) {
-
-            // Trim the data
-            $data = trim( $data );
-
-            // Decode the HTML entities
-            $trans = array_flip( get_html_translation_table( HTML_ENTITIES, ENT_NOQUOTES ) );
-            $data = strtr( $data, $trans );
-
-            // The characters to replace
-            $chars = array(
-                '?' => 'A', '?' => 'A', '?' => 'A', '?' => 'AE', '?' => 'E', '?' => 'E', '?' => 'I', '?' => 'I',
-                '?' => 'D', '?' => 'O', '?' => 'O', '?' => 'O', '?' => 'O', '?' => 'U', '?' => 'U', '?' => 'a',
-                '?' => 'a', '?' => 'a', '?' => 'ae', '?' => 'e', '?' => 'e', '?' => 'i', '?' => 'i', '?' => 'o',
-                '?' => 'o', '?' => 'o', '?' => 'o', '?' => 'o', '?' => 'u', '?' => 'u', '?' => 'A', '?' => 'A',
-                '?' => 'A', '?' => 'C', '?' => 'E', '?' => 'E', '?' => 'I', '?' => 'I', '?' => 'N', '?' => 'O',
-                '?' => 'O', '?' => 'U', '?' => 'U',  '?' => 'Y', '?' => 'B', '?' => 'a', '?' => 'a', '?' => 'a',
-                '?' => 'c', '?' => 'e', '?' => 'e', '?' => 'i', '?' => 'i', '?' => 'n', '?' => 'o', '?' => 'o',
-                '?' => 'u', '?' => 'u', '?' => 'y', '?' => 'y', '@' => '_', ' ' => '_', '[' => '_', ']' => '_',
-                '(' => '_', ')' => '_', '&' => '_', '+' => '_', '=' => '_'
-            );
-
-            // Strip the special characters
-            $data = str_replace( array_keys( $chars ), $chars, $data );
-
-            // Return the data
-            return $data;
-
-        }
-
-        /**
-         *  This function will check if the specified string starts with the indicated text or not. You can specify if
-         *  this needs to happen case-sensitively or not.
-         *
-         *  @param  $string         The string to check.
-         *  @param  $substring      The string with which it needs to start.
-         *  @param  $case_sensitive (optional) Whether the comparison needs to be case-sensitive or not. Default is true.
-         *
-         *  @returns    Boolean indicating if the string starts with the specified text or not.
-         */
-        function startsWith( $string, $substring, $case_sensitive=true ) {
-            if ( ! $case_sensitive ) {
-                $string = strtolower( $string );
-                $substring = strtolower( $substring );
-            }
-            return ( substr( $string, 0, strlen( $substring ) ) == $substring );
-        }
-
-        /**
-         *  This function will check if the specified string ends with the indicated text or not. You can specify if
-         *  this needs to happen case-sensitively or not.
-         *
-         *  @param  $string         The string to check.
-         *  @param  $substring      The string with which it needs to ends.
-         *  @param  $case_sensitive (optional) Whether the comparison needs to be case-sensitive or not. Default is true.
-         *
-         *  @returns    Boolean indicating if the string ends with the specified text or not.
-         */
-        function endsWith( $string, $substring, $case_sensitive=true ) {
-            if ( ! $case_sensitive ) {
-                $string = strtolower( $string );
-                $substring = strtolower( $substring );
-            }
-            return ( substr( $string, -strlen( $substring ) ) == $substring );
-        }
-
-        /**
-         *  This function is an fnmatch replacement.
-         *
-         *  $param $string      The string to test
-         *  $param $pattern     The pattern to match
-         *
-         *  @returns    Boolean indicating if the string matches the pattern or not.
-         */
-        function match( $string, $pattern ) {
-            for ( $op = 0, $npattern = '', $n = 0, $l = strlen( $pattern ); $n < $l; $n++ ) {
-            switch ($c = $pattern[$n]) {
-                case '\\':
-                    $npattern .= '\\' . @$pattern[++$n];
-                    break;
-                case '.':
-                case '+':
-                case '^':
-                case '$':
-                case '(':
-                case ')':
-                case '{':
-                case '}':
-                case '=':
-                case '!':
-                case '<':
-                case '>':
-                case '|':
-                    $npattern .= '\\' . $c;
-                    break;
-                case '?': case '*':
-                    $npattern .= '.' . $c;
-                    break;
-                case '[':
-                case ']':
-                default:
-                    $npattern .= $c;
-                    if ($c == '[') {
-                        $op++;
-                    } else if ($c == ']') {
-                        if ($op == 0) return false;
-                            $op--;
-                        }
-                        break;
-                    }
-            }
-            if ( $op != 0 ) {
-                return false;
-            } else {
-                return preg_match( '/' . $npattern . '/i', $string );
-            }
-        }
-
-        /**
-         *  Show the time that has elapsed since a given time.
-         *
-         *  @param  $time   The time in seconds
-         *
-         *  @returns    The elapsed time
-         */
-        function timesince( $time ) {
-
-            // Convert to integer
-            if ( is_string( $time ) && is_numeric( $time ) ) {
-                $time = intval( $time );
-            }
-
-            // Array of time period chunks
-            $chunks = array(
-                array( 60 * 60 * 24 * 365 , t('years') ),
-                array( 60 * 60 * 24 * 30 , t('months') ),
-                array( 60 * 60 * 24 * 7, t('weeks') ),
-                array( 60 * 60 * 24 , t('days') ),
-                array( 60 * 60 , t('hours') ),
-                array( 60 , t('minutes') ),
-            );
-
-            // Difference in seconds
-            $since = time() - $time;
-
-            // The first chunk
-            for ( $i = 0, $j = sizeof( $chunks ); $i < $j; $i++ ) {
-                $seconds = $chunks[$i][0];
-                $name = $chunks[$i][1];
-                if ( ( $count = floor( $since / $seconds ) ) != 0 ) {
-                    break;
-                }
-            }
-
-            // Set output var
-            $output = ( $count == 1 ) ? '1 '.$name : $count . ' ' . $name;
-
-            // step two: the second chunk
-            if ( $i + 1 < $j ) {
-                $seconds2 = $chunks[$i + 1][0];
-                $name2 = $chunks[$i + 1][1];
-                if ( ( $count2 = floor( ( $since - ( $seconds * $count ) ) / $seconds2 ) ) != 0 ) {
-                    $output .= ($count2 == 1) ? ', 1 '.$name2 : ", $count2 {$name2}s";
-                }
-            }
-
-            // Return the output
-            return $output . ' ' . t('ago');
-
-        }
-
-    }
-
-    /**
-     *	This class uses the HTTP_USER_AGENT varaible to get information about the browser the visitor used to perform
-     *	the request. We determine the browser name, the version and the platform it's running on.
-     *
-     *  @ingroup YDFramework
-     */
-    class YDBrowserInfo extends YDBase {
-
-        /**
-         *	The class constructor analyzes for the YDBrowserInfo class. The constructor takes no arguments and uses the
-         *	$_SERVER['HTTP_USER_AGENT'] variable to parse the browser info.
-         */
-        function YDBrowserInfo() {
-
-            // Initialize YDBase
-            $this->YDBase();
-
-            // The matching list for browsers
-            $browsers = array(
-                'bot'       => array( 'bot', 'Yahoo! Slurp', 'crawler', 'scooter', 'mercator', 'altavista', 'Gulliver', 'spider', 'Ask Jeeves' ),
-                'opera'     => array( 'opera' ),
-                'ie'        => array( 'msie' ),
-                'safari'    => array( 'safari' ),
-                'konqueror' => array( 'Konqueror' ),
-                'feed'      => array( 'feed', 'rss', 'synd', 'bloglines', 'newsgator' ),
-                'mozilla'   => array( 'mozilla', 'firefox' ),
-            );
-
-            // The matching list for platforms
-            $platforms = array(
-                'win'       => array( 'win' ),
-                'mac'       => array( 'mac', 'apple' ),
-                'linux'     => array( 'linux', 'bsd' ),
-                'unix'      => array( 'unix', 'sun', 'risc', 'aix' ),
-                'bot'       => array( 'bot', 'Yahoo! Slurp', 'crawler' ),
-                'feed'      => array( 'feed', 'rss', 'synd', 'bloglines', 'newsgator' ),
-            );
-
-            // Mark everything as unknown
-            $this->agent = 'unknown';
-            $this->browser = 'unknown';
-            $this->platform = 'unknown';
-            $this->dotnet = 'unknown';
-
-            // Check if the user agent was specified
-            if ( isset( $_SERVER['HTTP_USER_AGENT'] ) ) {
-
-                // Get the user agent
-                $this->agent = $_SERVER['HTTP_USER_AGENT'];
-
-                // Get the browser name
-                foreach ( $browsers as $browser => $browserpatterns ) {
-                    foreach ( $browserpatterns as $browserpattern ) {
-                        if ( stristr( $this->agent, $browserpattern ) ) {
-                            $this->browser = $browser;
-                            continue;
-                        }
-                    }
-                    if ( $this->browser != 'unknown' ) {
-                        break;
-                    }
-                }
-
-                // Get the browser name
-                foreach ( $platforms as $platform => $platformpatterns ) {
-                    foreach ( $platformpatterns as $platformpattern ) {
-                        if ( stristr( $this->agent, $platformpattern ) ) {
-                            $this->platform = $platform;
-                            continue;
-                        }
-                    }
-                    if ( $this->platform != 'unknown' ) {
-                        break;
-                    }
-                }
-
-                // Get the .NET runtime version
-                preg_match_all( '/.NET CLR ([0-9][.][0-9])/i', $this->agent, $ver );
-                $this->dotnet = $ver[1];
-
-            }
-
-        }
-
-        /**
-         *  Get the hostname of the client computer.
-         *
-         *  @returns The hostname of the client computer in lowercase.
-         *
-         *  @static
-         */
-        function getComputerName() {
-            return strtolower( gethostbyaddr( $_SERVER['REMOTE_ADDR'] ) );
-        }
-
-        /**
-         *	This function returns an array with the languages that are supported by the browser. This is done by using
-         *	the HTTP_ACCEPT_LANGUAGE server variable that gets send with the HTTP headers.
-         *
-         *	@return Array containing the list of supported languages
-         */
-        function getBrowserLanguages() {
-
-            // We parse the language headers sent by the browser
-            if ( ! isset( $_SERVER['HTTP_ACCEPT_LANGUAGE'] ) ) {
-                return array();
-            }
-            $browserLanguages = explode( ',', $_SERVER['HTTP_ACCEPT_LANGUAGE'] );
-
-            // Normalize the browser language headers
-            for ( $i = 0; $i < sizeof( $browserLanguages ); $i++ ) {
-                $browserLanguage = explode( ';', $browserLanguages[$i] );
-                $browserLanguages[$i] = substr( $browserLanguage[0], 0, 2 );
-            }
-
-            // Remove the duplicates
-            $browserLanguages = array_unique( $browserLanguages );
-
-            // Return the browser languages
-            return array_map( 'strtolower', array_values( $browserLanguages ) );
-
-        }
-
-        /**
-         *  This function returns an array with the languages that are supported by the browser and also interprets the
-         *  country information that the browser sends over.. This is done by using the HTTP_ACCEPT_LANGUAGE server
-         *  variable that gets send with the HTTP headers.
-         *
-         *  @return Array containing the list of supported languages
-         */
-        function getBrowserLanguagesAndCountries() {
-
-            // We parse the language headers sent by the browser
-            if ( !isset( $_SERVER['HTTP_ACCEPT_LANGUAGE'] ) ) {
-                return array();
-            }
-            $browserCountries = explode( ',', $_SERVER['HTTP_ACCEPT_LANGUAGE'] );
-            $languagesAndCountries = array();
-
-            // Loop over the languages and normalize them
-            foreach( $browserCountries as $value ) {
-                $lang = explode( ';', $value );
-                $lang = explode( '-', $lang[0] );
-                $lang[1] = ( isset( $lang[1] ) && $lang[1] != '' ? $lang[1] : $lang[0] );
-                $languagesAndCountries[][ $lang[1] ] = $lang[0];
-            }
-
-            // Return the normalized list
-            return $languagesAndCountries;
-
-        }
-
-        /**
-         *	This function will get the most appropriate language for the browser, considering the list of supported
-         *	languages by both the browser and the web application.
-         *
-         *	@param $supported	(optional) An array with the list of supported languages. By default, only english is
-         *						supported.
-         */
-        function getLanguage( $supported=array( 'en' ) ) {
-
-            // Start with the default language
-            $language = $supported[0];
-
-            // Get the list of languages supported by the browser
-            $browserLanguages = $this->getBrowserLanguages();
-
-            // Now, we look if the browser specified one
-            if ( isset( $_SERVER['HTTP_ACCEPT_LANGUAGE'] ) ) {
-                foreach ( $browserLanguages as $browserLanguage ) {
-                    if ( in_array( $browserLanguage, $supported ) ) {
-                        $language = $browserLanguage;
-                        break;
-                    }
-                }
-            }
-
-            // Return the language
-            return $language;
-
-        }
-
-    }
-
-    /**
-     *  This class allows you to generate GUIDs (global unique identifier).
-     *
-     *  More info: http://www.ietf.org/rfc/rfc4122.txt
-     *
-     *  @ingroup YDFramework
-     */
-    class YDGuidUtil extends YDBase {
-
-        /**
-         *  Generate a new GUID.
-         *
-         *  @returns    A new GUID as a string.
-         */
-        function create() {
-            return md5( uniqid( rand(), true ) . $_SERVER['SERVER_NAME'] . $_SERVER['SERVER_ADDR'] );
-        }
-
-        /**
-         *  Generate a new formatted GUID.
-         *
-         *  @returns    A formatted GUID as a string.
-         */
-        function createFormatted() {
-            return YDGuidUtil::format( YDGuidUtil::create() );
-        }
-
-        /**
-         *  Formats a GUID.
-         *
-         *  @param $g    GUID to format.
-         *
-         *  @returns    A formatted GUID as a string.
-         */
-         function format( $g ) {
-            $g = str_replace( '-', '', $g );
-            return sprintf(
-                '%s-%s-%s-%s-%s',
-                substr( $g, 0, 8 ), substr( $g, 8, 4 ), substr( $g, 12, 4 ), substr( $g, 16, 4 ), substr( $g, 20 )
-            );
-         }
-
-    }
-
-    /**
-     *  This class allows you to perform LDAP releated tasks.
-     *
-     *  @ingroup YDFramework
-     */
-    class YDLdapUtil extends YDBase {
-
-        /**
-         *  Authenticate against a domain.
-         *
-         *  @param  $server     The name of the domain controller.
-         *  @param  $domain     The name of the domain.
-         *  @param  $user       The username.
-         *  @param  $password   The password.
-         *
-         *  @returns    A boolean indicating if the user was authenticated or not.
-         */
-        function authenticate( $server, $domain, $user, $password ) {
-
-            // Connect to the LDAP server
-            $conn = ldap_connect( $server );
-
-            // Setup the options
-            ldap_set_option( $conn, LDAP_OPT_PROTOCOL_VERSION, 3 );
-            ldap_set_option( $conn, LDAP_OPT_REFERRALS, 0 );
-
-            // Require a username
-            if ( empty( $user ) || empty( $pass ) ) {
-                return false;
-            }
-
-            // Fix the username
-            $user = strtolower( trim( $user ) );
-            if ( strpos( $user, '\\' ) ) {
-                $user = substr( $user, strpos( $user, '\\' ) + 1 );
-            }
-
-            // Authenticate
-            $result = @ldap_bind( $conn, $user . '@' . $server, $password );
-
-            // Close the connection
-            ldap_close( $conn );
-
-            // Return the result
-            return ( $result ) ? true : false;
-
-        }
-
-    }
-
-?>
+<?php
+
+    /*
+
+        Yellow Duck Framework version 2.1
+        (c) Copyright 2002-2007 Pieter Claerhout
+
+        This library is free software; you can redistribute it and/or
+        modify it under the terms of the GNU Lesser General Public
+        License as published by the Free Software Foundation; either
+        version 2.1 of the License, or (at your option) any later version.
+
+        This library is distributed in the hope that it will be useful,
+        but WITHOUT ANY WARRANTY; without even the implied warranty of
+        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+        Lesser General Public License for more details.
+
+        You should have received a copy of the GNU Lesser General Public
+        License along with this library; if not, write to the Free Software
+        Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+
+    */
+
+    /**
+     *  @addtogroup YDFramework Core
+     */
+
+    // Check if the framework is loaded
+    if ( ! defined( 'YD_FW_NAME' ) ) {
+        die( 'Yellow Duck Framework is not loaded.' );
+    }
+
+    /**
+     *	This is a general timer class that starts counting when it's instantiated, and which returns the elapsed time as
+     *	soon as the finish method is called.
+     *
+     *  @ingroup YDFramework
+     */
+    class YDTimer extends YDBase {
+
+        /**
+         *	This is the class constructor of the YDTimer class.
+         */
+        function YDTimer() {
+
+            // Initialize YDBase
+            $this->YDBase();
+
+            // Get the start time
+            $this->startTime = $this->_getMicroTime();
+
+            // Keep a list of intermediate times
+            $this->markers = array();
+
+        }
+
+        /**
+         *	This function returns the current microtime as a double.
+         *
+         *	@returns	Double containing the current time.
+         *
+         *	@internal
+         */
+        function _getMicroTime() {
+            $time = explode ( ' ', microtime() );
+            return ( doubleval( $time[0] ) + $time[1] );
+        }
+
+        /**
+         *	This will add a named marker.
+         *
+         *	@param $name	The name to use for the marker
+         */
+        function addMarker( $name ) {
+            array_push( $this->markers, array( $name, $this->getElapsed() ) );
+        }
+
+        /**
+         *	Finish the timer.
+         */
+        function finish() {
+            $this->addMarker( '** Finish' );
+        }
+
+        /**
+         *	This function will return the number of seconds elapsed since the timer was instantiated.
+         *
+         *	@returns	The total elapsed time
+         */
+        function getElapsed() {
+            $endTime = $this->_getMicroTime();
+            return intval( ( $endTime - $this->startTime ) * 1000 );
+        }
+
+        /**
+         *	This function returns a report as an array, with each row containing the following info: elapsed time,
+         *	difference with previous marker and marker name.
+         *
+         *	@returns	Array with the elapsed times, differences and marker names.
+         */
+        function getReport() {
+            $report = array();
+            $report[] = array( 0, 0, '** Start' );
+            $previous = 0;
+            foreach ( $this->markers as $marker ) {
+                $report[] = array( $marker[1], $marker[1]-$previous, $marker[0] );
+                $previous = $marker[1];
+            }
+            return $report;
+        }
+
+    }
+
+    /**
+     *  This class houses all the array related utility functions. All the methods are implemented as static methods and
+     *	do not require you to create a class instance in order to use them.
+     *
+     *  @ingroup YDFramework
+     */
+    class YDArrayUtil extends YDBase {
+
+        /**
+         *  This function will convert a single dimension array to a multi dimension array with the indicated number of
+         *	colums. If the number of columns is 1, it will return the original array.
+         *
+         *  If you enable the $fillLastRow option, it will fill the last row with null values to match the number of
+         *	columns.
+         *
+         *  @param $array		    The single dimension array you want to convert.
+         *  @param $columns		    The number of columns the table should have.
+         *  @param $fillLastRow	    (optional) If true, the last row will be filled with null values so that it matches
+         *						    the number of columns.
+         *  @param $horizontal  	(optional) If true, rows will be filled first, then it will create an new row
+         *
+         *  @returns	A multi-dimension array with the contents of the original array converted to a table with the
+         *				indicated number of colums.
+         *
+         *	@static
+         */
+        function convertToTable( $array, $columns, $fillLastRow=false, $horizontal=true ) {
+
+            // If the number of columns is 1, return the original array
+            if ( $columns == 1 ) {
+                return $array;
+            }
+
+            // Return original array if empty
+            if ( sizeof( $array ) == 0 ) {
+                return $array;
+            }
+
+            // Convert horizontally or vertically
+            if ( $horizontal ) {
+
+                // Use the array_chunk function to convert to a table
+                $newArray = @array_chunk( $array, $columns );
+                if ( $newArray == null ) {
+                    trigger_error( 'Failed to split the array in chunks.', YD_ERROR );
+                }
+
+                // Pad the last row
+                if ( $fillLastRow ) {
+                    $lastRow = $newArray[sizeof( $newArray )-1];
+                    $numMissing = $columns - sizeof( $lastRow );
+                    for ( $i = 0; $i < $numMissing; $i++ ) {
+                        array_push( $newArray[sizeof( $newArray )-1], null );
+                    }
+
+                }
+
+            } else {
+
+                // Get only the values of the array
+                $array = array_values( $array );
+
+                // Check how many rows we will have
+                $rows = ceil( sizeof( $array ) / $columns );
+
+                // Keep track of the current row
+                $currentItem = 0;
+                $currentCol  = 0;
+
+                // Start with a new empty array
+                $newArray = array();
+
+                // Loop over the rows
+                while ( $currentCol < $columns ) {
+                    foreach ( range( 0, $rows-1 ) as $row ) {
+                        $newArray[$row][$currentCol] = isset( $array[$currentItem] ) ? $array[$currentItem] : null;
+                        $currentItem++;
+                    }
+                    $currentCol++;
+                }
+
+            }
+
+            // Return the array
+            return $newArray;
+
+        }
+
+        /**
+         *	This function will create a new array which is a nested using the given column name.
+         *
+         *	@param $array	The array to convert.
+         *	@param $key		The column to use as the key name.
+         *	@param $append	(Optional) Boolean that defines if values are append to array (TRUE) or if are assigned (FALSE).
+         *
+         *	@returns	A new array which is a nested using the given column name.
+         *
+         *	@static
+         */
+        function convertToNested( $array, $key, $append = true ) {
+
+            // Start with the a new array
+            $new = array();
+
+            // Loop over the original array
+            foreach ( $array as $item ) {
+                if ( ! array_key_exists( $key, $item ) ) {
+                    trigger_error( 'YDArrayUtil::convertToNested: key "' . $key . '" not found', YD_ERROR );
+                }
+
+                // append values or assign them
+                if ( $append == true ){
+                    if ( ! isset( $new[ $item[ $key ] ] ) ) { $new[ $item[ $key ] ] = array(); }
+                    array_push( $new[ $item[ $key ] ], $item );
+                }else{
+                    $new[ $item[ $key ] ] = $item;
+                }
+            }
+
+            // Return the new array
+            return $new;
+
+        }
+
+        /**
+         *	This function will create a new array which is grouped by a given key and mapped according to a given array.
+         *
+         *	@param $input	The array to convert.
+         *	@param $key		The column to use as the key name.
+         *	@param $map		The array or string which indicates how values of the children arrays should be mapped in
+         *                  the parent array.
+         *
+         *	@returns		The array resulting from the mapping.
+         *
+         *	@static
+         */
+        function map( $input, $key, $map ) {
+
+            // Starting with new array
+            $output = array();
+
+            // Loop over the original array
+            foreach ( $input as $inputFragment ) {
+                if ( isset( $inputFragment[ $key ] ) ) {
+                    if ( is_array($map)) {
+                        foreach ( $map as $mapKey => $mapValue ) {
+                            if ( ! array_key_exists( $key, $inputFragment ) ) {
+                                trigger_error( 'YDArrayUtil::map: key "' . $key . '" not found', YD_ERROR );
+                            }
+                            if ( isset( $inputFragment[ $mapKey ] ) && isset( $inputFragment[ $mapValue ] ) ) {
+                                $output[ $inputFragment[ $key ] ][ $inputFragment[ $mapKey ] ] = $inputFragment[ $mapValue ];
+                            }
+                            else {
+                                $output[ $inputFragment[ $key ] ][ $inputFragment[ $mapKey ] ] = NULL;
+                            }
+                        }
+                    }
+                    else {
+                        $output[ $inputFragment[ $key ] ] = $inputFragment[ $map ];
+                    }
+                }
+            }
+
+            // Return the new array
+            return $output;
+        }
+
+        /**
+         *  This function will implode a 1-level array in a string.
+         *
+         *  @param $input      The array to implode.
+         *  @param $glue       (optional) The key/value glue. Default: =
+         *  @param $separator  (optional) The items separator. Default: ,
+         *
+         *  @returns       The imploded string.
+         *
+         *  @static
+         */
+        function implode( $input, $glue='=', $separator=',' ) {
+            $return = '';
+            foreach ( $input as $k => $v ) {
+                $return .= $separator . $k . $glue . $v;
+            }
+            return substr( $return, 1 );
+        }
+
+        /**
+         *  This function will initialize the indicated array if it doesn't exist yet.
+         *
+         *  @param  $where  Where to instantiate the array in.
+         *  @param  $name   The name of the array to create.
+         *
+         *  @static
+         */
+        function createIfNeeded( & $where, $name ) {
+            if ( ! isset( $where[$name] ) ) {
+                $where[$name] = array();
+            }
+        }
+
+
+        /**
+         *  This function will return a array with gmts.
+         *
+         *  @param $format      Format to return
+         *
+         *  @returns	Array. If format is NULL returns complete array.
+         *                                  'simple' returns: array( -11 => '(GMT -11:00)', -10 => ...
+         *                                  'full'   returns: array( -11 => '(GMT -11:00) Nome, Midway Island, Samoa', -10 => ...
+         *  @static
+         */
+        function getGMT( $format = null ){
+            $gmts = array(
+                '-11'   => array( '(GMT -11:00)', 'Nome, Midway Island, Samoa' ),
+                '-10'   => array( '(GMT -10:00)', 'Hawaii' ),
+                 '-9'   => array( '(GMT  -9:00)', 'Alaska' ),
+                 '-8'   => array( '(GMT  -8:00)', 'Pacific Time' ),
+                 '-7'   => array( '(GMT  -7:00)', 'Mountain Time' ),
+                 '-6'   => array( '(GMT  -6:00)', 'Central Time, Mexico City' ),
+                 '-5'   => array( '(GMT  -5:00)', 'Eastern Time, Bogota, Lima, Quito' ),
+                 '-4'   => array( '(GMT  -4:00)', 'Atlantic Time, Caracas, La Paz' ),
+                 '-3.5' => array( '(GMT  -3:30)', 'Newfoundland' ),
+                 '-3'   => array( '(GMT  -3:00)', 'Brazil, Buenos Aires, Georgetown, Falkland Is.' ),
+                 '-2'   => array( '(GMT  -2:00)', 'Mid-Atlantic, Ascention Is., St Helena' ),
+                 '-1'   => array( '(GMT  -1:00)', 'Azores, Cape Verde Islands' ),
+                  '0'   => array( '(GMT   0:00)', 'Casablanca, Dublin, Edinburgh, London, Lisbon, Monrovia' ),
+                  '1'   => array( '(GMT  +1:00)', 'Berlin, Brussels, Copenhagen, Madrid, Paris, Rome' ),
+                  '2'   => array( '(GMT  +2:00)', 'Kaliningrad, South Africa, Warsaw' ),
+                  '3'   => array( '(GMT  +3:00)', 'Baghdad, Riyadh, Moscow, Nairobi' ),
+                  '2.5' => array( '(GMT  +3:30)', 'Tehran' ),
+                  '4'   => array( '(GMT  +4:00)', 'Abu Dhabi, Baku, Muscat, Tbilisi' ),
+                  '4.5' => array( '(GMT  +4:30)', 'Kabul' ),
+                  '5'   => array( '(GMT  +5:00)', 'Islamabad, Karachi, Tashkent' ),
+                  '5.5' => array( '(GMT  +5:30)', 'Bombay, Calcutta, Madras, New Delhi' ),
+                  '6'   => array( '(GMT  +6:00)', 'Almaty, Colombo, Dhaka' ),
+                  '7'   => array( '(GMT  +7:00)', 'Bangkok, Hanoi, Jakarta' ),
+                  '8'   => array( '(GMT  +8:00)', 'Beijing, Hong Kong, Perth, Singapore, Taipei' ),
+                  '9'   => array( '(GMT  +9:00)', 'Osaka, Sapporo, Seoul, Tokyo, Yakutsk' ),
+                  '9.5' => array( '(GMT  +9:30)', 'Adelaide, Darwin' ),
+                 '10'   => array( '(GMT +10:00)', 'Melbourne, Papua New Guinea, Sydney, Vladivostok' ),
+                 '11'   => array( '(GMT +11:00)', 'Magadan, New Caledonia, Solomon Islands' ),
+                 '12'   => array( '(GMT +12:00)', 'Auckland, Wellington, Fiji, Marshall Island' )
+            );
+            if ( is_null( $format ) ) {
+                return $gmts;
+            }
+            foreach( $gmts as $t => $arr ){
+                if ( $format == 'simple' ) $gmts[ $t ] = $arr[ 0 ];
+                else                       $gmts[ $t ] = $arr[ 0 ] . ' ' . $arr[ 1 ];
+            }
+            return $gmts;
+        }
+
+        /**
+         *  This function will convert a database result array to XML
+         *
+         *  @param $array      The input array.
+         *
+         *  @returns       The array as an XML string.
+         *
+         *  @static
+         */
+        function toXml( $array ) {
+            $out = '';
+            foreach ( $array as $record ) {
+                $out .= sprintf( '<row>' );
+                foreach ( $record as $key=>$val ) {
+                    if ( is_numeric( $val ) ) {
+                        $out .= sprintf( '<%s>%s</%s>', $key, $val, $key );
+                    } else {
+                        $out .= sprintf( '<%s><![CDATA[%s]]></%s>', $key, $val, $key );
+                    }
+                }
+                $out .= sprintf( '</row>' );
+            }
+            $out = sprintf( '<root>%s</root>', $out );
+            return '<?xml version="1.0" encoding="utf-8"?>' . $out;
+        }
+
+    }
+
+    /**
+     *	This class houses all the debug related utility functions. All the methods are implemented as static methods and
+     *	do not require you to create a class instance in order to use them.
+     *
+     *  @ingroup YDFramework
+     */
+    class YDDebugUtil extends YDBase {
+
+        /**
+         *  Trigger an error
+         *
+         *  @param  $msg    The error to raise.
+         *  @param  $sql    (optional) The SQL statement to log with the error.
+         *  @param  $level  (optional) The type of error to be raised. Default is YD_ERROR.
+         */
+        function error( $msg, $sql=null, $level=YD_ERROR ) {
+            echo( '<p><b><font color="red">An error occured</font></b></p>' );
+            echo( '<b>Stacktrace:</b> <pre>' . YDDebugUtil::getStackTrace() . '</pre>' );
+            if ( ! empty( $sql ) ) {
+                echo( '<b>SQL Statement:</b> <pre>' . $this->formatSql( $sql ) . '</pre>' );
+            }
+            trigger_error( $msg, $level );
+        }
+
+        /**
+         *	Function to output a debug message. These message are only shown if the constant YD_DEBUG is set to 1. You
+         *	can turn on debugging by specifying the YD_DEBUG parameter in the url and assigning it the value 1.
+         *
+         *	Example url with debugging turned on: http://localhost/index.php?YD_DEBUG=1
+         *
+         *	This function accepts a variable amount of arguments which are all concatenated using a space in between.
+         *	All debug messages will be shown as HTML comments with the prefix "[ YD_DEBUG ]".
+         *
+         *	@static
+         */
+        function debug() {
+            $args = func_get_args();
+            if ( YDConfig::get( 'YD_DEBUG' ) == 1 ) {
+                echo( YD_CRLF . '<!-- [ YD_DEBUG ] ' . implode( ' ', $args ) . '-->' . YD_CRLF );
+            }
+            if ( YDConfig::get( 'YD_DEBUG' ) == 2 ) {
+                echo( '<table border="0" cellspacing="0" cellpadding="4"><tr>' );
+                echo( '<td bgcolor="#FFCC00">' );
+                echo( '<b>' . YD_FW_NAME . ' Debug Information</b> ' );
+                echo( '<pre>' . htmlspecialchars( trim( implode( ' ', $args ) ) ) . '</pre>' );
+                echo( '</td></tr></table>' );
+            }
+        }
+
+        /**
+         *	Function to dump the contents of pretty much anything. This is the same as the var_dump function in PHP, but
+         *	has a nicer and more readable output.
+         *
+         *	@param $obj		Object you want to dump.
+         *	@param $label	The label for the dump.
+         *
+         *	@static
+         */
+        function dump( $obj, $label='' ) {
+            echo( YDDebugUtil::r_dump( $obj, true, $label ) );
+        }
+
+        /**
+         *	Function to return the contents of pretty much anything. This is the same as the var_export function in PHP.
+         *
+         *	@param $obj		Object you want to dump.
+         *	@param $html	(optional) If you want to have everything returned as HTML or text. The default is false,
+         *					returning text.
+         *	@param $label	The label for the dump.
+         *
+         *	@returns	Text representation of the object.
+         *
+         *	@static
+         */
+        function r_dump( $obj, $html=false, $label='' ) {
+            $data = var_export( $obj, true );
+            if ( $html == true ) {
+                $data = stripslashes( htmlentities( $data ) );
+                $style = ' style="text-align: left; font-size: 10pt;"';
+                if ( ! empty( $label ) ) {
+                    $data = '<pre' . $style . '><b style="color: navy">' . $label . '</b><br>' . $data . '</pre>';
+                } else {
+                    $data = '<pre' . $style . '>' . $data . '</pre>';
+                }
+            } else {
+                $data = $label . YD_CRLF . $data;
+            }
+            return $data;
+        }
+
+        /**
+         *	This function will print a stack trace.
+         *
+         *	@static
+         */
+        function stackTrace() {
+            if ( YDConfig::get( 'YD_DEBUG' ) == 1 || YDConfig::get( 'YD_DEBUG' ) == 2 ) {
+                $err = 'URI: ' . YD_SELF_URI . YD_CRLF . YDDebugUtil::getStackTrace();
+                if ( ini_get( 'display_errors' ) == 1 ) {
+                    echo( '<pre>' . YD_CRLF . htmlentities( $err ) . '</pre>' );
+                }
+                error_log( $err, 0 );
+            }
+        }
+
+        /**
+         *	Function to get a formatted stack trace.
+         *
+         *	@static
+         */
+        function getStackTrace() {
+            $err = '';
+            $err .= 'Debug backtrace:' . YD_CRLF;
+            foreach( debug_backtrace() as $t ) {
+                $err .= '    @ ';
+                if ( isset( $t['file'] ) ) {
+                    $err .= basename( $t['file'] ) . ':' . $t['line'];
+                } else {
+                    $err .= basename( YD_SELF_FILE );
+                }
+                $err .= ' -- ';
+                if ( isset( $t['class'] ) ) {
+                    $err .= $t['class'] . $t['type'];
+                }
+                $err .= $t['function'];
+                if ( isset( $t['args'] ) && sizeof( $t['args'] ) > 0 ) {
+                    $err .= '(...)';
+                } else {
+                    $err .= '()';
+                }
+                $err .= YD_CRLF;
+            }
+            return $err;
+        }
+
+    }
+
+    /**
+     *	This class houses all the object and class related utility functions. All the methods are implemented as static
+     *	methods and do not require you to create a class instance in order to use them.
+     *
+     *  @ingroup YDFramework
+     */
+    class YDObjectUtil extends YDBase {
+
+        /**
+         *	This function checks if an object instance is of a specific class or is based on a derived class of the
+         *	given class. The class name is case insensitive.
+         *
+         *	@param $obj		The object instance to check.
+         *	@param $class	The object type you want to check against.
+         *
+         *	@returns	Boolean indicating if the object is of the specified class.
+         *
+         *	@static
+         */
+        function isSubClass( $obj, $class ) {
+            $class = strtolower( $class );
+            if ( function_exists( 'is_a' ) ) {
+                return is_a( $obj, $class );
+            } else {
+                if ( is_object( $obj ) ) {
+                    if ( strtolower( get_class( $obj ) ) == strtolower( $class ) ) return true;
+                    if ( is_subclass_of( $obj, $class ) ) return true;
+                }
+            }
+            return false;
+        }
+
+        /**
+         *	Function to get all the ancestors of a class. The list will contain the parent class first, and then it's
+         *	parent class, etc. You can pass both the name of the class or an object instance to this function
+         *
+         *	@param $classname	Name of the class or object.
+         *
+         *	@returns	Array with all the ancestors.
+         *
+         *	@static
+         */
+        function getAncestors( $classname ) {
+            if ( is_object( $classname ) ) {
+                $classname = strtolower( get_class( $classname ) );
+            }
+            $ancestors = array();
+            $father = get_parent_class( $classname );
+            if ( $father != '' ) {
+                $ancestors = YDObjectUtil::getAncestors( $father );
+                $ancestors[] = $father;
+            }
+            return array_reverse( $ancestors );
+        }
+
+        /**
+         *	This function will serialize an object.
+         *
+         *	@param $obj	Object to serialize.
+         *
+         *	@static
+         */
+        function serialize( $obj ) {
+            $obj = serialize( $obj );
+            if ( ! $obj ) {
+                trigger_error( 'Failed serializing the object', YD_ERROR );
+            }
+            return $obj;
+        }
+
+        /**
+         *	This function will unserialize an object.
+         *
+         *	@param $obj	Object to unserialize.
+         *
+         *	@static
+         */
+        function unserialize( $obj ) {
+            $obj = unserialize( $obj );
+            if ( ! $obj ) {
+                trigger_error( 'Failed unserializing the object', YD_ERROR );
+            }
+            return $obj;
+        }
+
+    }
+
+    /**
+     *	This class houses all the string related utility functions. All the methods are implemented as static methods
+     *	and do not require you to create a class instance in order to use them.
+     *
+     *  @ingroup YDFramework
+     */
+    class YDStringUtil extends YDBase {
+
+        /**
+         *	Function to format a file size to a meaningful value.
+         *
+         *	@param $bytes		The file size to format.
+         *	@param $decimals	(optional) The number of decimals that should be returned.
+         *
+         *	@returns String containing the formatted file size.
+         *
+         *	@static
+         */
+        function formatFilesize( $bytes, $decimals=1 ) {
+
+            // Convert the bytes to a string
+            $bytes = strval( $bytes );
+
+            // The different units
+            $units = array(
+                '1152921504606846976'	=> 'EB',
+                '1125899906842624'		=> 'PB',
+                '1099511627776'			=> 'TB',
+                '1073741824'			=> 'GB',
+                '1048576'				=> 'MB',
+                '1024'					=> 'KB'
+            );
+
+            // If smaller than 1024, return it as bytes
+            if ( $bytes <= 1024 ) {
+                return $bytes . ' bytes';
+            }
+
+            // Check the right format
+            foreach ( $units as $base=>$title ) {
+                if ( floor( $bytes / $base ) != 0 ) {
+                    return number_format( $bytes / $base, $decimals, '.', "'" ) . ' ' . $title;
+                }
+            }
+
+        }
+
+        /**
+         *  This function will format a timestamp using the strftime function.
+         *
+         *  @param  $timestamp  The timestamp to format. It can also be a date/time form object.
+         *  @param  $format     The strftime format to use. You can also use the predefined options date, time and
+         *                      datetime.
+         *  @param  $locale     (optional) The locale to use to format the date.
+         *
+         *  @returns    A formatted timestamp
+         *
+         *  @static
+         */
+        function formatDate( $timestamp, $format, $locale=null ) {
+
+            // Check if the timestamp is an object and has the getTimeStamp function
+            if ( is_object( $timestamp ) && method_exists( $timestamp, 'getTimeStamp' ) ) {
+                $timestamp = $timestamp->getTimeStamp();
+            }
+
+            // Convert to an integer
+            if ( is_numeric( $timestamp ) ) {
+                $timestamp = intval( $timestamp );
+            }
+
+            // If text, convert to number
+            if ( is_string( $timestamp ) ) {
+                $timestamp = strtotime( $timestamp );
+            }
+
+            // If array, is a date YDForm element value
+            if ( is_array( $timestamp ) ) {
+
+                // check if timestamp exists. otherwise create it
+                $hours   = isset( $timestamp[ 'hours' ] ) ?   $timestamp[ 'hours' ] : 0;
+                $minutes = isset( $timestamp[ 'minutes' ] ) ? $timestamp[ 'minutes' ] : 0;
+                $seconds = isset( $timestamp[ 'seconds' ] ) ? $timestamp[ 'seconds' ] : 0;
+                $month   = isset( $timestamp[ 'month' ] ) ?   $timestamp[ 'month' ] : 1;
+                $day     = isset( $timestamp[ 'day' ] ) ?     $timestamp[ 'day' ] : 1;
+                $year    = isset( $timestamp[ 'year' ] ) ?    $timestamp[ 'year' ] : 1970;
+                $timestamp = mktime( $hours, $minutes, $seconds, $month, $day, $year );
+            }
+
+            // Check the standard formats
+            if ( strtolower( $format ) == 'date' ) {
+                $format = '%d %B %Y';
+            }
+            if ( strtolower( $format ) == 'datetime' ) {
+                $format = '%d %B %Y %H:%M';
+            }
+            if ( strtolower( $format ) == 'datetimesql' ) {
+                $format = '%Y-%m-%d %H:%M:%S';
+            }
+            if ( strtolower( $format ) == 'time' ) {
+                $format = '%H:%M';
+            }
+            if ( strtolower( $format ) == 'file' ) {
+                $format = '%d-%m-%Y %H:%M';
+            }
+
+            // Set the new locale
+            if ( ! is_null( $locale ) ) {
+                $currentLocale = YDLocale::get();
+                YDLocale::set( $locale );
+            }
+
+            // Return the formatted date
+            $timestamp = strftime( $format, $timestamp );
+
+            // Reset the old locale
+            if ( ! is_null( $locale ) ) {
+                YDLocale::set( $currentLocale );
+            }
+
+            // Return the timestamp
+            return $timestamp;
+
+        }
+
+        /**
+         *	This function will encode all characters which have an ordinal bigger than 128 to numeric HTML entities,
+         *	which can be safely included in e.g. XML output.
+         *
+         *	@param $string	The original string to encode.
+         *	@param $htmlent	Boolean indicating if the result should be HTML encoded or not.
+         *
+         *	@returns	String with all the characters with an ordinal bigger than 128 converted to numeric entities.
+         *
+         *	@static
+         */
+        function encodeString( $string, $htmlent=false ) {
+            $trans = array_flip( get_html_translation_table( HTML_ENTITIES ) );
+            $string = strtr( $string, $trans );
+            $trans = get_html_translation_table( HTML_ENTITIES, ENT_NOQUOTES );
+            foreach ( $trans as $key => $value ) {
+                if ( ord( $key ) == 60 || ord( $key ) == 62 || ord( $key ) == 38 ) {
+                    unset( $trans[$key] );
+                } else {
+                    $trans[$key] = '&#' . ord( $key ) . ';';
+                }
+            }
+            $string = strtr( $string, $trans );
+            if ( $htmlent == true ) {
+                $string = htmlentities( $string );
+            }
+            return $string;
+        }
+
+        /**
+         *   This function will encode all characters in a string to it's ASCII value.
+         *
+         *   @param $string   The original string to encode.
+         *
+         *   @returns   The encoded string.
+         *
+         *   @static
+         */
+        function encodeToAscii( $string ) {
+            $result = '';
+            for ( $i=0; $i < strlen( $string ); $i++ ) {
+                $result .= "&#" . ord( substr( $string, $i, 1) ) . ';';
+            }
+            return $result;
+        }
+
+        /**
+         *	This function will truncate a string.
+         *
+         *	@param $string		String to truncate.
+         *	@param $length		(optional) The length to truncate to. Default length is 80 characters.
+         *	@param $etc			(optional) The string to append if the item gets trunctated. Default is '...'.
+         *	@param $break_words	(optional) Break in the middle of words or not. Default is false.
+         *
+         *	@static
+         */
+        function truncate( $string, $length=80, $etc='...', $break_words=false ) {
+            if ( $length == 0 ) { return ''; }
+            if ( strlen( $string ) > $length ) {
+                $string = html_entity_decode( strip_tags( $string ) );
+                $length -= strlen( $etc );
+                if ( ! $break_words ) {
+                    $string = preg_replace( '/\s+?(\S+)?$/', '', substr( $string, 0, $length+1 ) );
+                }
+                return htmlentities( substr( $string, 0, $length ) . $etc );
+            } else {
+                return $string;
+            }
+        }
+
+        /**
+         *	This function normalizes all the newlines to the correct newline character for the current platform.
+         *
+         *	@param $string		String to normalize the newlines from.
+         *
+         *	@returns	The original string with normalized newlines.
+         *
+         *	@static
+         */
+        function normalizeNewlines( $string ) {
+
+            // First, change all to \n
+            $string = str_replace( "\r\n", "\n",    $string );
+            $string = str_replace( "\r",   "\n",    $string );
+
+            // Now, change everything to the correct one
+            $string = str_replace( "\n",   YD_CRLF, $string );
+
+            // Return the changed string
+            return $string;
+
+        }
+
+        /**
+         *	This function will remove all newlines and all spaces at the beginning and end of each line.
+         *
+         *	@param $string		String to remove the whitespace from.
+         *
+         *	@returns	The original string without the newlines and spaces at the beginning and end of each line.
+         *
+         *	@static
+         */
+        function removeWhiteSpace( $string ) {
+
+            // First, normalize the newlines
+            $string = YDStringUtil::normalizeNewLines( $string );
+
+            // Now, remove the whitespace
+            $string = implode( ' ', array_map( 'trim', explode( YD_CRLF, $string ) ) );
+
+            // Return the changed string
+            return $string;
+
+        }
+
+        /**
+         *   This function will compare two network ip addresses
+         *
+         *   @param $ip1      First ip
+         *
+         *   @param $ip2      Second ip
+         *
+         *   @returns    Returns < 0 if ip1 is less than ip2; > 0 if str1 is greater than ip2, and 0 if they are equal.
+         *
+         *   @static
+         */
+        function ipcmp( $ip1, $ip2 ){
+
+            // get 4 elements from the network address
+            $ip1 = explode(".", $ip1);
+            $ip2 = explode(".", $ip2);
+
+            // get an integer that represents the numeric value of the address
+            $ip1 = $ip1[0]*256^3 + $ip1[1]*256^2 + $ip1[2]*256 + $ip1[3];
+            $ip2 = $ip2[0]*256^3 + $ip2[1]*256^2 + $ip2[2]*256 + $ip2[3];
+
+            // return diference
+            return $ip1 - $ip2;
+
+        }
+
+        /**
+         *  This function will replace all special characters to normal ASCII characters. This is very useful when you
+         *  want to rename uploaded files and strip out the special characters.
+         *
+         *  @param  $data   The data to strip the special characters from.
+         *
+         *  @returns    The data with the special characters replaced.
+         *
+         *  @static
+         */
+        function stripSpecialCharacters( $data ) {
+
+            // Trim the data
+            $data = trim( $data );
+
+            // Decode the HTML entities
+            $trans = array_flip( get_html_translation_table( HTML_ENTITIES, ENT_NOQUOTES ) );
+            $data = strtr( $data, $trans );
+
+            // The characters to replace
+            $chars = array(
+                '?' => 'A', '?' => 'A', '?' => 'A', '?' => 'AE', '?' => 'E', '?' => 'E', '?' => 'I', '?' => 'I',
+                '?' => 'D', '?' => 'O', '?' => 'O', '?' => 'O', '?' => 'O', '?' => 'U', '?' => 'U', '?' => 'a',
+                '?' => 'a', '?' => 'a', '?' => 'ae', '?' => 'e', '?' => 'e', '?' => 'i', '?' => 'i', '?' => 'o',
+                '?' => 'o', '?' => 'o', '?' => 'o', '?' => 'o', '?' => 'u', '?' => 'u', '?' => 'A', '?' => 'A',
+                '?' => 'A', '?' => 'C', '?' => 'E', '?' => 'E', '?' => 'I', '?' => 'I', '?' => 'N', '?' => 'O',
+                '?' => 'O', '?' => 'U', '?' => 'U',  '?' => 'Y', '?' => 'B', '?' => 'a', '?' => 'a', '?' => 'a',
+                '?' => 'c', '?' => 'e', '?' => 'e', '?' => 'i', '?' => 'i', '?' => 'n', '?' => 'o', '?' => 'o',
+                '?' => 'u', '?' => 'u', '?' => 'y', '?' => 'y', '@' => '_', ' ' => '_', '[' => '_', ']' => '_',
+                '(' => '_', ')' => '_', '&' => '_', '+' => '_', '=' => '_'
+            );
+
+            // Strip the special characters
+            $data = str_replace( array_keys( $chars ), $chars, $data );
+
+            // Return the data
+            return $data;
+
+        }
+
+        /**
+         *  This function will check if the specified string starts with the indicated text or not. You can specify if
+         *  this needs to happen case-sensitively or not.
+         *
+         *  @param  $string         The string to check.
+         *  @param  $substring      The string with which it needs to start.
+         *  @param  $case_sensitive (optional) Whether the comparison needs to be case-sensitive or not. Default is true.
+         *
+         *  @returns    Boolean indicating if the string starts with the specified text or not.
+         */
+        function startsWith( $string, $substring, $case_sensitive=true ) {
+            if ( ! $case_sensitive ) {
+                $string = strtolower( $string );
+                $substring = strtolower( $substring );
+            }
+            return ( substr( $string, 0, strlen( $substring ) ) == $substring );
+        }
+
+        /**
+         *  This function will check if the specified string ends with the indicated text or not. You can specify if
+         *  this needs to happen case-sensitively or not.
+         *
+         *  @param  $string         The string to check.
+         *  @param  $substring      The string with which it needs to ends.
+         *  @param  $case_sensitive (optional) Whether the comparison needs to be case-sensitive or not. Default is true.
+         *
+         *  @returns    Boolean indicating if the string ends with the specified text or not.
+         */
+        function endsWith( $string, $substring, $case_sensitive=true ) {
+            if ( ! $case_sensitive ) {
+                $string = strtolower( $string );
+                $substring = strtolower( $substring );
+            }
+            return ( substr( $string, -strlen( $substring ) ) == $substring );
+        }
+
+        /**
+         *  This function is an fnmatch replacement.
+         *
+         *  $param $string      The string to test
+         *  $param $pattern     The pattern to match
+         *
+         *  @returns    Boolean indicating if the string matches the pattern or not.
+         */
+        function match( $string, $pattern ) {
+            for ( $op = 0, $npattern = '', $n = 0, $l = strlen( $pattern ); $n < $l; $n++ ) {
+            switch ($c = $pattern[$n]) {
+                case '\\':
+                    $npattern .= '\\' . @$pattern[++$n];
+                    break;
+                case '.':
+                case '+':
+                case '^':
+                case '$':
+                case '(':
+                case ')':
+                case '{':
+                case '}':
+                case '=':
+                case '!':
+                case '<':
+                case '>':
+                case '|':
+                    $npattern .= '\\' . $c;
+                    break;
+                case '?': case '*':
+                    $npattern .= '.' . $c;
+                    break;
+                case '[':
+                case ']':
+                default:
+                    $npattern .= $c;
+                    if ($c == '[') {
+                        $op++;
+                    } else if ($c == ']') {
+                        if ($op == 0) return false;
+                            $op--;
+                        }
+                        break;
+                    }
+            }
+            if ( $op != 0 ) {
+                return false;
+            } else {
+                return preg_match( '/' . $npattern . '/i', $string );
+            }
+        }
+
+        /**
+         *  Show the time that has elapsed since a given time.
+         *
+         *  @param  $time   The time in seconds
+         *
+         *  @returns    The elapsed time
+         */
+        function timesince( $time ) {
+
+            // Convert to integer
+            if ( is_string( $time ) && is_numeric( $time ) ) {
+                $time = intval( $time );
+            }
+
+            // Array of time period chunks
+            $chunks = array(
+                array( 60 * 60 * 24 * 365 , t('years') ),
+                array( 60 * 60 * 24 * 30 , t('months') ),
+                array( 60 * 60 * 24 * 7, t('weeks') ),
+                array( 60 * 60 * 24 , t('days') ),
+                array( 60 * 60 , t('hours') ),
+                array( 60 , t('minutes') ),
+            );
+
+            // Difference in seconds
+            $since = time() - $time;
+
+            // The first chunk
+            for ( $i = 0, $j = sizeof( $chunks ); $i < $j; $i++ ) {
+                $seconds = $chunks[$i][0];
+                $name = $chunks[$i][1];
+                if ( ( $count = floor( $since / $seconds ) ) != 0 ) {
+                    break;
+                }
+            }
+
+            // Set output var
+            $output = ( $count == 1 ) ? '1 '.$name : $count . ' ' . $name;
+
+            // step two: the second chunk
+            if ( $i + 1 < $j ) {
+                $seconds2 = $chunks[$i + 1][0];
+                $name2 = $chunks[$i + 1][1];
+                if ( ( $count2 = floor( ( $since - ( $seconds * $count ) ) / $seconds2 ) ) != 0 ) {
+                    $output .= ($count2 == 1) ? ', 1 '.$name2 : ", $count2 {$name2}s";
+                }
+            }
+
+            // Return the output
+            return $output . ' ' . t('ago');
+
+        }
+
+    }
+
+    /**
+     *	This class uses the HTTP_USER_AGENT varaible to get information about the browser the visitor used to perform
+     *	the request. We determine the browser name, the version and the platform it's running on.
+     *
+     *  @ingroup YDFramework
+     */
+    class YDBrowserInfo extends YDBase {
+
+        /**
+         *	The class constructor analyzes for the YDBrowserInfo class. The constructor takes no arguments and uses the
+         *	$_SERVER['HTTP_USER_AGENT'] variable to parse the browser info.
+         */
+        function YDBrowserInfo() {
+
+            // Initialize YDBase
+            $this->YDBase();
+
+            // The matching list for browsers
+            $browsers = array(
+                'bot'       => array( 'bot', 'Yahoo! Slurp', 'crawler', 'scooter', 'mercator', 'altavista', 'Gulliver', 'spider', 'Ask Jeeves' ),
+                'opera'     => array( 'opera' ),
+                'ie'        => array( 'msie' ),
+                'safari'    => array( 'safari' ),
+                'konqueror' => array( 'Konqueror' ),
+                'feed'      => array( 'feed', 'rss', 'synd', 'bloglines', 'newsgator' ),
+                'mozilla'   => array( 'mozilla', 'firefox' ),
+            );
+
+            // The matching list for platforms
+            $platforms = array(
+                'win'       => array( 'win' ),
+                'mac'       => array( 'mac', 'apple' ),
+                'linux'     => array( 'linux', 'bsd' ),
+                'unix'      => array( 'unix', 'sun', 'risc', 'aix' ),
+                'bot'       => array( 'bot', 'Yahoo! Slurp', 'crawler' ),
+                'feed'      => array( 'feed', 'rss', 'synd', 'bloglines', 'newsgator' ),
+            );
+
+            // Mark everything as unknown
+            $this->agent = 'unknown';
+            $this->browser = 'unknown';
+            $this->platform = 'unknown';
+            $this->dotnet = 'unknown';
+
+            // Check if the user agent was specified
+            if ( isset( $_SERVER['HTTP_USER_AGENT'] ) ) {
+
+                // Get the user agent
+                $this->agent = $_SERVER['HTTP_USER_AGENT'];
+
+                // Get the browser name
+                foreach ( $browsers as $browser => $browserpatterns ) {
+                    foreach ( $browserpatterns as $browserpattern ) {
+                        if ( stristr( $this->agent, $browserpattern ) ) {
+                            $this->browser = $browser;
+                            continue;
+                        }
+                    }
+                    if ( $this->browser != 'unknown' ) {
+                        break;
+                    }
+                }
+
+                // Get the browser name
+                foreach ( $platforms as $platform => $platformpatterns ) {
+                    foreach ( $platformpatterns as $platformpattern ) {
+                        if ( stristr( $this->agent, $platformpattern ) ) {
+                            $this->platform = $platform;
+                            continue;
+                        }
+                    }
+                    if ( $this->platform != 'unknown' ) {
+                        break;
+                    }
+                }
+
+                // Get the .NET runtime version
+                preg_match_all( '/.NET CLR ([0-9][.][0-9])/i', $this->agent, $ver );
+                $this->dotnet = $ver[1];
+
+            }
+
+        }
+
+        /**
+         *  Get the hostname of the client computer.
+         *
+         *  @returns The hostname of the client computer in lowercase.
+         *
+         *  @static
+         */
+        function getComputerName() {
+            return strtolower( gethostbyaddr( $_SERVER['REMOTE_ADDR'] ) );
+        }
+
+        /**
+         *	This function returns an array with the languages that are supported by the browser. This is done by using
+         *	the HTTP_ACCEPT_LANGUAGE server variable that gets send with the HTTP headers.
+         *
+         *	@return Array containing the list of supported languages
+         */
+        function getBrowserLanguages() {
+
+            // We parse the language headers sent by the browser
+            if ( ! isset( $_SERVER['HTTP_ACCEPT_LANGUAGE'] ) ) {
+                return array();
+            }
+            $browserLanguages = explode( ',', $_SERVER['HTTP_ACCEPT_LANGUAGE'] );
+
+            // Normalize the browser language headers
+            for ( $i = 0; $i < sizeof( $browserLanguages ); $i++ ) {
+                $browserLanguage = explode( ';', $browserLanguages[$i] );
+                $browserLanguages[$i] = substr( $browserLanguage[0], 0, 2 );
+            }
+
+            // Remove the duplicates
+            $browserLanguages = array_unique( $browserLanguages );
+
+            // Return the browser languages
+            return array_map( 'strtolower', array_values( $browserLanguages ) );
+
+        }
+
+        /**
+         *  This function returns an array with the languages that are supported by the browser and also interprets the
+         *  country information that the browser sends over.. This is done by using the HTTP_ACCEPT_LANGUAGE server
+         *  variable that gets send with the HTTP headers.
+         *
+         *  @return Array containing the list of supported languages
+         */
+        function getBrowserLanguagesAndCountries() {
+
+            // We parse the language headers sent by the browser
+            if ( !isset( $_SERVER['HTTP_ACCEPT_LANGUAGE'] ) ) {
+                return array();
+            }
+            $browserCountries = explode( ',', $_SERVER['HTTP_ACCEPT_LANGUAGE'] );
+            $languagesAndCountries = array();
+
+            // Loop over the languages and normalize them
+            foreach( $browserCountries as $value ) {
+                $lang = explode( ';', $value );
+                $lang = explode( '-', $lang[0] );
+                $lang[1] = ( isset( $lang[1] ) && $lang[1] != '' ? $lang[1] : $lang[0] );
+                $languagesAndCountries[][ $lang[1] ] = $lang[0];
+            }
+
+            // Return the normalized list
+            return $languagesAndCountries;
+
+        }
+
+        /**
+         *	This function will get the most appropriate language for the browser, considering the list of supported
+         *	languages by both the browser and the web application.
+         *
+         *	@param $supported	(optional) An array with the list of supported languages. By default, only english is
+         *						supported.
+         */
+        function getLanguage( $supported=array( 'en' ) ) {
+
+            // Start with the default language
+            $language = $supported[0];
+
+            // Get the list of languages supported by the browser
+            $browserLanguages = $this->getBrowserLanguages();
+
+            // Now, we look if the browser specified one
+            if ( isset( $_SERVER['HTTP_ACCEPT_LANGUAGE'] ) ) {
+                foreach ( $browserLanguages as $browserLanguage ) {
+                    if ( in_array( $browserLanguage, $supported ) ) {
+                        $language = $browserLanguage;
+                        break;
+                    }
+                }
+            }
+
+            // Return the language
+            return $language;
+
+        }
+
+    }
+
+    /**
+     *  This class allows you to generate GUIDs (global unique identifier).
+     *
+     *  More info: http://www.ietf.org/rfc/rfc4122.txt
+     *
+     *  @ingroup YDFramework
+     */
+    class YDGuidUtil extends YDBase {
+
+        /**
+         *  Generate a new GUID.
+         *
+         *  @returns    A new GUID as a string.
+         */
+        function create() {
+            return md5( uniqid( rand(), true ) . $_SERVER['SERVER_NAME'] . $_SERVER['SERVER_ADDR'] );
+        }
+
+        /**
+         *  Generate a new formatted GUID.
+         *
+         *  @returns    A formatted GUID as a string.
+         */
+        function createFormatted() {
+            return YDGuidUtil::format( YDGuidUtil::create() );
+        }
+
+        /**
+         *  Formats a GUID.
+         *
+         *  @param $g    GUID to format.
+         *
+         *  @returns    A formatted GUID as a string.
+         */
+         function format( $g ) {
+            $g = str_replace( '-', '', $g );
+            return sprintf(
+                '%s-%s-%s-%s-%s',
+                substr( $g, 0, 8 ), substr( $g, 8, 4 ), substr( $g, 12, 4 ), substr( $g, 16, 4 ), substr( $g, 20 )
+            );
+         }
+
+    }
+
+    /**
+     *  This class allows you to perform LDAP releated tasks.
+     *
+     *  @ingroup YDFramework
+     */
+    class YDLdapUtil extends YDBase {
+
+        /**
+         *  Authenticate against a domain.
+         *
+         *  @param  $server     The name of the domain controller.
+         *  @param  $domain     The name of the domain.
+         *  @param  $user       The username.
+         *  @param  $password   The password.
+         *
+         *  @returns    A boolean indicating if the user was authenticated or not.
+         */
+        function authenticate( $server, $domain, $user, $password ) {
+
+            // Connect to the LDAP server
+            $conn = ldap_connect( $server );
+
+            // Setup the options
+            ldap_set_option( $conn, LDAP_OPT_PROTOCOL_VERSION, 3 );
+            ldap_set_option( $conn, LDAP_OPT_REFERRALS, 0 );
+
+            // Require a username
+            if ( empty( $user ) || empty( $pass ) ) {
+                return false;
+            }
+
+            // Fix the username
+            $user = strtolower( trim( $user ) );
+            if ( strpos( $user, '\\' ) ) {
+                $user = substr( $user, strpos( $user, '\\' ) + 1 );
+            }
+
+            // Authenticate
+            $result = @ldap_bind( $conn, $user . '@' . $server, $password );
+
+            // Close the connection
+            ldap_close( $conn );
+
+            // Return the result
+            return ( $result ) ? true : false;
+
+        }
+
+    }
+
+?>



From ximian at mail.berlios.de  Thu Mar 22 01:57:57 2007
From: ximian at mail.berlios.de (ximian at mail.berlios.de)
Date: Thu, 22 Mar 2007 01:57:57 +0100
Subject: [ydf-devel] r2414 -
	YDFramework2.0/trunk/YDFramework2/addons/YDDatabaseObjectTree
Message-ID: <200703220057.l2M0vvUC003699@sheep.berlios.de>

Author: ximian
Date: 2007-03-22 01:57:46 +0100 (Thu, 22 Mar 2007)
New Revision: 2414

Modified:
   YDFramework2.0/trunk/YDFramework2/addons/YDDatabaseObjectTree/YDDatabaseObjectTree.php
Log:
on YDDatabaseObjectTree:
 - FEATURE: added moveNodeUp() and moveNodeDown() that moves node up/down on same parent
 - FIXED: move node was not updating levels when moving to different parent

Modified: YDFramework2.0/trunk/YDFramework2/addons/YDDatabaseObjectTree/YDDatabaseObjectTree.php
===================================================================
--- YDFramework2.0/trunk/YDFramework2/addons/YDDatabaseObjectTree/YDDatabaseObjectTree.php	2007-03-19 16:59:03 UTC (rev 2413)
+++ YDFramework2.0/trunk/YDFramework2/addons/YDDatabaseObjectTree/YDDatabaseObjectTree.php	2007-03-22 00:57:46 UTC (rev 2414)
@@ -1,815 +1,860 @@
-<?php
-
-    /*
-
-        Yellow Duck Framework version 2.1
-        (c) Copyright 2002-2007 Pieter Claerhout
-
-        This library is free software; you can redistribute it and/or
-        modify it under the terms of the GNU Lesser General Public
-        License as published by the Free Software Foundation; either
-        version 2.1 of the License, or (at your option) any later version.
-
-        This library is distributed in the hope that it will be useful,
-        but WITHOUT ANY WARRANTY; without even the implied warranty of
-        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
-        Lesser General Public License for more details.
-
-        You should have received a copy of the GNU Lesser General Public
-        License along with this library; if not, write to the Free Software
-        Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
-
-    */
-
-    /**
-     *  @addtogroup YDDatabaseObjectTree Addons - DatabaseObjectTree
-     */
-
-    // Check if the framework is loaded
-    if ( ! defined( 'YD_FW_NAME' ) ) {
-        die( 'Yellow Duck Framework is not loaded.' );
-    }
-
-	// add YDF libs needed by this class
-	require_once( YD_DIR_HOME_ADD . '/YDDatabaseObject/YDDatabaseObject.php' );
-
-    /**
-     *	This is the actual implementation of the lineage tree algorithm but as an YDDatabaseObject.
-     *
-     *  The DatabaseObjectTree needs to have the following database schema.
-     *  
-     *  @code
-     *	CREATE TABLE nested_tree (
-     *	    id int NOT NULL auto_increment,
-     *	    parent_id int NULL,
-     *	    lineage varchar(255) NOT NULL default '//',
-     *	    level int NOT NULL default '1',
-     *	    position int NOT NULL default '1',
-     *	    title varchar(255) NOT NULL default '',
-     *	    PRIMARY KEY (id),
-     *	    FOREIGN KEY (parent_id)
-     *	        REFERENCES nested_tree(id)
-     *	             ON DELETE CASCADE
-     *	             ON UPDATE CASCADE
-     *	)TYPE=InnoDB;
-     *  @endcode
-     *
-     *  Note: root node must have ID 1, PARENT null and LINEAGE '' !
-     * 
-     *  @code
-     *  INSERT INTO nested_tree VALUES ( 1, null, '',         0, 1, '');
-     *  INSERT INTO nested_tree VALUES ( 2,    1, '//',       1, 1, 'General Resources');
-     *  INSERT INTO nested_tree VALUES ( 3,    2, '//2/',     2, 1, 'Code Paste');
-     *  INSERT INTO nested_tree VALUES ( 4,    2, '//2/',     2, 2, 'Documentation');
-     *  INSERT INTO nested_tree VALUES ( 5,    2, '//2/',     2, 3, 'Books & Publications');
-     *  INSERT INTO nested_tree VALUES ( 6,    5, '//2/5/',   3, 1, 'Apache');
-     *  INSERT INTO nested_tree VALUES ( 7,    5, '//2/5/',   3, 2, 'PostgreSQL');
-     *  INSERT INTO nested_tree VALUES ( 8,    5, '//2/5/',   3, 3, 'MySQL');
-     *  INSERT INTO nested_tree VALUES ( 9,    2, '//2/',     2, 4, 'Links');
-     *  INSERT INTO nested_tree VALUES (10,    9, '//2/9/',   3, 1, 'Databases');
-     *  INSERT INTO nested_tree VALUES (11,    9, '//2/9/',   3, 2, 'Generators');
-     *  INSERT INTO nested_tree VALUES (12,    9, '//2/9/',   3, 3, 'Portals');
-     *  @endcode
-     *
-     *  @ingroup YDDatabaseObjectTree
-     */
-    class YDDatabaseObjectTree extends YDDatabaseObject {
-    
-        function YDDatabaseObjectTree( $table, $db = 'default', $idField = 'id', $parentField = 'parent_id', $lineageField = 'lineage', $levelField = 'level', $positionField = 'position' ) {
-        
-			// init DB object
-            $this->YDDatabaseObject();
-
-			// register database
-            $this->registerDatabase( $db );
-
-			// register table
-            $this->registerTable( $table );
-
-			// register reserved fields
-			$this->registerKey( $idField, true );
-			$this->registerField( $parentField );
-			$this->registerField( $lineageField );
-			$this->registerField( $levelField );
-			$this->registerField( $positionField );
-
-			// save field names for future use
-			$this->__id       = $idField;
-			$this->__parent   = $parentField;
-			$this->__lineage  = $lineageField;
-			$this->__level    = $levelField;
-			$this->__position = $positionField;
-
-			$this->__table_id       = $table . '.' . $idField;
-			$this->__table_parent   = $table . '.' . $parentField;
-			$this->__table_lineage  = $table . '.' . $lineageField;
-			$this->__table_level    = $table . '.' . $levelField;
-			$this->__table_position = $table . '.' . $positionField;
-
-
-			// define a generic tree order
-			$this->setOrder( $this->__table_parent . ' ASC, ' . $this->__table_position . ' ASC' );
-		}
-
-
-        /**
-         *  This function defines the order used in all SELECTS
-         *
-         *  @param $sql  The sql order string.
-         */
-        function setOrder( $sql ){
-
-			return $this->_tree_order = $sql;
-        }
-
-
-        /**
-         *  This function will overide the YDDatabaseObject to reset object but init order
-         */
-		function resetAll(){
-			parent::resetAll();
-			$this->order( $this->_tree_order );
-		}
-
-
-        /**
-         *  Returns the node level based on the lineage string
-         *
-         *  @returns  level int value
-         */
-        function _getLevel( $lineage ) {
-			return substr_count( $lineage, '/' ) - 1;
-        }
-
-
-        /**
-         *  Fetch the node data for the node identified by $id.
-         *
-         *  @param $id      The ID of the node to fetch.
-         *  @param $field   (Optional) The unique field to select on. Defaults to id, which means that the ID field specified
-         *                  when the object was instantiated will be used.
-         *  @param $class   (optional) Relation name
-         *  @param $prefix  (optional) Adds the relation's vars as prefixes to the keys. Default: false.
-         *
-         *  @returns An object containing the node's data, or false if node not found
-         */
-        function getNode( $id, $field = null, $class = null, $prefix = false ) {
-
-			$this->resetAll();
-
-            // get node
-            return $this->_getNode( $id, $field, $class, $prefix );
-        }
-
-
-        /**
-         *  Helper method to fetch a node.
-         *
-         *  @param $id      The ID of the node to fetch.
-         *  @param $field   (optional) The unique field to select on. Defaults to id, which means that the ID field specified
-         *                             when the object was instantiated will be used.
-         *  @param $class   (optional) Relation name
-         *  @param $prefix  (optional) Adds the relation's vars as prefixes to the keys. Default: true.
-         *
-         *  @returns An object containing the node's data, or false if node not found
-         */
-        function _getNode( $id, $field = null, $class = null, $prefix = true ) {
-
-			// if field not defined, field is id
-			if ( is_null( $field ) ) $field = $this->__id;
-	
-			// set local field
-			if ( is_null( $class ) ){
-
-				// set field value
-				$this->set( $field, $id );
-			}else{
-
-				// load relation and set field
-				$this->load( $class );
-				$this->$class->set( $field, $id );
-			}
-
-			// check results
-			if ( $this->findAll() == 0 ) return false;
-
-            // Execute the query and return the record
-            return $this->getValues( false, false, false, $prefix );
-        }
-
-
-        /**
-         *  Fetch the descendants of a node. NOTE: To get all elements use getTreeElements()
-         *
-         *  @param $id              The ID of the node to fetch descendant data for. 
-         *  @param $includeSelf     (optional) Whether or not to include the passed node in results. 
-         *  @param $maxLevel        (optional) Max level to retrieve. Eg: 10 returns all descendants with level smaller than 10; NULL retrieve all descendants.
-         *  @param $prefix          (optional) Adds the relation's vars as prefixes to the keys. Default: false.
-         *
-         *  @returns The descendants of the passed now
-         */
-        function getDescendants( $id, $includeSelf = false, $maxLevel = null, $prefix = false ) {
-
-			// check if we want an invalid id (like 0 or 1)
-			if ( $id < 2 ) return $this->getTreeElements( $prefix );
-
-			$this->resetAll();
-
-			return $this->_getDescendants( $id, $includeSelf, $maxLevel, $prefix );
-		}
-
-
-        /**
-         *  Helper to fetch the descendants of a node
-         *
-         *  @param $id              The ID of the node to fetch descendant data for. 
-         *  @param $includeSelf     (optional) Whether or not to include the passed node in results. 
-         *  @param $maxLevel        (optional) Max level to retrieve. Eg: 10 returns all descendants with level smaller than 10; NULL retrieve all descendants.
-         *  @param $prefix          (optional) Adds the relation's vars as prefixes to the keys. Default: false.
-         *
-         *  @returns The descendants of id
-         */
-        function _getDescendants( $id, $includeSelf = false, $maxLevel = null, $prefix = false ) {
-
-            // get just children
-			if ( $includeSelf == false ) $this->where(       $this->__table_lineage . ' LIKE "%/' . intval( $id ) . '/%"' );
-			else                         $this->where( '(' . $this->__table_lineage . ' LIKE "%/' . intval( $id ) . '/%" OR ' . $this->__table_id . ' = ' . intval( $id ) . ')' );
-
-			// check max level to retrieve
-			if ( is_numeric( $maxLevel ) ) $this->where( $this->__table_level . '<' . intval( $maxLevel ) );
-
-			// find nodes
-			$this->findAll();
-
-			// return all nodes
-			return $this->getResults( false, false, false, $prefix );
-		}
-
-
-        /**
-         *  Fetch all elements of a tree
-         *
-         *  @param $prefix          (optional) Adds the relation's vars as prefixes to the keys. Default: false.
-         *
-         *  @returns All tree nodes
-         */
-        function getTreeElements( $prefix = false ) {
-
-			$this->resetAll();
-
-			return $this->_getTreeElements( $prefix );
-		}
-
-
-        /**
-         *  Helper to fetch all elements of a tree
-         *
-         *  @param $prefix          (optional) Adds the relation's vars as prefixes to the keys. Default: false.
-         *
-         *  @returns All tree nodes
-         */
-        function _getTreeElements( $prefix = false ) {
-
-			// get all elements except root
-			$this->where( $this->__table_id . ' > 1' );
-
-			// find elements
-			$this->findAll();
-
-			// return all nodes
-			return $this->getResults( false, false, false, $prefix );
-		}
-
-
-        /**
-         *  Helper to fetch all elements of a tree as an assocArray
-         *
-         *  @param $columns             (Optional) Columns to retrieve. Default: add columns
-         *  @param $key                 (Optional) Key to use. Default: current table key
-         *
-         *  @returns All tree nodes
-         */
-        function _getTreeElementsAsAssocArray( $columns = array(), $key = null ) {
-
-			// get all elements except root
-			$this->where( $this->__table_id . ' > 1' );
-
-			// find elements
-			$this->findAll();
-
-			// compute key
-			if ( is_null( $key ) ) $key = $this->__id;
-
-			// return all nodes
-			return $this->getResultsAsAssocArray( $key, $columns );
-		}
-
-
-        /**
-         *  Fetch the children of a node, or if no node is specified, fetch the top level items.
-         *
-         *  @param $id             The ID of the node to fetch child data for.
-         *  @param $includeSelf    (optional) Include self node in results. Default: false.
-         *  @param $prefix         (optional) Adds the relation's vars as prefixes to the keys. Default: false.
-         *
-         *  @returns The children of the passed id
-         */
-        function getChildren( $id, $includeSelf = false, $prefix = false ){
-
-			$this->resetAll();
-			
-			return $this->_getChildren( $id, $includeSelf, $prefix );
-        }
-
-
-        /**
-         *  Helper to fetch the children of a node, or if no node is specified, fetch the top level items.
-         *
-         *  @param $id             The ID of the node to fetch child data for.
-         *  @param $includeSelf    (optional) Include self node in results. Default: false.
-         *  @param $prefix         (optional) Adds the relation's vars as prefixes to the keys. Default: false.
-         *
-         *  @returns The children of the passed id
-         */
-        function _getChildren( $id, $includeSelf = false, $prefix = false  ){
-
-            // get just children
-			if ( $includeSelf == false ) $this->where(       $this->__table_parent . ' = ' . intval( $id ) );
-			else                         $this->where( '(' . $this->__table_parent . ' = ' . intval( $id ) . ' OR ' . $this->__table_id . ' = ' . intval( $id ) . ')' );
-
-			$this->findAll();
-
-			return $this->getResults( false, false, false, $prefix );
-        }
-
-
-        /**
-         *  Fetch the path to a node. If an invalid node is passed, an empty array is returned. If a top level node is 
-         *  passed, an array containing on that node is included (if 'includeSelf' is set to true, otherwise an empty
-         *  array).
-         *
-         *  @param $id             The ID of the node to fetch child data for.
-         *  @param $includeSelf    (optional) Whether or not to include the passed node in the the results.
-         *  @param $prefix         (optional) Adds the relation's vars as prefixes to the keys. Default: false.
-         *
-         *  @returns An array of each node to passed node
-         */
-        function getPath( $id, $includeSelf = false, $prefix = false ) {
-
-			$this->resetAll();
-
-			return $this->_getPath( $id, $includeSelf, $prefix );
-        }
-
-
-        /**
-         *  Helper to fetch the path to a node. 
-         *
-         *  @param $id             The ID of the node to fetch child data for.
-         *  @param $includeSelf    (optional) Whether or not to include the passed node in the the results.
-         *  @param $prefix         (optional) Adds the relation's vars as prefixes to the keys. Default: false.
-         *
-         *  @returns An array of each node to passed node
-         */
-        function _getPath( $id, $includeSelf = false, $prefix = false ) {
-
-            // Get the node
-            $node = $this->getNode( intval($id) ) ;
-
-			// reset values of previous getNode()
-			$this->resetAll();
-
-            // No node, return empty array
-            if ( ! $node ) return array();
-
-			// compute parents of this node. Read lineage, delete first '//', last '/', apply 'intval' to all elements and implode
-			$nodes = array_map( 'intval', explode( '/', substr( substr( $node[ $this->__lineage ], 2 ), 0, -1 ) ) );
-
-			// if we want current node too, lets add it to nodes array
-            if ( $includeSelf == true ) $nodes[] = intval( $id );
-
-			// apply where clause
-			$this->where( $this->__table_id . ' IN (' . $this->escapeSqlArray( $nodes ) . ')' );
-
-			$this->findAll();
-
-			return $this->getResults( false, false, false, $prefix );
-        }
-
-
-        /**
-         *  Check if one node descends from another node. If either node is not found, then false is returned.
-         *
-         *  @param $descendant_id  The node that potentially descends
-         *  @param $ancestor_id    The node that is potentially descended from
-         *
-         *  @returns True if $descendant_id descends from $ancestor_id, false otherwise
-         */
-        function isDescendantOf( $descendant_id, $ancestor_id ) {
-
-			// if ancertor is root, element is descendant if exist
-			if ( $ancestor_id == 1 ) return ( $this->getNode( $descendant_id ) != false );
-
-			$this->resetAll();
-			
-			return $this->_isDescendantOf( $descendant_id, $ancestor_id );
-        }
-
-
-        /**
-         *  Helper to check if one node descends from another node.
-         *
-         *  @param $descendant_id  The node that potentially descends
-         *  @param $ancestor_id    The node that is potentially descended from
-         *
-         *  @returns True if $descendant_id descends from $ancestor_id, false otherwise
-         */
-        function _isDescendantOf( $descendant_id, $ancestor_id ) {
-
-			// id must be the descendant
-			$this->set( $this->__id, intval( $descendant_id ) );
-
-			// check if descendant has the ancestor in lineage ;)
-			$this->where( $this->__table_lineage . ' LIKE "%/' . intval( $ancestor_id ) . '/%"' );
-		
-			// get total of rows
-			return ( $this->findAll() == 1 );
-        }
-
-
-        /**
-         *  Check if one node is a child of another node. If either node is not found, then false is returned.
-         *
-         * @param $child_id       The node that is possibly a child
-         * @param $parent_id      The node that is possibly a parent
-         *
-         * @returns True if $child_id is a child of $parent_id, false otherwise
-         */
-        function isChildOf( $child_id, $parent_id ) {
-
-			$this->resetAll();
-
-			// check if there is a id that equals $child_id
-			$this->set( $this->__id, intval( $child_id ) );
-
-			// check if there is a parent that equals $parent_id
-			$this->where( $this->__table_parent . ' = ' . intval( $parent_id ) );
-
-			// get total of rows
-			return ( $this->findAll() == 1 );
-        }
-
-
-        /**
-         *  Find the number of descendants a node has
-         *
-         *  @param $id     The ID of the node to search for.
-         *
-         *  @returns The number of descendants the node has
-         */
-        function numDescendants( $id ) {
-
-			$this->resetAll();
-
-			return $this->_numDescendants( $id );
-        }
-
-
-        /**
-         *  Helper to find the number of descendants a node has
-         *
-         *  @param $id     The ID of the node to search for.
-         *
-         *  @returns The number of descendants the node has
-         */
-        function _numDescendants( $id ) {
-
-			// search all nodes that contains this id in lineage. if node is root, count all nodes
-			if ( $id > 1 ) $this->where( $this->__table_lineage . ' LIKE "%/' . intval( $id ) . '/%"' );
-
-			// find them
-			return $this->findAll();
-        }
-
-
-        /**
-         *  Find the number of children a node has
-         *
-         *  @param $id     The ID of the node to search for. Pass 0 to count the first level items
-         *
-         *  @returns The number of descendants the node has, or -1 if the node isn't found.
-         */
-        function numChildren( $id ) {
-
-			$this->resetAll();
-
-			// search all nodes that contains this id in lineage
-			$this->where( $this->__table_parent . ' = ' . intval( $id ) );
-
-			// find them
-			return $this->findAll();
-        }
-
-
-        /**
-         *  Fetch the immediately family of a node. More specifically, fetch a node's parent, siblings and children. 
-         *
-         * @param $id   The ID of the node to fetch child data for.
-         *
-         * @returns An array of each node in the family
-         */
-        function getImmediateFamily( $id ) {
-
-            // Get the node parent
-            $node = $this->getNode( $id );
-
-            // No node, return empty array
-            if ( ! $node ) return array();
-
-			$this->resetAll();
-
-			// get elements that have parent $parent (this returns current element and brothers), that have id $parent (returns parent), and that have lineage like /$id/ (returns all children)
-			$this->where( '(' . $this->__table_parent . '=' . $node[ $this->__parent ] . ' OR ' . $this->__table_id . ' = ' . $node[ $this->__parent ] . ' OR ' . $this->__table_lineage . ' LIKE "%/' . intval( $id ) . '/%"' . ')' );
-
-			$this->findAll();
-
-            // Execute the query and get the record
-            return $this->getResults();
-        }
-
-
-        /**
-         *  This function adds a node to the database.
-         *
-         *  @param $values      The field values of the node. Do NOT define parent_id here!
-         *  @param $parent_id   The parent ID of the node. If not set, node will be added as a root child (its parent will be 1)
-         *  @param $position    (optional) Node position. If not set, node will be added at the end position
-         *  @param $onDate      (optional) When element of $values is a date (read: array ), we should convert to this format. Default: 'datetimesql'
-         *
-         *  @returns    The ID of the newly inserted node.
-         */
-        function addNode( $values, $parent_id = 1, $position = null, $onDate = 'datetimesql' ) {
-
-			// check values
-			foreach( $values as $element => $value )
-				if ( is_array( $value ) ) $values[ $element ] = YDStringUtil::formatDate( $value, $onDate );
-
-            // compute linege. to do that we must check if we want to add node to root
-            if ( $parent_id == 1 ) { 
-
-				// compute lineage
-				$lineage = '//';
-			}else{
-
-				// get parent lineage and compute node lineage
-				$parent_node = $this->getNode( $parent_id );
-				$lineage     = $parent_node[ $this->__lineage ] . $parent_id . '/';
-			}
-
-			// get how much brothers we will have
-			$total_brothers = $this->numChildren( $parent_id );
-
-			// compute position. If passed in arg we check if really can be that value, otherwise place node at the end
-			if ( !is_numeric( $position ) || intval( $position ) < 1 || intval( $position ) > $total_brothers + 1 )
-				$position = $total_brothers + 1;
-
-			// create an empty position. To do this, if node is not added in the end, we must increment position of nodes that have the same parent and equal or bigger position 
-			if ( $position != $total_brothers + 1 ){
-	
-				$this->resetAll();
-
-				// position field must increment
-				$this->set( $this->__position, $this->__table_position . ' + 1' );
-
-				// only on new brothers with higher or equal position
-				$this->where( '(' . $this->__table_parent . ' = ' . intval( $parent_id ) . ' AND ' .  $this->__table_position . ' >= ' . intval( $position ) . ')' );
-
-				// lets update.
-				$this->update( array(), $this->__position );
-			}
-
-			// reset any previous value to create insert
-			$this->resetAll();
-
-			// apply custom values
-			$this->setValues( $values );
-
-			// override reserved fields
-			$this->set( $this->__parent,   $parent_id );
-			$this->set( $this->__lineage,  $lineage );
-			$this->set( $this->__level,    $this->_getLevel( $lineage ) );
-			$this->set( $this->__position, $position );
-
-			return $this->insert();
-        }
-
-
-        /**
-         *  This function updates a node fields ( that are NOT RESERVED only )
-         *
-         *  @param $values      The field values of the node. Do NOT update position, parent_id, lineage or level
-         *  @param $id          (optional) The ID of the node to update.
-         *  @param $onDate      (optional) When element of $values is a date (read: array ), we should convert to this format. Default: 'datetimesql'
-         *
-         *  @returns    Total of lines affected
-         */
-        function updateNode( $values, $id, $onDate = 'datetimesql' ) {
-
-			// check values
-			foreach( $values as $element => $value )
-				if ( is_array( $value ) ) $values[ $element ] = YDStringUtil::formatDate( $value, $onDate );
-
-			$this->resetAll();
-
-			// apply custom values
-			$this->setValues( $values );
-			
-			// overwrite id
-			$this->set( $this->__id, intval( $id ) );
-
-			// unset reserved fields
-			$this->unsetVar( $this->__parent );
-			$this->unsetVar( $this->__lineage );
-			$this->unsetVar( $this->__level );
-			$this->unsetVar( $this->__position );
-
-			return $this->update();
-        }
-
-
-        /**
-         *  Delete the node and it's children. NOTE: Make shure your table is in InnoDB !
-         *
-         *  @param $id             The ID of the node to delete.
-         *  @param $deleteAll     (Optional) Delete id and all children (true by default. if false, deletes children only)
-         *
-         *  @returns    Total of lines affected
-         */
-        function deleteNode( $id, $deleteAll = true ) {
-
-            // if we want to delete $id (and all children) we must update positions in all $id brothers after delete
-			if ( $deleteAll ){
-
-	            // get node details before delete. we must know the position
-	            $node = $this->getNode( $id );
-
-				$this->resetAll();
-
-				$this->set( $this->__id, intval( $id ) );
-
-				// if delete didn't affect any rows we don't need to update brothers
-				$total = $this->delete();
-				
-				if ( $total == 0 ) return 0;
-
-				$this->resetAll();
-
-				// decrease positions
-				$this->set( $this->__position, $this->__table_position . ' - 1' );
-
-				// in all elements with same parent AND position bigger than our
-				$this->where( '(' . $this->__table_parent . ' = ' . intval( $node[ $this->__parent ] ) . ' AND ' . $this->__table_position . ' > ' . intval( $node[ $this->__position ] ) . ')' );
-
-				$this->update( array(), $this->__position );
-				
-				return $total;
-			}
-
-			// here we want do delete child only
-			$this->resetAll();
-
-			// we only need to delete children. Children of children will be deleted when mysql is InnoDB
-			$this->where( $this->__table_parent . ' = ' . intval( $id ) );
-
-			return $this->delete();
-        }
-
-
-        /**
-         *  Move a node to a different parent node.
-         *
-         *  @param  $id             The ID of the node to move
-         *  @param  $new_parent_id  (optional) The ID of the new parent node. If not set, will be moved in same parent
-         *  @param  $new_position   (optional) The new position.
-         */
-        function moveNode( $id, $new_parent_id = null, $new_position = null ) {
-
-            // get old node details before move
-            $old_node      = $this->getNode( $id );
-            $old_parent_id = $old_node[ $this->__parent ];
-            $old_position  = $old_node[ $this->__position ];
-            $old_lineage   = $old_node[ $this->__lineage ];
-
-			// compute new parent id
-			if ( ! is_numeric( $new_parent_id ) ) $new_parent_id = $old_parent_id;
-
-			// if position not set, we will move node to the end of the new parent
-			$total_new_brothers = $this->numChildren( $new_parent_id );
-
-			// if custom position is not valid add node at end
-			if ( ! is_numeric( $new_position ) || intval( $new_position ) < 1 || intval( $new_position ) > $total_new_brothers + 1 )
-				$new_position = 1 + $total_new_brothers;
-
-			// get information of old parent
-            $old_parent_node = $this->getNode( $old_parent_id );
-
-			// get information of new parent if diferent than old parent
-			if ( $new_parent_id == $old_parent_id ) $new_parent_node = $old_parent_node;
-            else                                    $new_parent_node = $this->getNode( $new_parent_id );
-
-
-			// only update positions if new parent and old parent are not the same OR if (they are same but) positions are not changed
-			if ( $new_parent_id != $old_parent_id || $new_position != $old_position ){
-
-				// decrease positions of old brothers that have position bigger than this node position
-				$this->resetAll();
-				$this->set( $this->__position, $this->__table_position . ' - 1' );
-				$this->where( '(' . $this->__table_parent . ' = ' . $old_parent_id . ' AND ' . $this->__table_position . ' > ' . $old_position . ')' );
-				$this->update( array(), $this->__position );
-
-				// add position space for this node in new parent: increase positions of new brothers that have position bigger than this node position
-				$this->resetAll();
-				$this->set( $this->__position, $this->__table_position . ' + 1' );
-				$this->where( '(' . $this->__table_parent . ' = ' . $new_parent_id . ' AND ' . $this->__table_position . ' >= ' . $new_position . ')' );
-				$this->update( array(), $this->__position );
-			}
-
-			// compute lineage
-			if ( $new_parent_id == 1 ) $new_lineage = '//';
-			else                       $new_lineage = $new_parent_node[ $this->__lineage ] . $new_parent_id . '/';
-
-			// update node
-			$this->resetAll();
-			$this->set( $this->__id,       intval( $id ) );
-			$this->set( $this->__parent,   intval( $new_parent_id ) );
-			$this->set( $this->__lineage,  $new_lineage );
-			$this->set( $this->__level,    $this->_getLevel( $new_lineage ) );
-			$this->set( $this->__position, intval( $new_position ) );
-			$res = $this->update();
-			
-			// update lineages of node descendants ;)
-			if ( $new_parent_id != $old_parent_id ){
-				$this->resetAll();
-				$this->set( $this->__lineage, 'REPLACE(' . $this->__table_lineage . ',"' . $old_lineage . $id . '/","' . $new_lineage . $id . '/")' );
-				$this->where( $this->__table_id . ' > 1 ' );
-				$this->update( array(), $this->__lineage );
-			}
-
-			return $res;
-        }
-
-
-        /**
-         *  Fetch an array of tree nodes containing a traversal of the tree. 
-         *
-         * @param $id   (optional) The ID of the node to fetch child data for.
-         *
-         * @returns An array of each node in the tree
-         */
-		function getTraversedTree( $id = 1 ) {
-		
-			$this->_tree_data = $this->getTreeElements();
-			$this->_tree_data_keys = array_keys( $this->_tree_data );
-		
-			return $this->_getTraversedTree( $id );
-		}
-
-
-        /**
-         *  Helper function to get traversal of tree. 
-         *
-         * @param $id   (optional) The ID of the node to fetch child data for.
-         *
-         * @returns An array of each node in the tree
-         */
-		function _getTraversedTree( $id = 1 ) {
-		
-			$key_match = false;
-			
-			foreach ( $this->_tree_data_keys as $key ) {
-				if ( $this->_tree_data[$key]['id'] == $id ) {
-					$key_match = true;
-					$ref = & $this->_tree_data[$key];
-					break;
-				}
-			}
-			
-			if ( $key_match ) {
-				$result = array( $ref );
-			} else {
-				$result = array();
-			}
-			
-			$children = $this->getChildren ( $id, true );
-			
-			foreach ( $children as $child ) {			
-				$child_ids = $this->getTraversedTree( $child['id'] );				
-				$result = array_merge( $result, $child_ids );
-			}
-						
-			return $result;
-		}
-		
-
-    }
+<?php
+
+    /*
+
+        Yellow Duck Framework version 2.1
+        (c) Copyright 2002-2007 Pieter Claerhout
+
+        This library is free software; you can redistribute it and/or
+        modify it under the terms of the GNU Lesser General Public
+        License as published by the Free Software Foundation; either
+        version 2.1 of the License, or (at your option) any later version.
+
+        This library is distributed in the hope that it will be useful,
+        but WITHOUT ANY WARRANTY; without even the implied warranty of
+        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+        Lesser General Public License for more details.
+
+        You should have received a copy of the GNU Lesser General Public
+        License along with this library; if not, write to the Free Software
+        Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+
+    */
+
+    /**
+     *  @addtogroup YDDatabaseObjectTree Addons - DatabaseObjectTree
+     */
+
+    // Check if the framework is loaded
+    if ( ! defined( 'YD_FW_NAME' ) ) {
+        die( 'Yellow Duck Framework is not loaded.' );
+    }
+
+	// add YDF libs needed by this class
+	require_once( YD_DIR_HOME_ADD . '/YDDatabaseObject/YDDatabaseObject.php' );
+
+    /**
+     *	This is the actual implementation of the lineage tree algorithm but as an YDDatabaseObject.
+     *
+     *  The DatabaseObjectTree needs to have the following database schema.
+     *  
+     *  @code
+     *	CREATE TABLE nested_tree (
+     *	    id int NOT NULL auto_increment,
+     *	    parent_id int NULL,
+     *	    lineage varchar(255) NOT NULL default '//',
+     *	    level int NOT NULL default '1',
+     *	    position int NOT NULL default '1',
+     *	    title varchar(255) NOT NULL default '',
+     *	    PRIMARY KEY (id),
+     *	    FOREIGN KEY (parent_id)
+     *	        REFERENCES nested_tree(id)
+     *	             ON DELETE CASCADE
+     *	             ON UPDATE CASCADE
+     *	)TYPE=InnoDB;
+     *  @endcode
+     *
+     *  Note: root node must have ID 1, PARENT null and LINEAGE '' !
+     * 
+     *  @code
+     *  INSERT INTO nested_tree VALUES ( 1, null, '',         0, 1, '');
+     *  INSERT INTO nested_tree VALUES ( 2,    1, '//',       1, 1, 'General Resources');
+     *  INSERT INTO nested_tree VALUES ( 3,    2, '//2/',     2, 1, 'Code Paste');
+     *  INSERT INTO nested_tree VALUES ( 4,    2, '//2/',     2, 2, 'Documentation');
+     *  INSERT INTO nested_tree VALUES ( 5,    2, '//2/',     2, 3, 'Books & Publications');
+     *  INSERT INTO nested_tree VALUES ( 6,    5, '//2/5/',   3, 1, 'Apache');
+     *  INSERT INTO nested_tree VALUES ( 7,    5, '//2/5/',   3, 2, 'PostgreSQL');
+     *  INSERT INTO nested_tree VALUES ( 8,    5, '//2/5/',   3, 3, 'MySQL');
+     *  INSERT INTO nested_tree VALUES ( 9,    2, '//2/',     2, 4, 'Links');
+     *  INSERT INTO nested_tree VALUES (10,    9, '//2/9/',   3, 1, 'Databases');
+     *  INSERT INTO nested_tree VALUES (11,    9, '//2/9/',   3, 2, 'Generators');
+     *  INSERT INTO nested_tree VALUES (12,    9, '//2/9/',   3, 3, 'Portals');
+     *  @endcode
+     *
+     *  @ingroup YDDatabaseObjectTree
+     */
+    class YDDatabaseObjectTree extends YDDatabaseObject {
+    
+        function YDDatabaseObjectTree( $table, $db = 'default', $idField = 'id', $parentField = 'parent_id', $lineageField = 'lineage', $levelField = 'level', $positionField = 'position' ) {
+        
+			// init DB object
+            $this->YDDatabaseObject();
+
+			// register database
+            $this->registerDatabase( $db );
+
+			// register table
+            $this->registerTable( $table );
+
+			// register reserved fields
+			$this->registerKey( $idField, true );
+			$this->registerField( $parentField );
+			$this->registerField( $lineageField );
+			$this->registerField( $levelField );
+			$this->registerField( $positionField );
+
+			// save field names for future use
+			$this->__id       = $idField;
+			$this->__parent   = $parentField;
+			$this->__lineage  = $lineageField;
+			$this->__level    = $levelField;
+			$this->__position = $positionField;
+
+			$this->__table_id       = $table . '.' . $idField;
+			$this->__table_parent   = $table . '.' . $parentField;
+			$this->__table_lineage  = $table . '.' . $lineageField;
+			$this->__table_level    = $table . '.' . $levelField;
+			$this->__table_position = $table . '.' . $positionField;
+
+
+			// define a generic tree order
+			$this->setOrder( $this->__table_level . ' ASC,' . $this->__table_position . ' ASC' );
+		}
+
+
+        /**
+         *  This function defines the order used in all SELECTS
+         *
+         *  @param $sql  The sql order string.
+         */
+        function setOrder( $sql ){
+
+			return $this->_tree_order = $sql;
+        }
+
+
+        /**
+         *  This function will overide the YDDatabaseObject to reset object but init order
+         */
+		function resetAll(){
+			parent::resetAll();
+			$this->order( $this->_tree_order );
+		}
+
+
+        /**
+         *  Returns the node level based on the lineage string
+         *
+         *  @returns  level int value
+         */
+        function _getLevel( $lineage ) {
+			return substr_count( $lineage, '/' ) - 1;
+        }
+
+
+        /**
+         *  Fetch the node data for the node identified by $id.
+         *
+         *  @param $id      The ID of the node to fetch.
+         *  @param $field   (Optional) The unique field to select on. Defaults to id, which means that the ID field specified
+         *                  when the object was instantiated will be used.
+         *  @param $class   (optional) Relation name
+         *  @param $prefix  (optional) Adds the relation's vars as prefixes to the keys. Default: false.
+         *
+         *  @returns An object containing the node's data, or false if node not found
+         */
+        function getNode( $id, $field = null, $class = null, $prefix = false ) {
+
+			$this->resetAll();
+
+            // get node
+            return $this->_getNode( $id, $field, $class, $prefix );
+        }
+
+
+        /**
+         *  Helper method to fetch a node.
+         *
+         *  @param $id      The ID of the node to fetch.
+         *  @param $field   (optional) The unique field to select on. Defaults to id, which means that the ID field specified
+         *                             when the object was instantiated will be used.
+         *  @param $class   (optional) Relation name
+         *  @param $prefix  (optional) Adds the relation's vars as prefixes to the keys. Default: true.
+         *
+         *  @returns An object containing the node's data, or false if node not found
+         */
+        function _getNode( $id, $field = null, $class = null, $prefix = true ) {
+
+			// if field not defined, field is id
+			if ( is_null( $field ) ) $field = $this->__id;
+	
+			// set local field
+			if ( is_null( $class ) ){
+
+				// set field value
+				$this->set( $field, $id );
+			}else{
+
+				// load relation and set field
+				$this->load( $class );
+				$this->$class->set( $field, $id );
+			}
+
+			// check results
+			if ( $this->findAll() == 0 ) return false;
+
+            // Execute the query and return the record
+            return $this->getValues( false, false, false, $prefix );
+        }
+
+
+        /**
+         *  Fetch the descendants of a node. NOTE: To get all elements use getTreeElements()
+         *
+         *  @param $id              The ID of the node to fetch descendant data for. 
+         *  @param $includeSelf     (optional) Whether or not to include the passed node in results. 
+         *  @param $maxLevel        (optional) Max level to retrieve. Eg: 10 returns all descendants with level smaller than 10; NULL retrieve all descendants.
+         *  @param $prefix          (optional) Adds the relation's vars as prefixes to the keys. Default: false.
+         *
+         *  @returns The descendants of the passed now
+         */
+        function getDescendants( $id, $includeSelf = false, $maxLevel = null, $prefix = false ) {
+
+			// check if we want an invalid id (like 0 or 1)
+			if ( $id < 2 ) return $this->getTreeElements( $prefix );
+
+			$this->resetAll();
+
+			return $this->_getDescendants( $id, $includeSelf, $maxLevel, $prefix );
+		}
+
+
+        /**
+         *  Helper to fetch the descendants of a node
+         *
+         *  @param $id              The ID of the node to fetch descendant data for. 
+         *  @param $includeSelf     (optional) Whether or not to include the passed node in results. 
+         *  @param $maxLevel        (optional) Max level to retrieve. Eg: 10 returns all descendants with level smaller than 10; NULL retrieve all descendants.
+         *  @param $prefix          (optional) Adds the relation's vars as prefixes to the keys. Default: false.
+         *
+         *  @returns The descendants of id
+         */
+        function _getDescendants( $id, $includeSelf = false, $maxLevel = null, $prefix = false ) {
+
+            // get just children
+			if ( $includeSelf == false ) $this->where(       $this->__table_lineage . ' LIKE "%/' . intval( $id ) . '/%"' );
+			else                         $this->where( '(' . $this->__table_lineage . ' LIKE "%/' . intval( $id ) . '/%" OR ' . $this->__table_id . ' = ' . intval( $id ) . ')' );
+
+			// check max level to retrieve
+			if ( is_numeric( $maxLevel ) ) $this->where( $this->__table_level . '<' . intval( $maxLevel ) );
+
+			// find nodes
+			$this->findAll();
+
+			// return all nodes
+			return $this->getResults( false, false, false, $prefix );
+		}
+
+
+        /**
+         *  Fetch all elements of a tree
+         *
+         *  @param $prefix          (optional) Adds the relation's vars as prefixes to the keys. Default: false.
+         *
+         *  @returns All tree nodes
+         */
+        function getTreeElements( $prefix = false ) {
+
+			$this->resetAll();
+
+			return $this->_getTreeElements( $prefix );
+		}
+
+
+        /**
+         *  Helper to fetch all elements of a tree
+         *
+         *  @param $prefix          (optional) Adds the relation's vars as prefixes to the keys. Default: false.
+         *
+         *  @returns All tree nodes
+         */
+        function _getTreeElements( $prefix = false ) {
+
+			// get all elements except root
+			$this->where( $this->__table_id . ' > 1' );
+
+			// find elements
+			$this->findAll();
+
+			// return all nodes
+			return $this->getResults( false, false, false, $prefix );
+		}
+
+
+        /**
+         *  Helper to fetch all elements of a tree as an assocArray
+         *
+         *  @param $columns             (Optional) Columns to retrieve. Default: add columns
+         *  @param $key                 (Optional) Key to use. Default: current table key
+         *
+         *  @returns All tree nodes
+         */
+        function _getTreeElementsAsAssocArray( $columns = array(), $key = null ) {
+
+			// get all elements except root
+			$this->where( $this->__table_id . ' > 1' );
+
+			// find elements
+			$this->findAll();
+
+			// compute key
+			if ( is_null( $key ) ) $key = $this->__id;
+
+			// return all nodes
+			return $this->getResultsAsAssocArray( $key, $columns );
+		}
+
+
+        /**
+         *  Fetch the children of a node, or if no node is specified, fetch the top level items.
+         *
+         *  @param $id             The ID of the node to fetch child data for.
+         *  @param $includeSelf    (optional) Include self node in results. Default: false.
+         *  @param $prefix         (optional) Adds the relation's vars as prefixes to the keys. Default: false.
+         *
+         *  @returns The children of the passed id
+         */
+        function getChildren( $id, $includeSelf = false, $prefix = false ){
+
+			$this->resetAll();
+			
+			return $this->_getChildren( $id, $includeSelf, $prefix );
+        }
+
+
+        /**
+         *  Helper to fetch the children of a node, or if no node is specified, fetch the top level items.
+         *
+         *  @param $id             The ID of the node to fetch child data for.
+         *  @param $includeSelf    (optional) Include self node in results. Default: false.
+         *  @param $prefix         (optional) Adds the relation's vars as prefixes to the keys. Default: false.
+         *
+         *  @returns The children of the passed id
+         */
+        function _getChildren( $id, $includeSelf = false, $prefix = false  ){
+
+            // get just children
+			if ( $includeSelf == false ) $this->where(       $this->__table_parent . ' = ' . intval( $id ) );
+			else                         $this->where( '(' . $this->__table_parent . ' = ' . intval( $id ) . ' OR ' . $this->__table_id . ' = ' . intval( $id ) . ')' );
+
+			$this->findAll();
+
+			return $this->getResults( false, false, false, $prefix );
+        }
+
+
+        /**
+         *  Fetch the path to a node. If an invalid node is passed, an empty array is returned. If a top level node is 
+         *  passed, an array containing on that node is included (if 'includeSelf' is set to true, otherwise an empty
+         *  array).
+         *
+         *  @param $id             The ID of the node to fetch child data for.
+         *  @param $includeSelf    (optional) Whether or not to include the passed node in the the results.
+         *  @param $prefix         (optional) Adds the relation's vars as prefixes to the keys. Default: false.
+         *
+         *  @returns An array of each node to passed node
+         */
+        function getPath( $id, $includeSelf = false, $prefix = false ) {
+
+			$this->resetAll();
+
+			return $this->_getPath( $id, $includeSelf, $prefix );
+        }
+
+
+        /**
+         *  Helper to fetch the path to a node. 
+         *
+         *  @param $id             The ID of the node to fetch child data for.
+         *  @param $includeSelf    (optional) Whether or not to include the passed node in the the results.
+         *  @param $prefix         (optional) Adds the relation's vars as prefixes to the keys. Default: false.
+         *
+         *  @returns An array of each node to passed node
+         */
+        function _getPath( $id, $includeSelf = false, $prefix = false ) {
+
+            // Get the node
+            $node = $this->getNode( intval($id) ) ;
+
+			// reset values of previous getNode()
+			$this->resetAll();
+
+            // No node, return empty array
+            if ( ! $node ) return array();
+
+			// compute parents of this node. Read lineage, delete first '//', last '/', apply 'intval' to all elements and implode
+			$nodes = array_map( 'intval', explode( '/', substr( substr( $node[ $this->__lineage ], 2 ), 0, -1 ) ) );
+
+			// if we want current node too, lets add it to nodes array
+            if ( $includeSelf == true ) $nodes[] = intval( $id );
+
+			// apply where clause
+			$this->where( $this->__table_id . ' IN (' . $this->escapeSqlArray( $nodes ) . ')' );
+
+			$this->findAll();
+
+			return $this->getResults( false, false, false, $prefix );
+        }
+
+
+        /**
+         *  Check if one node descends from another node. If either node is not found, then false is returned.
+         *
+         *  @param $descendant_id  The node that potentially descends
+         *  @param $ancestor_id    The node that is potentially descended from
+         *
+         *  @returns True if $descendant_id descends from $ancestor_id, false otherwise
+         */
+        function isDescendantOf( $descendant_id, $ancestor_id ) {
+
+			// if ancertor is root, element is descendant if exist
+			if ( $ancestor_id == 1 ) return ( $this->getNode( $descendant_id ) != false );
+
+			$this->resetAll();
+			
+			return $this->_isDescendantOf( $descendant_id, $ancestor_id );
+        }
+
+
+        /**
+         *  Helper to check if one node descends from another node.
+         *
+         *  @param $descendant_id  The node that potentially descends
+         *  @param $ancestor_id    The node that is potentially descended from
+         *
+         *  @returns True if $descendant_id descends from $ancestor_id, false otherwise
+         */
+        function _isDescendantOf( $descendant_id, $ancestor_id ) {
+
+			// id must be the descendant
+			$this->set( $this->__id, intval( $descendant_id ) );
+
+			// check if descendant has the ancestor in lineage ;)
+			$this->where( $this->__table_lineage . ' LIKE "%/' . intval( $ancestor_id ) . '/%"' );
+		
+			// get total of rows
+			return ( $this->findAll() == 1 );
+        }
+
+
+        /**
+         *  Check if one node is a child of another node. If either node is not found, then false is returned.
+         *
+         * @param $child_id       The node that is possibly a child
+         * @param $parent_id      The node that is possibly a parent
+         *
+         * @returns True if $child_id is a child of $parent_id, false otherwise
+         */
+        function isChildOf( $child_id, $parent_id ) {
+
+			$this->resetAll();
+
+			// check if there is a id that equals $child_id
+			$this->set( $this->__id, intval( $child_id ) );
+
+			// check if there is a parent that equals $parent_id
+			$this->where( $this->__table_parent . ' = ' . intval( $parent_id ) );
+
+			// get total of rows
+			return ( $this->findAll() == 1 );
+        }
+
+
+        /**
+         *  Find the number of descendants a node has
+         *
+         *  @param $id     The ID of the node to search for.
+         *
+         *  @returns The number of descendants the node has
+         */
+        function numDescendants( $id ) {
+
+			$this->resetAll();
+
+			return $this->_numDescendants( $id );
+        }
+
+
+        /**
+         *  Helper to find the number of descendants a node has
+         *
+         *  @param $id     The ID of the node to search for.
+         *
+         *  @returns The number of descendants the node has
+         */
+        function _numDescendants( $id ) {
+
+			// search all nodes that contains this id in lineage. if node is root, count all nodes
+			if ( $id > 1 ) $this->where( $this->__table_lineage . ' LIKE "%/' . intval( $id ) . '/%"' );
+
+			// find them
+			return $this->findAll();
+        }
+
+
+        /**
+         *  Find the number of children a node has
+         *
+         *  @param $id     The ID of the node to search for. Pass 0 to count the first level items
+         *
+         *  @returns The number of descendants the node has, or -1 if the node isn't found.
+         */
+        function numChildren( $id ) {
+
+			$this->resetAll();
+
+			// search all nodes that contains this id in lineage
+			$this->where( $this->__table_parent . ' = ' . intval( $id ) );
+
+			// find them
+			return $this->findAll();
+        }
+
+
+        /**
+         *  Fetch the immediately family of a node. More specifically, fetch a node's parent, siblings and children. 
+         *
+         * @param $id   The ID of the node to fetch child data for.
+         *
+         * @returns An array of each node in the family
+         */
+        function getImmediateFamily( $id ) {
+
+            // Get the node parent
+            $node = $this->getNode( $id );
+
+            // No node, return empty array
+            if ( ! $node ) return array();
+
+			$this->resetAll();
+
+			// get elements that have parent $parent (this returns current element and brothers), that have id $parent (returns parent), and that have lineage like /$id/ (returns all children)
+			$this->where( '(' . $this->__table_parent . '=' . $node[ $this->__parent ] . ' OR ' . $this->__table_id . ' = ' . $node[ $this->__parent ] . ' OR ' . $this->__table_lineage . ' LIKE "%/' . intval( $id ) . '/%"' . ')' );
+
+			$this->findAll();
+
+            // Execute the query and get the record
+            return $this->getResults();
+        }
+
+
+        /**
+         *  This function adds a node to the database.
+         *
+         *  @param $values      The field values of the node. Do NOT define parent_id here!
+         *  @param $parent_id   The parent ID of the node. If not set, node will be added as a root child (its parent will be 1)
+         *  @param $position    (optional) Node position. If not set, node will be added at the end position
+         *  @param $onDate      (optional) When element of $values is a date (read: array ), we should convert to this format. Default: 'datetimesql'
+         *
+         *  @returns    The ID of the newly inserted node.
+         */
+        function addNode( $values, $parent_id = 1, $position = null, $onDate = 'datetimesql' ) {
+
+			// check values
+			foreach( $values as $element => $value )
+				if ( is_array( $value ) ) $values[ $element ] = YDStringUtil::formatDate( $value, $onDate );
+
+            // compute linege. to do that we must check if we want to add node to root
+            if ( $parent_id == 1 ) { 
+
+				// compute lineage
+				$lineage = '//';
+			}else{
+
+				// get parent lineage and compute node lineage
+				$parent_node = $this->getNode( $parent_id );
+				$lineage     = $parent_node[ $this->__lineage ] . $parent_id . '/';
+			}
+
+			// get how much brothers we will have
+			$total_brothers = $this->numChildren( $parent_id );
+
+			// compute position. If passed in arg we check if really can be that value, otherwise place node at the end
+			if ( !is_numeric( $position ) || intval( $position ) < 1 || intval( $position ) > $total_brothers + 1 )
+				$position = $total_brothers + 1;
+
+			// create an empty position. To do this, if node is not added in the end, we must increment position of nodes that have the same parent and equal or bigger position 
+			if ( $position != $total_brothers + 1 ){
+	
+				$this->resetAll();
+
+				// position field must increment
+				$this->set( $this->__position, $this->__table_position . ' + 1' );
+
+				// only on new brothers with higher or equal position
+				$this->where( '(' . $this->__table_parent . ' = ' . intval( $parent_id ) . ' AND ' .  $this->__table_position . ' >= ' . intval( $position ) . ')' );
+
+				// lets update.
+				$this->update( array(), $this->__position );
+			}
+
+			// reset any previous value to create insert
+			$this->resetAll();
+
+			// apply custom values
+			$this->setValues( $values );
+
+			// override reserved fields
+			$this->set( $this->__parent,   $parent_id );
+			$this->set( $this->__lineage,  $lineage );
+			$this->set( $this->__level,    $this->_getLevel( $lineage ) );
+			$this->set( $this->__position, $position );
+
+			return $this->insert();
+        }
+
+
+        /**
+         *  This function updates a node fields ( that are NOT RESERVED only )
+         *
+         *  @param $values      The field values of the node. Do NOT update position, parent_id, lineage or level
+         *  @param $id          (optional) The ID of the node to update.
+         *  @param $onDate      (optional) When element of $values is a date (read: array ), we should convert to this format. Default: 'datetimesql'
+         *
+         *  @returns    Total of lines affected
+         */
+        function updateNode( $values, $id, $onDate = 'datetimesql' ) {
+
+			// check values
+			foreach( $values as $element => $value )
+				if ( is_array( $value ) ) $values[ $element ] = YDStringUtil::formatDate( $value, $onDate );
+
+			$this->resetAll();
+
+			// apply custom values
+			$this->setValues( $values );
+			
+			// overwrite id
+			$this->set( $this->__id, intval( $id ) );
+
+			// unset reserved fields
+			$this->unsetVar( $this->__parent );
+			$this->unsetVar( $this->__lineage );
+			$this->unsetVar( $this->__level );
+			$this->unsetVar( $this->__position );
+
+			return $this->update();
+        }
+
+
+        /**
+         *  Delete the node and it's children. NOTE: Make shure your table is in InnoDB !
+         *
+         *  @param $id             The ID of the node to delete.
+         *  @param $deleteAll     (Optional) Delete id and all children (true by default. if false, deletes children only)
+         *
+         *  @returns    Total of lines affected
+         */
+        function deleteNode( $id, $deleteAll = true ) {
+
+            // if we want to delete $id (and all children) we must update positions in all $id brothers after delete
+			if ( $deleteAll ){
+
+	            // get node details before delete. we must know the position
+	            $node = $this->getNode( $id );
+
+				$this->resetAll();
+
+				$this->set( $this->__id, intval( $id ) );
+
+				// if delete didn't affect any rows we don't need to update brothers
+				$total = $this->delete();
+				
+				if ( $total == 0 ) return 0;
+
+				$this->resetAll();
+
+				// decrease positions
+				$this->set( $this->__position, $this->__table_position . ' - 1' );
+
+				// in all elements with same parent AND position bigger than our
+				$this->where( '(' . $this->__table_parent . ' = ' . intval( $node[ $this->__parent ] ) . ' AND ' . $this->__table_position . ' > ' . intval( $node[ $this->__position ] ) . ')' );
+
+				$this->update( array(), $this->__position );
+				
+				return $total;
+			}
+
+			// here we want do delete child only
+			$this->resetAll();
+
+			// we only need to delete children. Children of children will be deleted when mysql is InnoDB
+			$this->where( $this->__table_parent . ' = ' . intval( $id ) );
+
+			return $this->delete();
+        }
+
+
+        /**
+         *  Move a node upper (decreasing the position on same parent).
+         *
+         *  @param  $id             The ID of the node to move
+         */
+		function moveNodeUp( $id ){
+
+			// get current node position
+			$node = $this->getNode( $id );
+
+			// check if node can be moved up
+			if ( $node[ $this->__position ] < 2 ) return false;
+			
+			return $this->moveNode( $id, null, $node[ $this->__position ] - 1 );
+		}
+
+
+        /**
+         *  Move a node upper (decreasing the position on same parent).
+         *
+         *  @param  $id             The ID of the node to move
+         */
+		function moveNodeDown( $id ){
+
+			// get current node position
+			$node = $this->getNode( $id );
+
+			return $this->moveNode( $id, null, $node[ $this->__position ] + 1 );
+		}
+
+
+        /**
+         *  Move a node to a different parent node.
+         *
+         *  @param  $id             The ID of the node to move
+         *  @param  $new_parent_id  (optional) The ID of the new parent node. If not set, will be moved in same parent
+         *  @param  $new_position   (optional) The new position.
+         */
+        function moveNode( $id, $new_parent_id = null, $new_position = null ) {
+
+            // get old node details before move
+            $old_node      = $this->getNode( $id );
+            $old_parent_id = $old_node[ $this->__parent ];
+            $old_position  = $old_node[ $this->__position ];
+            $old_lineage   = $old_node[ $this->__lineage ];
+
+			// compute new parent id
+			if ( ! is_numeric( $new_parent_id ) ) $new_parent_id = $old_parent_id;
+
+			// if position not set, we will move node to the end of the new parent
+			$total_new_brothers = $this->numChildren( $new_parent_id );
+
+			// if custom position is not valid add node at end
+			if ( ! is_numeric( $new_position ) || intval( $new_position ) < 1 || intval( $new_position ) > $total_new_brothers + 1 )
+				$new_position = 1 + $total_new_brothers;
+
+			// get information of old parent
+            $old_parent_node = $this->getNode( $old_parent_id );
+
+			// get information of new parent if diferent than old parent
+			if ( $new_parent_id == $old_parent_id ) $new_parent_node = $old_parent_node;
+            else                                    $new_parent_node = $this->getNode( $new_parent_id );
+
+
+			// only update positions if new parent and old parent are not the same OR if (they are same but) positions are not changed
+			if ( $new_parent_id != $old_parent_id || $new_position != $old_position ){
+
+				// decrease positions of old brothers that have position bigger than this node position
+				$this->resetAll();
+				$this->set( $this->__position, $this->__table_position . ' - 1' );
+				$this->where( '(' . $this->__table_parent . ' = ' . $old_parent_id . ' AND ' . $this->__table_position . ' > ' . $old_position . ')' );
+				$this->update( array(), $this->__position );
+
+				// add position space for this node in new parent: increase positions of new brothers that have position bigger than this node position
+				$this->resetAll();
+				$this->set( $this->__position, $this->__table_position . ' + 1' );
+				$this->where( '(' . $this->__table_parent . ' = ' . $new_parent_id . ' AND ' . $this->__table_position . ' >= ' . $new_position . ')' );
+				$this->update( array(), $this->__position );
+			}
+
+			// compute lineage
+			if ( $new_parent_id == 1 ) $new_lineage = '//';
+			else                       $new_lineage = $new_parent_node[ $this->__lineage ] . $new_parent_id . '/';
+
+			// update node
+			$this->resetAll();
+			$this->set( $this->__id,       intval( $id ) );
+			$this->set( $this->__parent,   intval( $new_parent_id ) );
+			$this->set( $this->__lineage,  $new_lineage );
+			$this->set( $this->__level,    $this->_getLevel( $new_lineage ) );
+			$this->set( $this->__position, intval( $new_position ) );
+			$res = $this->update();
+			
+			// update lineages of node descendants ;)
+			if ( $new_parent_id != $old_parent_id ){
+				$this->resetAll();
+				$this->set( $this->__lineage, 'REPLACE(' . $this->__table_lineage . ',"' . $old_lineage . $id . '/","' . $new_lineage . $id . '/")' );
+				$this->where( $this->__table_id . ' > 1 ' );
+				$this->update( array(), $this->__lineage );
+
+				// update levels of node descendants
+				$new_level = $this->_getLevel( $new_lineage );
+				$old_level = $this->_getLevel( $old_lineage );
+
+				$diff_level = $new_level - $old_level;
+
+				$this->resetAll();
+
+				if ( $diff_level > 0 ) $this->set( $this->__level, $this->__level . '+' . abs( $diff_level ) );
+				else                   $this->set( $this->__level, $this->__level . '-' . abs( $diff_level ) );
+
+				$this->where( $this->__table_lineage . ' LIKE "%/' . intval( $id ) . '/%"' );
+				$this->update(array(), $this->__level );
+			}
+
+			return $res;
+        }
+
+
+        /**
+         *  Fetch an array of tree nodes containing a traversal of the tree. 
+         *
+         * @param $id   (optional) The ID of the node to fetch child data for.
+         *
+         * @returns An array of each node in the tree
+         */
+		function getTraversedTree( $id = 1 ) {
+		
+			$this->_tree_data = $this->getTreeElements();
+			$this->_tree_data_keys = array_keys( $this->_tree_data );
+		
+			return $this->_getTraversedTree( $id );
+		}
+
+
+        /**
+         *  Helper function to get traversal of tree. 
+         *
+         * @param $id   (optional) The ID of the node to fetch child data for.
+         *
+         * @returns An array of each node in the tree
+         */
+		function _getTraversedTree( $id = 1 ) {
+		
+			$key_match = false;
+			
+			foreach ( $this->_tree_data_keys as $key ) {
+				if ( $this->_tree_data[$key]['id'] == $id ) {
+					$key_match = true;
+					$ref = & $this->_tree_data[$key];
+					break;
+				}
+			}
+			
+			if ( $key_match ) {
+				$result = array( $ref );
+			} else {
+				$result = array();
+			}
+			
+			$children = $this->getChildren ( $id, true );
+			
+			foreach ( $children as $child ) {			
+				$child_ids = $this->getTraversedTree( $child['id'] );				
+				$result = array_merge( $result, $child_ids );
+			}
+						
+			return $result;
+		}
+		
+
+    }
 ?>
\ No newline at end of file



