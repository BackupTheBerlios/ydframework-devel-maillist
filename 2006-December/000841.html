<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [ydf-devel] r2250 - in YDFramework2.0/trunk/YDFramework2: .	3rdparty 3rdparty/upgrade 3rdparty/upgrade/contrib	3rdparty/upgrade/dtools 3rdparty/upgrade/ext 3rdparty/upgrade/tests
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/ydframework-devel/2006-December/index.html" >
   <LINK REL="made" HREF="mailto:ydframework-devel%40lists.berlios.de?Subject=Re%3A%20%5Bydf-devel%5D%20r2250%20-%20in%20YDFramework2.0/trunk/YDFramework2%3A%20.%0A%093rdparty%203rdparty/upgrade%203rdparty/upgrade/contrib%0A%093rdparty/upgrade/dtools%203rdparty/upgrade/ext%203rdparty/upgrade/tests&In-Reply-To=%3C200612091816.kB9IGC0d008669%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000840.html">
   <LINK REL="Next"  HREF="000842.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[ydf-devel] r2250 - in YDFramework2.0/trunk/YDFramework2: .	3rdparty 3rdparty/upgrade 3rdparty/upgrade/contrib	3rdparty/upgrade/dtools 3rdparty/upgrade/ext 3rdparty/upgrade/tests</H1>
    <B>ximian at mail.berlios.de</B> 
    <A HREF="mailto:ydframework-devel%40lists.berlios.de?Subject=Re%3A%20%5Bydf-devel%5D%20r2250%20-%20in%20YDFramework2.0/trunk/YDFramework2%3A%20.%0A%093rdparty%203rdparty/upgrade%203rdparty/upgrade/contrib%0A%093rdparty/upgrade/dtools%203rdparty/upgrade/ext%203rdparty/upgrade/tests&In-Reply-To=%3C200612091816.kB9IGC0d008669%40sheep.berlios.de%3E"
       TITLE="[ydf-devel] r2250 - in YDFramework2.0/trunk/YDFramework2: .	3rdparty 3rdparty/upgrade 3rdparty/upgrade/contrib	3rdparty/upgrade/dtools 3rdparty/upgrade/ext 3rdparty/upgrade/tests">ximian at mail.berlios.de
       </A><BR>
    <I>Sat Dec  9 19:16:12 CET 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="000840.html">[ydf-devel] r2249 -	YDFramework2.0/trunk/YDFramework2/YDClasses/YDFormElements
</A></li>
        <LI>Next message: <A HREF="000842.html">[ydf-devel] r2251 - in YDFramework2.0/trunk/YDFramework2: 3rdparty	3rdparty/captcha 3rdparty/fonts YDClasses	YDClasses/YDFormElements addons addons/YDCaptcha
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#841">[ date ]</a>
              <a href="thread.html#841">[ thread ]</a>
              <a href="subject.html#841">[ subject ]</a>
              <a href="author.html#841">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: ximian
Date: 2006-12-09 19:13:10 +0100 (Sat, 09 Dec 2006)
New Revision: 2250

Added:
   YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/
   YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/README
   YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/contrib/
   YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/contrib/exceptions.php
   YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/contrib/fix.meta
   YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/contrib/fix.php
   YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/contrib/hiddenerrors.php
   YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/contrib/http.meta
   YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/contrib/http.php
   YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/contrib/http.txt
   YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/contrib/phprequest.php
   YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/contrib/xmlrpc.meta
   YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/contrib/xmlrpc.php
   YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/contrib/xmlrpc.txt
   YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/dtools/
   YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/dtools/_dt
   YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/dtools/ckavail.php
   YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/dtools/compact
   YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/dtools/doctests
   YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/dtools/listemu
   YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/dtools/updoc
   YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/ext/
   YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/ext/array.php
   YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/ext/base64.php
   YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/ext/bcmath.php
   YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/ext/ctype.php
   YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/ext/dba.php
   YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/ext/exotic.php
   YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/ext/fakezlib.php
   YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/ext/ftp.php
   YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/ext/gettext.meta
   YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/ext/gettext.php
   YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/ext/gettext.txt
   YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/ext/mime.php
   YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/ext/odbc.php
   YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/ext/old.php
   YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/ext/openssl.php
   YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/ext/posix.php
   YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/
   YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/_listemulated
   YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/_runparts
   YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/array_change_key_case
   YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/array_chunk
   YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/array_combine
   YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/array_diff_assoc
   YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/array_fill
   YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/array_intersect_assoc
   YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/array_udiff_uassoc
   YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/array_walk_recursive
   YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/base16
   YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/bcmath
   YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/class_parents
   YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/file_put_contents
   YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/floatval
   YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/fmod
   YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/fnmatch
   YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/get_headers
   YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/gettext
   YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/glob
   YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/gzdecode
   YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/headers_list
   YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/html_entity_decode
   YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/http_build_query
   YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/is_a
   YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/md5_file
   YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/mhash
   YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/mime_content_type
   YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/scandir
   YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/spl_classes
   YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/str_ireplace
   YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/str_rot13
   YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/str_shuffle
   YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/str_split
   YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/str_word_count
   YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/stripos
   YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/strpbrk
   YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/strripos
   YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/substr_compare
   YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/uuencode
   YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/vprintf
   YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/upgrade.meta
   YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/upgrade.php
Modified:
   YDFramework2.0/trunk/YDFramework2/YDF2_init.php
Log:
- added Upgrade support. Not used by default.
  To use the upgrade pack you need to call after YDF init:  YDIncludeCompatibility();

Added: YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/README
===================================================================
--- YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/README	2006-12-09 18:08:01 UTC (rev 2249)
+++ YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/README	2006-12-09 18:13:10 UTC (rev 2250)
@@ -0,0 +1,500 @@
+
+PHP downwards compatibility functions
+&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;
+The &quot;upgrade.php&quot; package implements features and functions from
+later PHP versions in pure PHP script and dynamically defines them
+at runtime.  This allows you to use said functions on outdated
+server setups with only including() a single script.  You are freed
+from wasting time with backward compatibility problems or omitting
+certain useful PHP functions or retyping workarounds then, while
+your applications remain &quot;PHP 4.1+ COMPATIBLE&quot; even if features of
+PHP5 were used.
+
+
+It is useful in a variety of scenarios:
+
+&#183; If you write PHP scripts which are distributed later to a variety
+  of web servers, which may or may not run the latest PHP versions.
+
+&#183; If your own web space providers PHP version is immemorial.
+
+&#183; You want to use a PHP5 function, but know that it won't be
+  available elsewhere. Or you find yourself constantly writing some
+  workarounds instead of using the most useful PHP function for it.
+
+&#183; Support of the gettext/bcmath/ftp/... extensions would make your
+  script faster and easier to maintain, but would hinder server and
+  provider independence. (See our ext/ for PHP extensions.)
+
+&#183; If you yourself want to use a PHP application or projects, which
+  depends on features not available on your server and so breaks.
+
+&#183; You have a sourceforge.net project homepage ;-)
+
+
+It however cannot help in other cases:
+
+&#183; PHP5s extended object orientation language semantics aren't
+  emulated, and could never be.  You won't be able to write PHP4-
+  compatible scripts if you want or have to use them.
+
+&#183; Newer PHP versions also sometimes change the function signatures
+  and add/allow new arguments. Because existing and core functions
+  cannot be overridden, upgradephp won't ever make them compatible
+  between versions.
+
+&#183; PHPs safe_mode is a hurdle you either have to pay your webhoster
+  their extra fee for 'full PHP support' or make the lengthy
+  &quot;But-how-does-this-help-security-if-there-is-no-such-Safe-Mode-
+  in-Perl/Python-enabled?&quot;-discussion (with the dumber providers).
+  There is absolutely no safe_mode support in upgradephp, this is
+  entirely your problem.
+
+&#183; PHP4.1 superglobals cannot be emulated for 4.0 versions.
+
+&#183; Features which cannot be emulated therefore include: PHP5-OO,
+  superglobals, new function arguments, stream wrappers.
+
+
+Other things to note:
+
+&#183; Speed won't suffer on up-to-date servers, because functions are
+  only emulated/deifned if they are missing (all function_exists
+  checks are built-in; you don't have to care).
+
+&#183; Some of the functions that get defined here, are just simple
+  stubs; sometimes only there to prevent E_FATAL errors.
+
+&#183; Emulated functions sometimes run slower than the native variant
+  would, but it generally shouldn't be slower than any workaround
+  you used for the [advanced but not widely available] functions
+  until now.
+
+&#183; Most emulation functions leave the error reporting up to any
+  invoked parent functions (fopen, fwrite and call_user_func_array
+  for example).
+
+
+Remember that native functions will be used whereever available,
+this emulation only helps running scripts on aging PHP versions.
+
+
+
+      PEAR::PHP_Compat
+      &#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;
+      Alternatively to the &quot;upgradephp&quot; package, you could also give
+      the PEAR package &quot;PHP_Compat&quot; (by Aidan Lister &amp; Co.) from
+      [<A HREF="http://pear.php.net/">http://pear.php.net/</A>] a try. It comes under the PHP license
+      and contains cleaner code in some areas (exotic array funcs and
+      PHP4.0 code).
+
+      It is more thoroughly commented and emulates PHP error messages
+      completely.  In some circumstances you could benefit from its
+      divided function definitions (each in a separate file), while it
+      is possible to reassamble everything into a single script.  You
+      could then even load it in conjunction with upgrade.php then.
+
+      Note: no code from PHP_Compat has been reused here (this is more
+      a license thing, than NIH syndrome).
+
+
+
+Usage
+&#175;&#175;&#175;&#175;&#175;
+Simply include(&quot;upgrade.php&quot;); in any of your scripts, if you want
+to use some of the newer PHP4.3 or PHP5 functions like stripos() or
+so.
+
+You could additionally check the PHP_VERSION, and only include the
+emulation wrapper if you depend on features from a certain PHP
+interpreter release:
+
+  &lt;?example
+     if (PHP_VERSION &lt; &quot;4.3.0&quot;) { include(&quot;.../upgrade.php&quot;); }
+  ?&gt;
+
+Currently following functions can be emulated:
+&#183; gzdecode
+&#183; ob_get_headers
+&#183; xmlentities
+&#183; stripos
+&#183; strripos
+&#183; str_ireplace
+&#183; get_headers
+&#183; headers_list
+&#183; fprintf
+&#183; vfprintf
+&#183; str_split
+&#183; http_build_query
+&#183; convert_uuencode
+&#183; convert_uudecode
+&#183; scandir
+&#183; idate
+&#183; time_nanosleep
+&#183; strpbrk
+&#183; php_real_logo_guid
+&#183; php_egg_logo_guid
+&#183; get_declared_interfaces
+&#183; array_combine
+&#183; array_walk_recursive
+&#183; substr_compare
+&#183; spl_classes
+&#183; class_parents
+&#183; session_commit
+&#183; dns_check_record
+&#183; dns_get_mx
+&#183; setrawcookie
+&#183; file_put_contents
+&#183; count_recursive
+&#183; file_get_contents
+&#183; fnmatch
+&#183; glob
+&#183; array_key_exists
+&#183; array_intersect_assoc
+&#183; array_diff_assoc
+&#183; html_entity_decode
+&#183; str_word_count
+&#183; str_shuffle
+&#183; get_include_path
+&#183; set_include_path
+&#183; restore_include_path
+&#183; str_rot13
+&#183; array_change_key_case
+&#183; array_fill
+&#183; array_chunk
+&#183; md5_file
+&#183; is_a
+&#183; fmod
+&#183; floatval
+&#183; is_infinite
+&#183; is_nan
+&#183; is_finite
+&#183; var_export
+&#183; strcoll
+&#183; diskfreespace
+&#183; disktotalspace
+&#183; vprintf
+&#183; vsprintf
+&#183; import_request_variables
+&#183; hypot
+&#183; log1p
+&#183; expm1
+&#183; sinh
+&#183; cosh
+&#183; tanh
+&#183; asinh
+&#183; acosh
+&#183; atanh
+&#183; mhash
+&#183; mhash_count
+&#183; mhash_get_hash_name
+&#183; mhash_get_block_size
+&#183; array_udiff_uassoc
+&#183; array_udiff_assoc
+&#183; array_diff_uassoc
+&#183; array_udiff
+&#183; array_uintersect_uassoc
+&#183; array_uintersect_assoc
+&#183; array_uintersect
+&#183; array_intersect_uassoc
+&#183; dc___exec
+&#183; bcscale
+&#183; bcadd
+&#183; bcsub
+&#183; bcmul
+&#183; bcdiv
+&#183; bcmod
+&#183; bcpow
+&#183; bcpowmod
+&#183; bcsqrt
+&#183; bccomp
+&#183; bc___scaledown
+&#183; gettext
+&#183; gettext___plural_guess
+&#183; ngettext
+&#183; dngettext
+&#183; dcngettext
+&#183; dcgettext
+&#183; dgettext
+&#183; textdomain
+&#183; bindtextdomain
+&#183; gettext___load_mo
+&#183; gettext___load_po
+&#183; bind_textdomain_codeset
+&#183; _
+&#183; mime_content_type
+&#183; image_type_to_mime_type
+&#183; image_type_to_extension
+&#183; exif_imagetype
+&#183; array_filter
+&#183; array_map
+&#183; is_callable
+&#183; array_search
+&#183; array_reduce
+&#183; is_scalar
+&#183; localeconv
+&#183; call_user_func_array
+&#183; call_user_method_array
+&#183; array_sum
+&#183; constant
+&#183; is_null
+&#183; pathinfo
+&#183; escapeshellarg
+&#183; is_uploaded_file
+&#183; move_uploaded_file
+&#183; strncasecmp
+&#183; wordwrap
+&#183; php_uname
+&#183; php_sapi_name
+&#183; posix_mkfifo
+&#183; posix_getcwd
+&#183; posix_kill
+&#183; posix_uname
+&#183; ctype_alnum
+&#183; ctype_alpha
+&#183; ctype_digit
+&#183; ctype_xdigit
+&#183; ctype_cntrl
+&#183; ctype_space
+&#183; ctype_upper
+&#183; ctype_lower
+&#183; ctype_graph
+&#183; ctype_punct
+&#183; ctype_print
+&#183; odbc_connect
+&#183; odbc_pconnect
+&#183; odbc_close
+&#183; odbc_exec
+&#183; odbc_do
+&#183; odbc_prepare
+&#183; odbc_execute
+&#183; odbc_fetch_array
+&#183; odbc_fetch_row
+&#183; odbc_fetch_object
+&#183; odbc_fetch_into
+&#183; odbc_free_result
+&#183; odbc_next_result
+&#183; odbc_num_fields
+&#183; odbc_num_rows
+
+On a side note: You don't have to include() this func emulation
+script yourself. Leave this to your users if they use an older PHP
+version; a note often suffices. It however may be senseful to ship
+this together with your scripts - that's also why it was released
+as Public Domain (=compatible to ALL open source licenses, including
+the GNU GPL).
+
+It is safe to extract a few function bodies/definitions out of the
+script to make a shorter version (load only the needed functions);
+but you should keep the &quot;if (function_exists(...))&quot; wrapper code
+always.
+(PHP_Compat makes a better source, if you really need only a few
+emulated functions.)
+
+
+Omissions
+&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;
+A few PHP features are specifically NOT implemented, and so still
+had to be taken care of in your scripts:
+
+&#183; predefined STDIN, STDOUT and STDERR constants
+&#183; UPLOAD_ERR_* constants (introduced with 4.2, officially 4.3)
+&#183; ob_* (eventually possible)
+&#183; clone (PHP5 language feature, but workaround exists in PHP_Compat)
+&#183; ini_get_all (ingenious trick in PHP_Compat)
+
+It may be possible that a script in ext/ later adds support. Often
+PHP_Compat already provides loadable definitions of above features.
+
+
+ext/
+&#175;&#175;&#175;&#175;
+The ext/ subdirectory in here provides a few more or less useful
+emulations for various PHP extensions or function groups.
+
+&#183; &quot;ext/array&quot; provides a few exotic array diff functions (for
+  associative arrays and for using multiple callback functions)
+
+&#183; &quot;ext/exotic&quot; contains some rarely needed functions, which have
+  been removed from the main file for that and other reasons
+
+&#183; &quot;ext/bcmath&quot; provides the mathematical functions with arbitrary
+  precision on Unix systems, but emulation also works on top of
+  GMP or big_int
+
+&#183; &quot;ext/dba&quot; allows you to use scripts written for the dba module,
+  if your interpreter only has dbm_*() functions; but only provides
+  the minimum functionality
+
+&#183; &quot;ext/ftp&quot; emulates the ftp extension using only the bare socket
+  and networking functions (should work anywhere), even has some
+  features not found in the original
+
+&#183; &quot;ext/gettext&quot; simulates most of what gettext/libintl provides, and
+  seems to read .mo data files correctly - plural support is however
+  weak. There is also support for .po files, but since the libintl
+  and original gettext functions don't normally read this, that's a
+  useless feature (just for fun). You save 2K by ripping it out.
+
+&#183; &quot;ext/mime&quot; simulates the mime_content_type() function, either by
+  accessing PECL::fileinfo or reading and evaluating the magic.mime
+  database itself (likely slower and a bit unclean of course)
+
+
+
+dtools/
+&#175;&#175;&#175;&#175;&#175;&#175;&#175;
+Please run the &quot;updoc&quot; script once to update your PHP manual, if you
+are planning to use the upgrade.php script. Create a symlink from your
+installed multi-file PHP manual to ease using this and the &quot;doctests&quot;
+utility:
+
+&#183; The &quot;dtools/updoc&quot; commandline script updates your local PHP
+  documentation to carry hints about emulated functions. It'll simply
+  add a small &quot;EMU&quot; on top of the supported functions` description
+  pages (in the line typically listing the PHP versions).
+
+&#183; &quot;ckavail.php&quot; was used to check for added functions between
+   different PHP interpreter versions, purely a development script.
+
+&#183; &quot;dtools/doctests&quot; greps your local PHP manual for function use
+  examples, and executes them with the given PHP interpreter and
+  the &quot;upgrade.php&quot; script loaded of course. This way you get live
+  tests, but also see:
+
+&#183; &quot;dtools/compact&quot; creates a collapsed version of the upgrade.php
+  script (saved into contrib/)
+
+
+
+tests/
+&#175;&#175;&#175;&#175;&#175;&#175;
+Contains stupidly short scripts, that have been used to compare
+behaviour of the original functions to that of the emulated ones.
+
+Use the &quot;tests/_runparts&quot; shell script (Linux) to get all tests run
+automatically. You must specify the names of two different PHP
+interpreter versions, whose output for each test will be shown side
+by side. If you don't have two, then simply give the name of your
+only PHP (-cgi) interpreter twice or simply use &quot;false&quot; or &quot;cat&quot; as
+the second argument.
+
+
+
+contrib/
+&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;
+Holds a few library scripts, which are believed to be of higher
+quality than any of the PEAR counterparts. Probably inappropriate to
+place it in this tarball, but they usefully take advantage of the
+upgrade.php provided gzdecode(). (PEARs HTTP and XML-RPC classes
+don't even know about content-coding, btw).
+
+&#183; &quot;contrib/http&quot; can be used to contact Web form scripts, or PHP
+  code utilizing &quot;ext/phprequest&quot; more efficiently. It especially
+  supports content-coding as per RFC2616 (HTTP standard) for saving
+  a lot of bandwidth and getting answers faster.
+
+&#183; &quot;contrib/xmlrpc&quot; likewise can compress output and is used to
+  access XML-RPC and IETF XML+RPC Web services. It takes advantage
+  of supported XML and EPI-XML-RPC extensions, but runs gracefully
+  (not 100% exact XML parser) without. It was also made to provide
+  downwards compatibility. Currently you shouldn't run it against
+  old and not-HTTP standards-compliant servers and clients (=avoid
+  compression unless you use it also as server or client at the
+  other side).
+
+&#183; &quot;contrib/hiddenerrors&quot; shows a nice way to hide all disturbing
+  error messages from users, but keeping them available for
+  development. It is especially useful, when premature _NOTICEs or
+  _WARNINGs could garbage (XML or binary) output or if this could
+  prevent sending any further/required HTTP headers().
+
+&#183; &quot;contrib/fix.php&quot; fights magic_quotes and register_globals
+  (though here it's often better to let users of outdated PHP setups
+  run into the open knife, or die() with an error message)
+
+&#183; &quot;contrib/phprequest&quot; enables your PHP interpreter to receive HTTP
+  requests with &quot;application/vnd.php.serialized&quot; encoding (even
+  compressed) instead of the older &quot;multipart/form-data&quot; and the
+  more simple &quot;application/x-www-form-urlencoded&quot; var post formats;
+  this is faster and type-safe if you control both ends of the wire;
+  see &quot;contrib/README.http&quot; for hints about the upcoming &quot;PHP-RPC&quot;
+
+&#183; &quot;contrib/exceptions&quot; provide a scheme for PHP4-compatible
+  exception management using simple wrapper calls and agreements
+
+Please also have a peek into the README files accompaning the script
+snippets distributed in this directory.
+
+
+
+Other Notes
+&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;
+&#183; Don't care about the *.meta files everywhere. They are used in
+  other projects for plugin / include script management only and
+  have little value else.
+
+&#183; This script doesn't reside in any CVS/SVN reposititory currently
+  because it is considered a too minor and small project.
+
+&#183; The project homepage is &lt;<A HREF="http://upgradephp.berlios.de/">http://upgradephp.berlios.de/</A>&gt; and also
+  &lt;<A HREF="http://freshmeat.net/p/upgradephp">http://freshmeat.net/p/upgradephp</A>&gt;.
+
+
+
+License
+&#175;&#175;&#175;&#175;&#175;&#175;&#175;
+Everything in here is Public Domain. There are no restrictions on how
+or where you could use it. You may redistribute it under any license
+as you wish, and you don't need to tell anyone where you got it from.
+It has absolutely no impact on the rest of YOUR project; you are free
+to include it as if you had written it yourself.
+
+You could prepend the license preamble (GNU GPL, LGPL, BSD, MPL, MSFT
+EULA, PHP, CDDL, Artistic, ...) of your choice if you want to.
+
+
+
+Author
+&#175;&#175;&#175;&#175;&#175;&#175;
+The current maintainer can be contacted under &lt;milky*users&#183;sf&#183;net&gt;
+
+Please drop me a line, if you found something important missing, or
+a really frustrating bug, and if you have feature wishes, or if you
+can name one of the functions that the php developers were too lazy
+to implement.
+
+
+
+ChangeLog
+&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;
+
+v13
+  - bcmath functions changed to use faster /usr/bin/dc, wrappers for GMP
+    fixed and php_big_int.so usage possible
+  - gettext_plural0 merged into old code and speed improved
+  -
+
+v12
+  - strripos() handling of positive offsets was fixed
+  - strpbrk() fixed to not return string, if nothing found
+  - php_strip_whitespace() and php_check_syntax() moved into ext/exotic
+  + ext/bcmath using /usr/bin/bc
+  + initial mhash (HMAC) implementation with MD5 and SHA1
+  + incomplete ext/odbc
+  + ext/exceptions for PHP4
+  + extremely fast but incomplete plural form handling in gettext module
+  - core script rewritten with more exhaustive comments
+
+v11
+  - shortened (whitespace- and comment-free) script was added
+  - first gettext emulation version
+
+v10
+  (unreleased)
+
+...
+  (visit the BerliOS download page and diff it yourself)
+
+v1
+  - initial release (non-public)

Added: YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/contrib/exceptions.php
===================================================================
--- YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/contrib/exceptions.php	2006-12-09 18:08:01 UTC (rev 2249)
+++ YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/contrib/exceptions.php	2006-12-09 18:13:10 UTC (rev 2250)
@@ -0,0 +1,203 @@
+&lt;?php
+/*
+   simplistic exception handling for PHP4
+   --------------------------------------
+   
+   As you might know, PHP5 introduced exceptions, like those from Java. This
+   feature of course cannot be used for PHP4-compatible scripts, and it can
+   in no way be emulated by a functional API emulation like &quot;upgrade.php&quot;.
+
+   To use an exception-like scheme in PHP4 we have to agree on conventions -
+   lots of. And exceptions won't look object-oriented anymore and not be
+   compliant with the PHP5 scheme - the names are in fact held incompatible
+   to avoid conflicts in the language semantics (reserved words).
+   
+
+   interfaces
+   ----------
+  
+    - class Exception 
+    - global variable $_EXCEPTION (- should better be a list of excptn objs?)
+    - _try() function
+    - _throw() function
+    - _catch() function
+
+
+   howto
+   -----
+   
+    - prefix a block of commands with _try();
+      this will initialize exception handling (evtl. resets internal vars)
+    - errors are thrown, by calling _throw() with an Exception-class derived
+      object instance as parameter, and returning immediately
+    - exceptions are &quot;catched&quot; in if() statements, the _catch() function
+      with a classname as parameter returns false or the $_EXCEPTION object
+    - you shouldn't use set_exception_handler(), but $_EXCEPTION=&quot;funcname&quot;;
+
+    #-- main code      
+    _try();
+    {
+       sub_call();
+    }
+    if ($e = _catch(&quot;Special_Case&quot;)) {
+       echo $e-&gt;broken_file();
+    }
+    if ($e = _catch(&quot;Exception&quot;)) {
+       echo &quot;Something broke, I'd say.&quot;;
+    }
+    
+    #-- error-prone
+    function sub_call() {
+       // ...
+       _throw(new Exception(&quot;error&quot;,255)); return();
+    }
+
+    
+   note
+   ----
+   
+   Please don't send hatemails only because you feel the syntax is too
+   far away from PHP5s native exception handling and counter to that in
+   other languages. And the underscores in this agreement are just to
+   prevent conflicts with PHP5 constructs - this is not yet another case
+   of PHP-underscoritis ;)
+   
+   -&gt; there has been another PHP framework which implemented exceptions
+      long before PHP5 came out; I just don't know anymore which it was
+      //@TODO: build a search engine similar to Google to find that out
+*/
+
+
+#-- base class for exceptions
+if (!class_exists(&quot;exception&quot;)) {
+   class Exception
+   {
+      #-- attributes
+      var $message = &quot;&quot;;
+      var $code = 0;
+      var $file = NULL;
+      var $line = NULL;
+      var $backtrace = NULL;
+      
+      #-- constructor
+      function Exception($message=&quot;&quot;, $code=0) {
+      
+         #-- values
+         $this-&gt;message = $message;
+         $this-&gt;code = $code;
+         
+         #-- debugging
+         $this-&gt;backtrace = debug_backtrace();
+         array_shift($this-&gt;backtrace);
+         $this-&gt;file = @$this-&gt;backtrace[0][&quot;file&quot;];
+         $this-&gt;line = @$this-&gt;backtrace[0][&quot;line&quot;];
+      }
+      
+      #-- get_ wrappers
+      function getMessage() {
+         return($this-&gt;message);
+      }
+      function getCode() {
+         return($this-&gt;code);
+      }
+      function getFile() {
+         return($this-&gt;file);
+      }
+      function getLine() {
+         return($this-&gt;line);
+      }
+      function getTrace() {
+         return($this-&gt;backtrace);
+      }
+      function getTraceAsString() {
+         return(var_export($this-&gt;backtrace, TRUE));
+      }
+      
+      #-- output
+      function __toString() {
+         return($this-&gt;message);
+      }
+   }
+}
+
+
+
+#-- initialize exception handling for next block
+function _try()
+{
+   global $_EXCEPTION;
+
+   #-- clean up
+   if (!is_string($_EXCEPTION) || !function_exists($_EXCEPTION)) {
+      $_EXCEPTION = new Object();
+   }
+}
+
+
+#-- use for throwing errors
+function _throw($obj) {
+   global $_EXCEPTION;
+
+   #-- quick
+   if (is_string($_EXCEPTION) &amp;&amp; function_exists($_EXCEPTION)) {
+      $_EXCEPTION($obj);
+   }
+
+   #-- what do we do if there's already an exception?
+   if ($_EXCEPTION) {
+      // ???
+      trigger_error(&quot;_throw: there is already an unhandled exception on the stack&quot;, E_USER_ERROR);
+   }
+
+   #-- generate object from error message
+   if (!is_object($obj)) {
+      $_EXCEPTION = new Exception(&quot;$obj&quot;);
+   }
+
+   #-- pass
+   $_EXCEPTION = $obj;
+
+   return(true);
+   // break 5;  (after throwing an exception, you should
+   //           exit from your current function quickly)
+}
+
+
+#-- check if exception thrown
+function &amp;_catch($classname=&quot;Exception&quot;) {
+   global $_EXCEPTION;
+   static $e;
+
+   #-- checked for a specific error type / exception class
+   if (is_object($_EXCEPTION) &amp;&amp; (($classname == &quot;*&quot;) || is_a($_EXCEPTION, $classname))) {
+      $e = &amp;$_EXCEPTION;   //@FIX: remove reference passing, seems unnecessary
+      unset($_EXCEPTION);  // this doesn't clean the global var  [but _try() does]
+   }
+   else {
+      $e = false;
+   }
+
+   #-- give out extracted exception   
+   return $e;
+}
+
+
+#-- functional additions
+if (!function_exists(&quot;debug_backtrace&quot;)) {
+   function debug_backtrace() {
+      return array();
+   }
+}
+
+
+#-- sets global state
+if (!function_exists(&quot;set_exception_handler&quot;)) {
+   // quick hack, should use a different func name
+   function set_exception_handler($func) {
+      global $_EXCEPTION;
+      $_EXCEPTION = $func;
+   }
+}
+
+
+?&gt;
\ No newline at end of file

Added: YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/contrib/fix.meta
===================================================================
--- YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/contrib/fix.meta	2006-12-09 18:08:01 UTC (rev 2249)
+++ YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/contrib/fix.meta	2006-12-09 18:13:10 UTC (rev 2250)
@@ -0,0 +1,7 @@
+api: PHP
+type: intercept
+title: PHP fixes
+descriptions: removes bogus magic_quotes and left over superglobals
+priority: auto
+category: library
+conflicts: strike_register_globals, strip_wonderful_slashes

Added: YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/contrib/fix.php
===================================================================
--- YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/contrib/fix.php	2006-12-09 18:08:01 UTC (rev 2249)
+++ YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/contrib/fix.php	2006-12-09 18:13:10 UTC (rev 2250)
@@ -0,0 +1,49 @@
+&lt;?php
+/*
+   Outdated and bogus PHP settings (register_globals and magic_quotes) are
+   defended by this script, so code cannot be negatively impacted. It can
+   always be loaded as it doesn't cause problems or speed disadvantages on
+   correctly configured servers. THE &quot;PHP.INI&quot; SHOULD BE FIXED PREFERABLY.
+*/
+
+ #-- strike register_globals (injected variables)
+ if (ini_get(&quot;register_globals&quot;) == &quot;1&quot;) {
+    ewiki_recursive_unset($GLOBALS, $_REQUEST);
+    ini_set(&quot;register_globals&quot;, 0);
+ }
+
+ #-- strip any \'s if magic_quotes (variable garbaging) is still enabled
+ if (ini_get(&quot;magic_quotes_gpc&quot;) &amp;&amp; get_magic_quotes_gpc()) {
+    ewiki_recursive_stripslashes($_REQUEST);
+    ewiki_recursive_stripslashes($_GET);
+    ewiki_recursive_stripslashes($_POST);
+    ewiki_recursive_stripslashes($_COOKIE);
+    ewiki_recursive_stripslashes($_ENV);
+    ewiki_recursive_stripslashes($_SERVER);
+    ini_set(&quot;magic_quotes_gpc&quot;, 0);
+ }
+
+ #-- now that one is really dumb
+ set_magic_quotes_runtime(0);
+
+
+ #-- implementation
+ function ewiki_recursive_unset(&amp;$TO, $FROM) {
+    foreach ($FROM as $var=&gt;$value) {
+       if (isset($TO[$var]) &amp;&amp; ($TO[$var]==$FROM[$var])) {
+          unset($TO[$var]);
+       }
+    }
+ }
+ function ewiki_recursive_stripslashes(&amp;$var) {
+    if (is_array($var)) {
+       foreach ($var as $key=&gt;$item) {
+          ewiki_recursive_stripslashes($var[$key]);
+       }
+    }
+    else {
+       $var = stripslashes($var);
+    }
+ }
+
+?&gt;
\ No newline at end of file

Added: YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/contrib/hiddenerrors.php
===================================================================
--- YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/contrib/hiddenerrors.php	2006-12-09 18:08:01 UTC (rev 2249)
+++ YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/contrib/hiddenerrors.php	2006-12-09 18:13:10 UTC (rev 2250)
@@ -0,0 +1,49 @@
+&lt;?php
+/*
+   The error handler provided here will feed all errors and warnings
+   into HTTP headers of the form &quot;X-Error-NNNNN: ...&quot;, so they can't
+   disturb page output or make XML documents invalid. This allows to
+   turn on complete error_reporting() without any functionality loss
+   due to premature output.
+   You of course need a good Web browser that can easily display all
+   response headers then for developing.
+*/
+
+set_error_handler(&quot;ewiki_http_header_errors&quot;);
+ini_set(&quot;html_errors&quot;, 0);
+
+function ewiki_http_header_errors($errno, $msg, $file, $line, $lvars) {
+
+   static $error_types = array(
+      E_PARSE =&gt; &quot;PARSE ERROR&quot;,
+      E_ERROR =&gt; &quot;ERROR&quot;,
+      E_WARNING =&gt; &quot;WARNING&quot;,
+      E_NOTICE =&gt; &quot;NOTICE&quot;,
+      E_STRICT =&gt; &quot;STRICT&quot;,
+      E_USER_ERROR =&gt; &quot;USER ERROR&quot;,
+      E_USER_WARNING =&gt; &quot;USER WARNING&quot;,
+      E_USER_NOTICE =&gt; &quot;USER NOTICE&quot;,
+   );
+   ($errtype = $error_types[$errno]) or ($errtype = &quot;UNDEF ERROR&quot;);
+   
+   #-- check for @ and disabled errors
+   $emask = get_cfg_var(&quot;error_reporting&quot;);
+   if (! ($emask &amp; $errno)) {
+      return;
+   }
+
+   #-- output
+   $msg = strtr($msg, &quot;\r\n\t\f&quot;, &quot;    &quot;);
+   $msg = &quot;$errtype: $msg in $file, line #$line&quot;;
+   if (headers_sent()) {
+      print &quot;\n&lt;!--&lt;div class=\&quot;php-error\&quot;&gt;$msg&lt;/div&gt;--&gt;\n&quot;;
+   }
+   else {
+      $no = crc32($msg);
+      $no = ($no &amp; 0xFFFF) ^ ($no &gt;&gt; 16);
+      header(&quot;X-Error-$no: $msg&quot;);
+      if ($errno == E_FATAL) { header(&quot;Status: 500 Something bad happened&quot;); }
+   }
+}
+
+?&gt;
\ No newline at end of file

Added: YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/contrib/http.meta
===================================================================
--- YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/contrib/http.meta	2006-12-09 18:08:01 UTC (rev 2249)
+++ YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/contrib/http.meta	2006-12-09 18:13:10 UTC (rev 2250)
@@ -0,0 +1,9 @@
+api: PHP
+type: functions
+category: library
+priority: optional
+provides: http-request
+title: HTTP requests
+description: implements HTTP protocol, various request methods supported
+url: <A HREF="http://freshmeat.net/p/upgradephp">http://freshmeat.net/p/upgradephp</A>
+version: 11.3

Added: YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/contrib/http.php
===================================================================
--- YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/contrib/http.php	2006-12-09 18:08:01 UTC (rev 2249)
+++ YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/contrib/http.php	2006-12-09 18:13:10 UTC (rev 2250)
@@ -0,0 +1,623 @@
+&lt;?php
+/*
+   This snippet implements HTTP queries, and allows for most request
+   methods, content types and encodings. It is useful for contacting
+   scripts made to serve HTML forms.
+    - does neither depend upon wget or curl, nor any other extension
+    - you can add -&gt;$params (form variables) on the fly, it's a hash
+    - if the initial URL contains a query string, the vars will be
+      extracted first
+    - set the -&gt;$enc very carefully, because many CGI apps and HTTP
+      servers can't deal with it (else &quot;gzip&quot; and &quot;deflate&quot; are nice)
+    - there are abbreviations for the content -&gt;$type values (namely
+      &quot;form&quot; , &quot;url&quot; and &quot;php&quot;)
+    - user:password@ pairs may be included in the initially given URL
+    - headers always get normalized to &quot;Studly-Caps&quot;
+    - won't support keep-alive connections
+    - for PUT and other methods, the -&gt;$params var may just hold the
+      request body
+    - files can be added to the -&gt;params array as hash with specially
+      named fields: &quot;content&quot;/&quot;data&quot;, and &quot;filename&quot;/&quot;name&quot; , &quot;type&quot;
+    - you can add authentication information using the standard notation
+      &quot;<A HREF="http://user:passw@www.example.com/...">http://user:passw@www.example.com/...</A>&quot; for -&gt;$url and -&gt;$proxy
+
+   A response object will have a -&gt;$content field, -&gt;$headers[] and
+   -&gt;len, -&gt;type attributes as well. You could also -&gt;decode() the
+   body, if it is app/vnd.php.serialized or app/x-www-form-urlencoded.
+   
+   Public Domain (use freely, transform into any other license, like
+   LGPL, BSD, MPL, ...; but if you change this into GPL please be so
+   kind and leave your users a hint where to find the free version).
+*/
+
+
+#-- request objects
+class http_request {
+
+   var $method = &quot;GET&quot;;
+   var $proto = &quot;HTTP/1.1&quot;;
+   var $url = &quot;&quot;;
+   var $params = array();   // URL/form post vars, or single request body str
+   var $headers = array();
+   var $cookies = array();
+   var $type = &quot;url&quot;;       // content-type, abbrv. for x-www-form-...
+   var $enc = false;        // &quot;gzip&quot; or &quot;deflate&quot;
+   var $error=&quot;&quot;, $io_err=0, $io_err_s=&quot;&quot;;
+   var $active_client = 1;  // enables redirect-following
+   var $redirects = 3;
+   var $proxy = false;      // set to &quot;<A HREF="http://host:NN/">http://host:NN/</A>&quot;
+   var $timeout = 15;
+
+
+   #-- constructor
+   function http_request($method=&quot;GET&quot;, $url=&quot;&quot;, $params=NULL) {
+      $this-&gt;headers[&quot;User-Agent&quot;] = &quot;http_query/17.2 {$GLOBALS[ewiki_config][ua]}&quot;;
+      $this-&gt;headers[&quot;Accept&quot;] = &quot;text/html, application/xml;q=0.9, text/xml;q=0.7, xml/*;q=0.6, text/plain;q=0.5, text/*;q=0.1, image/png;q=0.8, image/*;q=0.4, */*+xml;q=0.3; application/x-msword;q=0.001, */*;q=0.075&quot;;
+      $this-&gt;headers[&quot;Accept-Language&quot;] = &quot;en, eo, es;q=0.2, fr;q=0.1, nl;q=0.1, de;q=0.1&quot;;
+      $this-&gt;headers[&quot;Accept-Charset&quot;] = &quot;iso-8859-1, utf-8&quot;;
+      $this-&gt;headers[&quot;Accept-Feature&quot;] = &quot;textonly, tables, !tcpa, !javascript, !activex, !graphic&quot;;
+      $this-&gt;headers[&quot;Accept-Encoding&quot;] = &quot;deflate, gzip, compress, x-gzip, x-bzip2&quot;;
+      //$this-&gt;headers[&quot;Referer&quot;] = '$google';
+      $this-&gt;headers[&quot;TE&quot;] = &quot;identity, chunked, binary, base64&quot;;
+      $this-&gt;headers[&quot;Connection&quot;] = &quot;close&quot;;
+      //$this-&gt;headers[&quot;Content-Type&quot;] = &amp; $this-&gt;type;
+      if (isset($params)) {
+         $this-&gt;params = $params;
+      }
+      if (strpos($method, &quot;://&quot;)) {
+         $url = $method;  # glue for incompat PEAR::Http_Request
+         $method = &quot;GET&quot;;
+      }
+      $this-&gt;method($method);
+      $this-&gt;setURL($url);
+   }
+
+
+   #-- sets request method
+   function method($str = &quot;GET&quot;) {
+      $this-&gt;method = $str;
+   }
+
+   #-- special headers
+   function setcookie($str=&quot;name=value&quot;, $add=&quot;&quot;) {
+      $this-&gt;cookies[strtok($str,&quot;=&quot;)] = strtok(&quot;\000&quot;).$add;
+   }
+
+
+   #-- deciphers URL into server+path and query string
+   function setURL($url) {
+      if ($this-&gt;method == &quot;GET&quot;) {
+         $this-&gt;url = strtok($url, &quot;?&quot;);
+         if ($uu = strtok(&quot;\000&quot;)) {
+            $this-&gt;setQueryString($uu);
+         }
+      }
+      else {
+         $this-&gt;url = $url;
+      }
+   }
+   
+   
+   #-- decodes a query strings vars into the $params hash
+   function setQueryString($qs) {
+      $qs = ltrim($qs, &quot;?&quot;);
+      parse_str($qs, $this-&gt;params);
+   }
+
+
+   #-- returns params as querystring for GET requests
+   function getQueryString() {
+      $qs = &quot;&quot;;
+      if (function_exists(&quot;http_build_query&quot;)) {
+         $qs = http_build_query($this-&gt;params);
+      }
+      else {
+         foreach ($this-&gt;params as $n=&gt;$v) {
+            $qs .= &quot;&amp;&quot; . urlencode($n) . &quot;=&quot; . urlencode($v);
+         }
+         $qs = substr($qs, 1);
+      }
+      return($qs);
+   }
+
+
+   #-- transforms $params into request body
+   function pack(&amp;$path) {
+      $m = strtoupper($this-&gt;method);
+
+      #-- GET, HEAD
+      if (($m == &quot;GET&quot;) || ($m == &quot;HEAD&quot;)) {
+         $BODY = &quot;&quot;;
+         $path .= (strpos($path, &quot;?&quot;) ? &quot;&amp;&quot; : &quot;?&quot;) . $this-&gt;getQueryString();
+      }
+
+      #-- POST
+      elseif (($m == &quot;POST&quot;) &amp;&amp; is_array($this-&gt;params)) {
+
+         #-- known encoding types
+         $type = $this-&gt;type($this-&gt;type, 0);
+         if ($type == &quot;url&quot;) {
+            $BODY = $this-&gt;getQueryString($prep=&quot;&quot;);
+         }
+         elseif ($type == &quot;php&quot;) {
+            $BODY = serialize($this-&gt;params);
+         }
+         elseif ($type == &quot;form&quot;) {
+            // boundary doesn't need checking, unique enough
+            $bnd = &quot;snip-&quot;.dechex(time()).&quot;-&quot;.md5(serialize($this-&gt;params))
+                 . &quot;-&quot;.dechex(rand()).&quot;-snap&quot;;
+            $BODY = &quot;&quot;;
+            foreach ($this-&gt;params as $i=&gt;$v) {
+               $ct = &quot;text/plain&quot;;
+               $inj = &quot;&quot;;
+               if (is_array($v)) {
+                  ($ct = $v[&quot;ct&quot;].$v[&quot;type&quot;].$v[&quot;content-type&quot;]) || ($ct = &quot;application/octet-stream&quot;);
+                  $inj = ' filename=&quot;' . urlencode($v[&quot;name&quot;].$v[&quot;file&quot;].$v[&quot;filename&quot;]) . '&quot;';
+                  $v = $v[&quot;data&quot;].$v[&quot;content&quot;].$v[&quot;body&quot;];
+               }
+               $BODY .= &quot;--$bnd\015\012&quot;
+                     . &quot;Content-Disposition: form-data; name=\&quot;&quot;.urlencode($i).&quot;\&quot;$inj\015\012&quot;
+                     . &quot;Content-Type: $ct\015\012&quot;
+                     . &quot;Content-Length: &quot; . strlen($v) . &quot;\015\012&quot;
+                     . &quot;\015\012$v\015\012&quot;;
+            }
+            $BODY .= &quot;--$bnd--\015\012&quot;;
+            $ct = $this-&gt;type(&quot;form&quot;) . &quot;; boundary=$bnd&quot;;
+         }
+         #-- ignore
+         else {
+            $this-&gt;error = &quot;unsupported POST encoding&quot;;
+          // return(false);
+            $BODY = &amp; $this-&gt;params;
+         }
+
+         $this-&gt;headers[&quot;Content-Type&quot;] = isset($ct) ? $ct : $this-&gt;type($type, 1);
+      }
+
+      #-- PUT, POST, PUSH, P*
+      elseif ($m[0] == &quot;P&quot;) {
+         $BODY = &amp; $this-&gt;$params;
+      }
+
+      #-- ERROR (but don't complain)
+      else {
+         $this-&gt;error = &quot;unsupported request method '{$this-&gt;method}'&quot;;
+       //  return(false);
+         $BODY = &amp; $this-&gt;params;
+      }
+
+      return($BODY);
+   }
+
+
+   #-- converts content-type strings from/to shortened nick
+   function type($str, $long=1) {
+      $trans = array(
+         &quot;form&quot; =&gt; &quot;multipart/form-data&quot;,
+         &quot;url&quot; =&gt; &quot;application/x-www-form-urlencoded&quot;,
+         &quot;php&quot; =&gt; &quot;application/vnd.php.serialized&quot;,
+      );
+      $trans[&quot;multi&quot;] = &amp;$trans[&quot;form&quot;];
+      if ($long) {
+         $new = $trans[$str];
+      }
+      else {
+         $new = array_search($str, $trans);
+      }
+      return( $new ? $new : $str );
+   }
+
+
+   #-- initiate the configured HTTP request ------------------------------
+   function go($force=0, $asis=0) {
+
+      #-- prepare parts
+      $url = $this-&gt;prepare_url();
+      if (!$url &amp;&amp; !$force) { return; }
+      $BODY = $this-&gt;body($url);
+      if (($BODY===false) &amp;&amp; !$force) { return; }
+      $HEAD = $this-&gt;head($url);
+
+      #-- open socket
+      if (!$this-&gt;connect($url)) {
+         return;
+      }
+
+      #-- send request data
+      fwrite($this-&gt;socket, $HEAD);
+      fwrite($this-&gt;socket, $BODY);
+      $HEAD = false;
+      $BODY = false;
+
+      #-- read response, end connection
+      while (!feof($this-&gt;socket) &amp;&amp; (strlen($DATA) &lt;= 1&lt;&lt;22)) {
+         $DATA .= fread($this-&gt;socket, 32&lt;&lt;10);
+      }
+      fclose($this-&gt;socket);
+      unset($this-&gt;socket);
+
+      #-- for raw http pings
+      if ($asis) { 
+         return($DATA);
+      }
+
+      #-- decode response
+      $r = new http_response();
+      $r-&gt;from($DATA);        // should auto-unset $DATA
+
+      #-- handle redirects
+      if ($this-&gt;active_client) {
+         $this-&gt;auto_actions($r);
+      }
+
+      #-- fin      
+      return($r);
+   }
+
+   #-- alias
+   function start($a=0, $b=0) { 
+      return $this-&gt;go($a, $b);
+   }
+   
+   
+   #-- creates socket connection
+   function connect(&amp;$url) {
+      if ((isset($this-&gt;socket) and !feof($this-&gt;socket))
+      or ($this-&gt;socket = fsockopen($url[&quot;host&quot;], $url[&quot;port&quot;], $this-&gt;io_err, $this-&gt;io_err_s, $this-&gt;timeout))) {
+         socket_set_blocking($this-&gt;socket, true);
+         socket_set_timeout($this-&gt;socket, $this-&gt;timeout, 555);
+         return(true);
+      }
+      else {
+         $this-&gt;error = &quot;no socket/connection&quot;;
+         return(false);
+      }
+   }
+
+
+   #-- separate URL into pieces, prepare special headers
+   function prepare_url() {
+      $this-&gt;setURL($this-&gt;url);
+      if (!$this-&gt;proxy) {
+         $url = parse_url($this-&gt;url);
+         if (strtolower($url[&quot;scheme&quot;]) != &quot;http&quot;) {
+            $this-&gt;error = &quot;unsupported protocol/scheme&quot;;
+            return(false);
+         }
+         if (!$url[&quot;host&quot;]) { return; }
+         if (!$url[&quot;port&quot;]) { $url[&quot;port&quot;] = 80; }
+         if (!$url[&quot;path&quot;]) { $url[&quot;path&quot;] = &quot;/&quot;; }
+         if ($url[&quot;query&quot;]) { $url[&quot;path&quot;] .= &quot;?&quot; . $url[&quot;query&quot;]; }
+         $proxy = &quot;&quot;;
+      }
+      else {
+         $url = parse_url($this-&gt;proxy);
+         $url[&quot;path&quot;] = $this-&gt;url;
+         $proxy = &quot;Proxy-&quot;;
+         $this-&gt;headers[&quot;Proxy-Connection&quot;] = $this-&gt;headers[&quot;Connection&quot;];
+      }
+
+      #-- inj auth headers
+      if ($url[&quot;user&quot;] || $url[&quot;pass&quot;]) {
+         $this-&gt;headers[$proxy.&quot;Authorization&quot;] = &quot;Basic &quot; . base64_encode(&quot;$url[user]:$url[pass]&quot;);
+      }
+      
+      return($url);
+   }
+
+
+   #-- generates request body (if any), must be called before -&gt;head()
+   function body(&amp;$url) {
+
+      #-- encoding of variable $params as request body (according to reqmethod)
+      $BODY = $this-&gt;pack($url[&quot;path&quot;]);
+      if ($BODY === false) {
+         return false;
+      }
+      elseif ($len = strlen($BODY)) {
+         $this-&gt;headers[&quot;Content-Length&quot;] = $len;
+      }
+      $enc_funcs = array(&quot;gzip&quot;=&gt;&quot;gzencode&quot;, &quot;deflate&quot;=&gt;&quot;gzinflate&quot;, &quot;bzip2&quot;=&gt;&quot;bzcompress&quot;, &quot;x-bzip2&quot;=&gt;&quot;bzcompress&quot;, &quot;compress&quot;=&gt;&quot;gzcompress&quot;);
+      if ((strlen($BODY) &gt;= 1024) &amp;&amp; ($f = $enc_funcs[$this-&gt;enc]) &amp;&amp; function_exists($f)) {
+         $BODY = $f($BODY);
+         $this-&gt;headers[&quot;Content-Encoding&quot;] = $this-&gt;enc;
+         $this-&gt;headers[&quot;Content-Length&quot;] = strlen($BODY);
+      }
+      return($BODY);
+   }
+
+
+   #-- generates request head part
+   function head(&amp;$url) {
+   
+      #-- inject cookie header (if any)
+      if ($this-&gt;cookies) {
+         $c = &quot;&quot;;
+         foreach ($this-&gt;cookies as $i=&gt;$v) {
+            $c .= &quot;; &quot; . urlencode($i) . &quot;=&quot; . urlencode($v);
+         }
+         $this-&gt;headers[&quot;Cookie&quot;] = substr($c, 2);
+         $this-&gt;headers[&quot;Cookie2&quot;] = '$Version=&quot;1&quot;';
+      }
+      
+      #-- request head
+      $CRLF = &quot;\015\012&quot;;
+      $HEAD  = &quot;{$this-&gt;method} {$url[path]} {$this-&gt;proto}$CRLF&quot;;
+      $HEAD .= &quot;Host: {$url[host]}$CRLF&quot;;
+      foreach ($this-&gt;headers as $h=&gt;$v) {
+         $HEAD .= trim($h) . &quot;: &quot; . strtr(trim($v), &quot;\n&quot;, &quot; &quot;) . $CRLF;
+      }
+      $HEAD .= $CRLF;
+      return($HEAD);
+   }
+
+   #-- perform some things automatically (redirects)
+   function auto_actions(&amp;$r) {
+
+      #-- behaviour table
+      static $bhv = array(
+         &quot;failure&quot; =&gt; &quot;204,300,304,305,306&quot;,
+         &quot;clean_::POST&quot; =&gt; &quot;300,301,302,303,307&quot;,
+         &quot;clean_::PUT&quot; =&gt; &quot;300,301,302,303,307&quot;,
+         &quot;clean_::GET&quot; =&gt; &quot;300&quot;,  // $params:=undef
+         &quot;GET_::POST&quot; =&gt; &quot;303&quot;,
+         &quot;GET_::PUT&quot; =&gt; &quot;303&quot;,    // downgrade $method:=GET
+      );
+   
+      #-- failure
+      if (strstr($this-&gt;behaviour_table[&quot;failure&quot;], $r-&gt;status)) {
+         return;
+      }
+
+      #-- HTTP redirects
+      if (($pri_url=$r-&gt;headers[&quot;Location&quot;]) || ($pri_url=$r-&gt;headers[&quot;Uri&quot;])) {
+
+         if ((($this-&gt;redirects--) &gt;= 0) &amp;&amp; ($r-&gt;status &gt;= 300) &amp;&amp; ($r-&gt;status &lt; 400)) {
+            $m = strtoupper($this-&gt;method);
+            if (strstr($this-&gt;behaviour_table[&quot;clean_::$m&quot;], $r-&gt;status)) {
+               unset($this-&gt;params);
+            }
+            if (strstr($this-&gt;behaviour_table[&quot;GET_::$m&quot;], $r-&gt;status)) {
+               $this-&gt;method(&quot;GET&quot;);
+            }
+            $this-&gt;setURL($pri_url);
+            $this-&gt;go();
+         }
+      }
+   }
+   
+   #-- aliases for compatiblity to PEAR::HTTP_Request
+   function sendRequest() {
+      return $this-&gt;go();
+   }
+   function setBasicAuth($user, $pw) {
+      $this-&gt;url = preg_replace(&quot;#//(.+?@)?#&quot;, &quot;//$user@$pw&quot;, $this-&gt;url);
+   }
+   function setMethod($m) {
+      $this-&gt;method($m);
+   }
+   function setProxy($host, $port=8080, $user=&quot;&quot;, $pw=&quot;&quot;) {
+      $auth = ($pw ? &quot;$user:$pw@&quot; : ($user ? &quot;$user@&quot; : &quot;&quot;));
+      $this-&gt;proxy = &quot;<A HREF="http://$auth$server:$port">http://$auth$server:$port</A>&quot;;
+   }
+   function addHeader($h, $v) {
+      $this-&gt;headers[$h] = $v;
+   }
+   function getResponseStatus() {
+      $this-&gt;headers[$h] = $v;
+   }
+}
+class http_query extends http_request {
+   /* this is just an alias */
+}
+
+
+
+
+#-- every query result will be encoded in such an object --------------------
+class http_response {
+
+   var $status = 520;
+   var $status_str = &quot;&quot;;
+   var $headers_str = &quot;&quot;;
+   var $headers = array();
+   var $len = 0;
+   var $type = &quot;message/x-raw&quot;;
+   var $content = &quot;&quot;;
+   
+   
+   function http_response() {
+   }
+   
+
+   #-- fill object from given HTTP response BLOB   
+   function from(&amp;$SRC) {
+      $this-&gt;breakHeaders($SRC);  // split data into body + headers
+      $SRC = false;
+      $this-&gt;decodeHeaders();     // normalize header names
+      $this-&gt;headerMeta();
+      $this-&gt;decodeTransferEncodings();    // chunked
+      $this-&gt;decodeContentEncodings();     // gzip, deflate
+      $this-&gt;len = strlen($this-&gt;content);
+   }
+
+
+   #-- separates headers block from response body part
+   function breakHeaders(&amp;$DATA) {
+      $l = strpos($DATA, &quot;\012\015\012&quot;); $skip = 3;
+      $r = strpos($DATA, &quot;\012\012&quot;);
+      if ($r &amp;&amp; ($r&lt;$l)) { $l = $r; $skip = 2; }
+      if (!$l) { $l = strlen($DATA); }
+      $this-&gt;headers_str = rtrim(substr($DATA, 0, $l), &quot;\015&quot;);
+      $this-&gt;content = substr($DATA, $l + $skip);
+      $this-&gt;body = &amp; $this-&gt;content;
+      $this-&gt;data = &amp; $this-&gt;content;  // aliases
+      $this-&gt;ct = &amp; $this-&gt;type;
+   }
+
+
+   #-- splits up the $headers_str into an array and normalizes header names
+   function decodeHeaders() {
+
+      #-- normalize linebreaks
+      $str = &amp; $this-&gt;headers_str;
+//      $str = str_replace(&quot;\n &quot;, &quot; &quot;, $str);
+      $str = str_replace(&quot;\r&quot;, &quot;&quot;, $str);
+      
+      #-- strip headline
+      $nl = strpos($str, &quot;\n&quot;) + 1;
+      $this-&gt;proto = strtok(substr($str, 0, $nl), &quot; &quot;);
+      $this-&gt;status = (int) strtok(&quot; &quot;);
+      $this-&gt;status_str = strtok(&quot;\000\r\n&quot;);
+      if ($this-&gt;status == 100) {
+         $this-&gt;full_duplex = 1;
+      }
+
+      #-- go through lines, split name:value pairs
+      foreach (explode(&quot;\n&quot;, substr($str, $nl)) as $line) {
+
+         $i = trim(strtok($line, &quot;:&quot;));
+         $v = trim(strtok(&quot;\000&quot;));
+
+         #-- normalize name look&amp;feel
+         $i = strtr(ucwords(strtolower(strtr($i, &quot;-&quot;, &quot; &quot;))), &quot; &quot;, &quot;-&quot;);
+
+         #-- add to, if key exists
+         if (!empty($this-&gt;headers[$i])) {
+            $this-&gt;headers[$i] .= &quot;, &quot;.$v;
+         }
+         else {
+            $this-&gt;headers[$i] = $v;
+         }
+
+      }
+   }
+
+
+   #-- extract interesting values
+   function headerMeta() {
+      $this-&gt;len = strlen($this-&gt;content);
+      $this-&gt;type = trim(strtok(strtolower($this-&gt;headers[&quot;Content-Type&quot;]), &quot;;&quot;));
+   }
+   
+
+   #-- strip any content transformation
+   function decodeTransferEncodings() {
+      $enc = trim(strtok(strtolower($this-&gt;headers[&quot;Transfer-Encoding&quot;]), &quot;,;&quot;));
+      if ($enc) {
+         switch ($enc) {
+            case &quot;chunked&quot;:
+               $this-&gt;decodeChunkedEncoding();
+               break;
+            case &quot;base64&quot;:
+               $this-&gt;content = base64_decode($this-&gt;content);
+               $this-&gt;len = strlen($this-&gt;content);
+               break;
+            case &quot;identity&quot;: case &quot;binary&quot;:
+            case &quot;7bit&quot;: case &quot;8bit&quot;:
+               break;
+            default:
+               trigger_error(&quot;http_response::decodeTransferEncodings: unkown TE of '$enc'\n&quot;, E_WARNING);
+         }
+      }
+   }
+
+
+   #-- scripts on HTTP/1.1 servers may send fragmented response
+   function decodeChunkedEncoding() {
+
+      $data = &quot;&quot;;	# decoded data
+      $p = 0;		# current string position
+
+      while ($p &lt; strlen($this-&gt;content)) {
+
+         #-- read len token
+         $n = strtok(substr($this-&gt;content, $p, 20), &quot;\n&quot;);
+         $p += strlen($n)+1;
+
+         #-- make integer
+         $n = 0 + (int) (trim($n));
+         if (!$n) {
+            break;
+         }
+
+         #-- read data
+         $data .= substr($this-&gt;content, $p, $n);
+         $p += $n;
+      }
+
+      $this-&gt;content = $data;
+      unset($data);
+      $this-&gt;len = strlen($this-&gt;content);
+   }
+
+
+   #-- uncompress response body
+   function decodeContentEncodings() {
+      $enc = trim(strtok(strtolower($this-&gt;headers[&quot;Content-Encoding&quot;]), &quot;;,&quot;));
+      $dat = &amp;$this-&gt;content;
+      if ($enc == &quot;deflate&quot;) {
+         $dat = gzinflate($dat);
+      }
+      elseif (($enc == &quot;gzip&quot;) || ($enc == &quot;x-gzip&quot;)) {
+         if (function_exists(&quot;gzdecode&quot;)) {
+            $dat = gzdecode($dat);
+         }
+         else {
+            $dat = gzinflate(substr($dat, 10, strlen($dat)-18));
+         }
+      }
+      elseif ($enc == &quot;compress&quot;) {
+         $dat = gzuncompress($dat);
+      }
+      elseif (($enc == &quot;x-bzip2&quot;) || ($enc == &quot;bzip2&quot;)) {
+         if (function_exists(&quot;bzdecompress&quot;)) {
+            $dat = bzdecompress($dat);
+         }
+         else trigger_error(&quot;http_response::decodeContentEncoding: bzip2 decoding isn't supported with this PHP interpreter version&quot;, E_WARNING);
+      }
+      $this-&gt;len = strlen($this-&gt;content);
+   }
+
+
+   #-- can handle special content-types (multipart, serialized, form-data)
+   function decode() {
+      $t = http_request::type($this-&gt;type, 0);
+      if ($t == &quot;php&quot;) {
+         return(unserialize($this-&gt;content));
+      }
+      elseif ($t == &quot;url&quot;) {
+         parse_str($this-&gt;content, $r);
+         return($r);
+      }
+      elseif ($t == &quot;form&quot;) {
+         // oh, not yet exactly
+      }
+   }
+
+   #-- aliases for compatiblity to PEAR::HTTP_Request
+   function getResponseBody() {
+      return $this-&gt;content;
+   }
+   function getResponseStatus() {
+      return $this-&gt;status;
+   }
+   function getResponseCode() {
+      return $this-&gt;status;
+   }
+   function getResponseHeader($i=NULL) {
+      if (!isset($i)) {
+         return $this-&gt;headers;
+      }
+      $i = strtolower($i);
+      foreach ($this-&gt;headers as $h=&gt;$v) {
+         if (strtolower($h)==$i) {
+            return $v;
+         }
+      }
+   }
+}
+
+
+
+?&gt;
\ No newline at end of file

Added: YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/contrib/http.txt
===================================================================
--- YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/contrib/http.txt	2006-12-09 18:08:01 UTC (rev 2249)
+++ YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/contrib/http.txt	2006-12-09 18:13:10 UTC (rev 2250)
@@ -0,0 +1,270 @@
+
+Note: This class and file will be renamed into &quot;xhttp...&quot; in the near
+feature, to prevent clashes with the old PEAR class.
+
+http.php
+&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;
+This script provides the easy to use &quot;http_request&quot; class (&quot;http_query&quot;
+is an alias). You can contact forms or simply retrieve files with it.
+Unlike fopen_wrappers, you get the response headers alongside and the
+received file will be decompressed on-the-fly (it should also be faster
+due to more supported compression methods).
+
+There are some options, you can set before starting the request. Most
+important aspect is, that you can add form -&gt;params[] one after the
+other for GET and POST requests. You can also use a proxy or include
+authentication passwords in the initially given url, and of course
+inject or override a few -&gt;headers[] when it makes sense.
+
+
+
+usage
+&#175;&#175;&#175;&#175;&#175;
+It is really easy, you only must take care to always give the method
+parameter before the URL (&quot;GET&quot; or &quot;POST&quot; in most cases), look at
+the following:
+
+  &lt;?example
+
+      #-- prepare
+      $query = new http_request(&quot;GET&quot;, &quot;<A HREF="http://example.com/form.php">http://example.com/form.php</A>&quot;);
+      $query-&gt;params[&quot;q&quot;] = &quot;search-this-...&quot;;
+
+      #-- do request
+      $result = $query-&gt;go();
+
+      #-- use result
+      if ($result &amp;&amp; ($result-&gt;status == 200)) {
+         echo $result-&gt;content;
+      }
+  ?&gt;
+
+Note, that we could have included the &quot;q&quot; parameter simply appended to
+the URL in such simple cases (&quot;<A HREF="http://example.com/form.php?q=search-...">http://example.com/form.php?q=search-...</A>&quot;).
+
+You can also do &quot;POST&quot; requests (normal for forms), but that you than
+must decide about the encoding format. There are two for POST requests,
+the default is always urlencoding (like with GET requests) with
+  &lt;?example 
+      $query-&gt;type = &quot;url&quot;;    // corresponds to &quot;app/x-www-form-urlencoded&quot;
+  ?&gt;
+but many bigger forms however require the MIME type for form-data:
+  &lt;?example 
+      $query-&gt;type = &quot;form&quot;;    // translates to &quot;multipart/form-data&quot;
+  ?&gt;
+You see, there are easy to remember abbreviations for this.
+
+The form variables you want to transport are simply appended to the URL
+for GETs or &quot;url&quot;-coded requests, but you could use the $query-&gt;params[]
+array also here.
+
+If you do a &quot;POST&quot; request, you do likewise; or you could also just assign
+the $query-&gt;params a string blob to transfer as content (if the remote app
+can deal with it or expects that, or you already have encoded eveything
+into a valid form request).
+If you just want to add upload-files to a &quot;POST&quot; request, then do this as
+follows:
+  &lt;?example
+      $query-&gt;params[&quot;fileformname&quot;] = array(
+         &quot;filename&quot; =&gt; &quot;original-name.zip&quot;,
+         &quot;type&quot; =&gt; &quot;application/octet-stream&quot;,
+         &quot;content&quot; =&gt; &quot;$READ_FROM_FILE_DATA...&quot;,
+      );
+  // or
+      $query-&gt;params[&quot;2nd_file&quot;] = array(
+         &quot;ct&quot; =&gt; &quot;x.ml/my-format&quot;,
+         &quot;name&quot; =&gt; &quot;../../where/is/it/from.txt&quot;,
+         &quot;data&quot; =&gt; file_get_contents(&quot;.../from.txt&quot;),
+      );
+  ?&gt;
+&quot;body&quot; is a third alias for the &quot;content&quot; field here. If you don't set
+the &quot;type&quot; or &quot;ct&quot; flag it will get &quot;application/octet-stream&quot; per default
+(this is a good default). You could simply load the &quot;ext/mime&quot; script to
+have the best possible MIME type here.
+
+
+
+     start an request
+     &#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;
+     Use the -&gt;go() method to start a prepared HTTP request. The only
+     alias existing today is -&gt;start(); simply derive or edit this class
+     to add your preferred name for this likewise (-&gt;do() cannot be used
+     as it is a PHP reserved word, sorry ;)
+
+     There are two options to -&gt;go(), the first $force will override a few
+     problems, and with the second ($asis) set to 1 or true, you won't get
+     a result object, but the plain HTTP response blob (headers and response
+     body as one large string variable).
+
+
+
+     authentication
+     &#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;
+     If the remote site requires authentification, you would simply give
+     this within the URL:
+      &lt;?example
+         $query = new http_request(&quot;GET&quot;, &quot;<A HREF="http://user:passw@example.com/...">http://user:passw@example.com/...</A>&quot;);
+           // or later:
+         $query-&gt;setURL(&quot;<A HREF="http://username:pw2@server.../">http://username:pw2@server.../</A>&quot;)
+           // or even:
+         $query-&gt;url = &quot;<A HREF="http://name:password@localhost/form.php">http://name:password@localhost/form.php</A>&quot;;
+      ?&gt;
+
+
+
+     proxy
+     &#175;&#175;&#175;&#175;&#175;
+     You can also acccess a form or remote file using a proxy server easily,
+     just follow this:
+      &lt;?example
+         $query = new http_request(&quot;PUT&quot;, &quot;...&quot;);
+         $query-&gt;proxy = &quot;<A HREF="http://servername.proxy.org:3219/">http://servername.proxy.org:3219/</A>&quot;;
+           // ...
+         $result = $query-&gt;go();
+      ?&gt;
+     You could also give a password or username for your proxy server, if
+     you need it (works the same as for above).
+
+
+
+
+reponses
+&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;
+The $result value from the above examples should normally be an object,
+it will be a scalar (false) only if something went really wrong.
+
+It will have at least a -&gt;status field, which is typically 200 for
+succeeded requests. Everything above 500 means an server error, values
+above 400 a transport and request error (= we did something wrong) and
+a 300 response status means a redirection was issued.
+
+For fulfilled requests you can access the returned file/data simply as
+&quot;$result-&gt;content&quot; or &quot;$result-&gt;body&quot; or even &quot;$result-&gt;data&quot; (two aliases
+again).
+
+You will also have a &quot;$result-&gt;headers[]&quot; array, which will hold all
+response HTTP headers in normalized form. Typically this means:
+  &lt;?example
+      echo $result-&gt;headers[&quot;Content-Type&quot;] . &quot;\n&quot;;
+      echo $result-&gt;headers[&quot;Date&quot;] . &quot;\n&quot;;
+      echo $result-&gt;headers[&quot;Last-Modified&quot;] . &quot;\n&quot;;
+      echo $result-&gt;headers[&quot;Content-Length&quot;] . &quot;\n&quot;;
+      echo $result-&gt;headers[&quot;Etag&quot;] . &quot;\n&quot;;    // (beware of the lcased &quot;t&quot; !)
+      echo $result-&gt;headers[&quot;Content-Encoding&quot;] . &quot;\n&quot;;
+      ...
+      print_r($result-&gt;headers);  // much better here ;)
+  ?&gt;
+[[ Elsewhere the field names would be completely lowercased or fully
+uppercase, we have CamelCase here, with the hyphens still in of course. ]]
+
+Please note, that a known &quot;Content-Encoding&quot; was already removed from the
+received -&gt;content. And there is also a more correct &quot;$result-&gt;len&quot; and a
+&quot;$result-&gt;type&quot; shorthand.
+
+A few response types are understand as application data, and in this case
+you can call the $result-&gt;decode() function and get a PHP variable/array
+from the body.
+
+
+
+     redirects
+     &#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;
+     If you expect HTTP redirects (-&gt;status codes from 300 till 375), then
+     the default settings are ok for you, many will automatically be catched
+     and the form data or file request will succeed at the replied URL.
+
+     To tack/catch these cases yourself, simply disable that behaviour with:
+      &lt;?example
+         $query-&gt;active_client = 0;
+      ?&gt;
+
+
+
+PHP-RPC
+&#175;&#175;&#175;&#175;&#175;&#175;&#175;
+Not yet!  But this is probably what it will look like:
+
+  If you control both ends of the Wire, you shouldn't use the slow and
+  buggy (not everything works with everything else) XML-RPC protocol for
+  calling remote functions, but instead use the high speed PHP serialize
+  encoding to transfer data.
+
+  The &quot;http_request&quot; class can natively encode values as such. The MIME
+  type &quot;application/vnd.php.serialized&quot; has been registered explicitely
+  for this purpose (as alternative to &quot;multipart/form-data&quot; encoding,
+  and it is type-safe as opposed to the &quot;/x-www-form-urlencoded&quot; format).
+  Perl and JS implementations exist (probably also one for Python), so
+  plattform-independence should be given.
+
+  PHP-RPC shall inherit (not yet negotiated) some structure from the old
+  XML-RPC protocol. That is, a few names are identical. If you start an
+  request you would therefore do following:
+
+&lt;?php
+
+    function phprpc($server, $function, $args=array()) {
+
+       #-- init
+       $query = new http_request(&quot;POST&quot;, $server);
+
+       #-- set content
+       $query-&gt;type = &quot;php&quot;;  // here corresponds to &quot;app/vnd.php.serialized&quot;
+       $query-&gt;params
+         = array(
+              &quot;method&quot; =&gt; $function,
+              &quot;params&quot; =&gt; $args,
+           );
+
+       #-- start
+       $result = $query-&gt;go();
+       if ($result &amp;&amp; ($result-&gt;status == 200)) {
+
+          $r = $result-&gt;decode();
+          if ($good = $r[&quot;result&quot;]) {
+             return($good);
+          }
+          return($r);
+       }
+    }
+?&gt;
+
+  You of course need a server part to make use of this. Simply try the
+  &quot;ext/phprequest&quot;, in which case you would do the following:
+
+&lt;?php
+
+   include(&quot;ext/phprequest.php&quot;)
+   if (count($_POST) &amp;&amp; ($method = $_POST[&quot;method&quot;])
+   and ($params = $_POST[&quot;params&quot;]))
+   {
+      #-- call known/registered functions
+      $method = strtolower($method);
+      if ($method == &quot;my.func&quot;) {
+         $r = call_user_func_array(&quot;my_func&quot;, $params);
+      }
+      elseif ($method == &quot;system.time&quot;) {
+         $r = time();
+      }
+      elseif ($method == &quot;sytem.listmethods&quot;) {
+         $r = get_defined_functions();
+         $r = $r[&quot;user&quot;];
+      }
+
+      #-- if succeeded
+      if ($r) { 
+         header(&quot;Content-Type: application/vnd.php.serialized&quot;);
+         header(&quot;Content-Encoding: deflate&quot;);
+         $r = array(&quot;result&quot; =&gt; $r);
+         die(gzdeflate(serialize($r));
+      }
+   }
+
+   #-- your normal script can go on here
+   //...
+?&gt;
+
+  You can inject this into anywhere as it only engages, if a PHP-RPC
+  request was detected. 
+
+
+

Added: YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/contrib/phprequest.php
===================================================================
--- YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/contrib/phprequest.php	2006-12-09 18:08:01 UTC (rev 2249)
+++ YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/contrib/phprequest.php	2006-12-09 18:13:10 UTC (rev 2250)
@@ -0,0 +1,52 @@
+&lt;?php
+/*
+   Allows http &quot;POST&quot; and &quot;PUSH&quot; requests with a Content-Type of
+   &quot;application/vnd.php.serialized&quot;. This isn't used in the wild.
+*/
+
+if (empty($_POST)
+and (strtoupper($_SERVER[&quot;REQUEST_METHOD&quot;][0]) == &quot;P&quot;)
+and (strtolower(trim(strtok($_SERVER[&quot;CONTENT_TYPE&quot;], &quot;;,(&quot;)))
+     == &quot;application/vnd.php.serialized&quot;))   
+{
+   #-- search for bare request body
+   if (isset($GLOBALS[&quot;HTTP_RAW_POST_DATA&quot;])) {
+      $_POST = $GLOBALS[&quot;HTTP_RAW_POST_DATA&quot;];
+   }
+   else {
+      $f = fopen(&quot;<A HREF="php://input">php://input</A>&quot;, &quot;rb&quot;);
+      $_POST = fread($f, 1&lt;&lt;22);
+      fclose($f);
+   }
+
+   #-- uncompress and decode, if something found
+   if ($_POST) {
+
+      #-- strip known/supported encodings
+      $enc = trim(strtok(strtolower($_SERVER[&quot;HTTP_CONTENT_ENCODING&quot;]), &quot;,;&quot;));
+      if ($enc == &quot;deflate&quot;) {
+         $_POST = gzinflate($_POST);
+      }
+      elseif ($enc == &quot;compress&quot;) {
+         $_POST = gzuncompress($_POST);
+      }
+      elseif ($enc == &quot;gzip&quot;) {
+         $_POST = function_exists(&quot;gzdecode&quot;) ? gzdecode($_POST) : gzinflate(substr($_POST, 10, strlen($_POST) - 18));
+      }
+      elseif (($enc == &quot;x-bzip2&quot;) or ($enc == &quot;bzip2&quot;)) {
+         $_POST = function_exists(&quot;bzdecompress&quot;) ? bzdecompress($_POST) : NULL;
+      }
+
+      #-- decipher
+      if ($_POST) {
+         $_POST = unserialize($_POST);
+      }
+      #-- merge
+      if ($_POST) {
+         $_REQUEST = array_merge($_REQUEST, $_POST);
+      }
+
+   }
+}
+
+?&gt;
\ No newline at end of file

Added: YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/contrib/xmlrpc.meta
===================================================================
--- YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/contrib/xmlrpc.meta	2006-12-09 18:08:01 UTC (rev 2249)
+++ YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/contrib/xmlrpc.meta	2006-12-09 18:13:10 UTC (rev 2250)
@@ -0,0 +1,9 @@
+api: PHP
+type: api
+provides: rpc, xml-rpc
+version: 0.3.10
+category: library
+priority: optional
+title: XML-RPC client and server
+description: serves remote procedure calls
+homepage: <A HREF="http://freshmeat.net/p/upgradephp">http://freshmeat.net/p/upgradephp</A>

Added: YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/contrib/xmlrpc.php
===================================================================
--- YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/contrib/xmlrpc.php	2006-12-09 18:08:01 UTC (rev 2249)
+++ YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/contrib/xmlrpc.php	2006-12-09 18:13:10 UTC (rev 2250)
@@ -0,0 +1,1148 @@
+&lt;?php define(&quot;XMLRPC_VERSION&quot;, &quot;0.3.10&quot;);
+#
+#  Supports XML-RPC (text/xml) and XML+RPC (application/rpc+xml) compressed,
+#  and can be used as client or server interface. Works without XMLRPC and
+#  XML extensions, but utilizes them for optimal speed whenever available.
+#
+#   XXXX   XXXX MMM     MMM LLL              RRRRRRR   PPPPPPP    CCCCCCC
+#    XXXX XXXX  MMMM   MMMM LLL      +++     RRRRRRRR  PPPPPPPP  CCCCCCCCC
+#     XXXXXXX   MMMMM MMMMM LLL      +++     RRR   RRR PPP   PPP CCC    CCC
+#      XXXXX    MMMMMMMMMMM LLL  +++++++++++ RRR   RRR PPP   PPP CCC
+#       XXX     MMM MMM MMM LLL  +++++++++++ RRRRRRRR  PPPPPPPP  CCC
+#      XXXXX    MMM  M  MMM LLL      +++     RRRRRRR   PPPPPPP   CCC
+#     XXXXXXX   MMM     MMM LLL      +++     RRR  RRR  PPP       CCC    CCC
+#    XXXX XXXX  MMM     MMM LLLLLLL          RRR   RRR PPP       CCCCCCCCC
+#   XXXX   XXXX MMM     MMM LLLLLLL          RRR   RRR PPP        CCCCCCC
+#
+#  This is Public Domain. (c) 2004 WhoEver wants to. [milky*erphesfurt&#183;de]
+
+
+#-- config
+define(&quot;XMLRPC_PLUS&quot;, 0);        # use XML+RPC per default
+define(&quot;XMLRPC_AUTO_TYPES&quot;, 0);  # detect base64+datetime strings and automatically generate the according xmlrpc object representations then
+define(&quot;XMLRPC_AUTO_UTF8&quot;, 1);   # de/convert anything from and to UTF-8 automatically - if yourscripts use Latin1 natively, but the RPC server expects/sends UTF-8
+define(&quot;XMLRPC_CHARSET&quot;, &quot;utf-8&quot;);  # used in responses and requests
+define(&quot;XMLRPC_AUTODISCOVERY&quot;, 0);  # &quot;connections&quot; automatically create methods
+define(&quot;XMLRPC_FAST&quot;, 1);        # use PHPs XML-RPC extension where possible
+define(&quot;XMLRPC_OO&quot;, 1);          # return XML-RPC/HTTP errors as objects
+define(&quot;XMLRPC_DEBUG&quot;, 0);       # output error hints, write /tmp dumps - set this to 1, 2 or 3
+
+#-- _server() settings
+define(&quot;XMLRPC_LOG&quot;, &quot;/tmp/xmlrpc.&quot;.@$_SERVER[&quot;SERVER_NAME&quot;].&quot;.log&quot;);
+
+#-- general data
+#  (don't change the following, most are auto-configured values)
+define(&quot;XMLRPC_UA&quot;, &quot;xml+rpc/&quot;.XMLRPC_VERSION.&quot; (PHP/&quot;.PHP_VERSION.&quot;; &quot;.PHP_OS.&quot;)&quot;);
+define(&quot;XMLRPC_MIME_NEW&quot;, &quot;application/rpc+xml&quot;);
+define(&quot;XMLRPC_MIME_OLD&quot;, &quot;text/xml&quot;);
+define(&quot;XMLRPC_MIME&quot;, XMLRPC_MIME_OLD);
+define(&quot;XMLRPC_ACCEPT&quot;, XMLRPC_MIME_NEW.&quot;, &quot;.XMLRPC_MIME_OLD.&quot;; q=0.5&quot;);
+define(&quot;XMLRPC_EPI&quot;, function_exists(&quot;xmlrpc_decode_request&quot;));
+
+#-- init
+error_reporting(0);
+if (isset($_SERVER[&quot;HTTP_CONTENT_TYPE&quot;]) &amp;&amp; empty($_SERVER[&quot;CONTENT_TYPE&quot;])) {
+   $_SERVER[&quot;CONTENT_TYPE&quot;] = $_SERVER[&quot;HTTP_CONTENT_TYPE&quot;];   // older CGI implementations
+}
+
+
+
+
+############################################################################
+#                                                                          #
+#  client part                                                             #
+#                                                                          #
+############################################################################
+
+
+#-- Issue a request, call can take any number of arguments.
+#     $result = xmlrpc(&quot;<A HREF="http://example.com/RPC2/">http://example.com/RPC2/</A>&quot;, &quot;method1&quot;, $arg1 ...);
+#     $result = xmlrpc(&quot;xml+<A HREF="rpc://here.org/RPC3/">rpc://here.org/RPC3/</A>&quot;, &quot;ns.function&quot;, ...);
+#   Results automatically have &lt;datetime&gt; values converted into Unix
+#   timestamps and &lt;base64&gt; unpacked into strings.
+#
+function xmlrpc($server, $method=NULL /*, ... */) {
+   if ($method) {
+      $params = func_get_args();
+      shift($params); shift($params);
+      return
+        xmlrpc_request($server, $method, $params);
+   }
+   else {
+      return
+        new xmlrpc_connection($server);
+   }
+}
+
+
+
+#--  Generate and send request, decode response.
+function xmlrpc_request($url, $method, $params=array(), $plus=XMLRPC_PLUS, $gzip=0) {
+   global $xmlrpc_response_headers, $xmlrpc_error;
+   
+   #-- init whole lib for request (we are not-OO here)
+   $xmlrpc_error = false;
+   $xmlrpc_response_headers = array();
+   
+   #-- encapsulate req, transmit it
+   $socket = xmlrpc_request_send($url, $method, $params, $plus, $gzip);
+   if (!$socket) {
+      return xmlrpc_error(-32768, &quot;no connection&quot;, 0, &quot;GLOBALVARS&quot;);
+   }
+
+   #-- wait for, read response
+   $response = &quot;&quot;;
+   while (!feof($socket) &amp;&amp; (strlen($DATA) &lt;= 768&lt;&lt;10)) {
+      $response .= fread($socket, 4&lt;&lt;10);
+   }
+   fclose($socket);
+   if (XMLRPC_DEBUG &gt;= 3) {
+      echo &quot;&lt;code&gt;$response&lt;/code&gt;&quot;;
+   }
+
+   #-- decode answer and give results
+   return xmlrpc_response_decode($response);
+}
+
+
+#-- an alias
+function xmlrpc_call($url, $method, $params=array(), $plus=XMLRPC_PLUS, $gzip=0) {
+   return xmlrpc_request($url, $method, $params, $plus, $gzip);
+}
+
+
+
+#-- marshall request parameters into array, hash, xml string
+function xmlrpc_request_send($url, $method, &amp;$params, $plus, $gzip, $blocking=true) {
+
+   #-- get connection data
+   $c = parse_url($url);
+   ($host = $c[&quot;host&quot;]);
+   ($port = @$c[&quot;port&quot;]) or ($port = 80);
+   ($path = $c[&quot;path&quot;]) or ($path = &quot;/&quot;);
+   if (strpos($c[&quot;scheme&quot;], &quot;+&quot;)) {
+      $plus++;
+   }
+   if (strpos($c[&quot;scheme&quot;], &quot;gzip&quot;)) {
+      $gzip++;
+   }
+   if (!$host) { return(NULL); }
+   $inj = &quot;&quot;;
+   if ($str = $c[&quot;user&quot;]) {
+      if ($c[&quot;pass&quot;]) { $str .= &quot;:&quot; . $c[&quot;pass&quot;]; }
+      $inj = &quot;Authorization: Basic &quot; . base64_encode($str) . &quot;\n&quot;;
+   }
+   
+   #-- mk request HTTP+XML block from params
+   $request = xmlrpc_request_marshall($method, $params);
+   $request = xmlrpc_request_http($request, $path, $host, $plus, $gzip, $inj);
+
+   #-- connect, send request
+   if ($socket = fsockopen($host, $port, $io_err, $io_err_s, 30)) {
+      socket_set_blocking($socket, $blocking);
+      socket_set_timeout($socket, 17, 555);
+   }
+   else {
+      echo &quot;Could not connect to '&lt;b&gt;$host&lt;/b&gt;:$port$path' - error $io_err: $io_err_s.&lt;br&gt;\n&quot;;
+      return(NULL);
+   }
+   fputs($socket, $request);
+
+   #-- done here
+   return($socket);
+}
+
+
+#-- marshall function call into XML+HTTP string
+function xmlrpc_request_marshall($method, &amp;$params) {
+
+   #-- use xmlrpc-epi
+   if (XMLRPC_FAST &amp;&amp; XMLRPC_EPI) {
+      $query = xmlrpc_encode_request($method, $params);
+      return($query);
+   }
+
+   #-- build query
+   $query = array(
+      &quot;methodCall&quot; =&gt; array(
+         &quot;methodName&quot; =&gt; array( &quot;,0&quot;=&gt;$method ),
+         &quot;params&quot; =&gt; array()
+      )
+   );
+   foreach ($params as $i=&gt;$p) {
+      $query[&quot;methodCall&quot;][&quot;params&quot;][&quot;param,$i&quot;] = xmlrpc_compact_value($p);
+   }
+   $query = array2xml($query, 1, 'encoding=&quot;'.XMLRPC_CHARSET.'&quot; ');
+
+   #-- encode?
+   if (XMLRPC_AUTO_UTF8) {
+      $query = utf8_encode($query);
+   }
+   
+   return($query);   
+}
+
+
+#-- enclose body into HTTP request string
+function xmlrpc_request_http(&amp;$query, $path, $host, $plus, $gzip, $inj_header=&quot;&quot;) {
+
+   #-- build request
+   $n = &quot;\015\012&quot;;
+   $request = &quot;POST $path HTTP/1.0$n&quot;
+            . &quot;Host: $host$n&quot;
+            . ($inj_header ? str_replace(&quot;\n&quot;, $n, $inj_header) : &quot;&quot;)
+            . &quot;User-Agent: &quot; . XMLRPC_UA . &quot;$n&quot;
+            . &quot;Accept: &quot;.XMLRPC_ACCEPT.&quot;$n&quot;
+            . (!XMLRPC_DEBUG ? &quot;Accept-Encoding: deflate$n&quot; : &quot;&quot;)
+            . &quot;Content-Type: &quot;.($plus ? XMLRPC_MIME_NEW : XMLRPC_MIME_OLD)
+                              .&quot;; charset=&quot;.XMLRPC_CHARSET.&quot;$n&quot;;
+
+   #-- compress?
+   if ($gzip) {
+      $query = gzdeflate($query);
+      $request .= &quot;Content-Encoding: deflate$n&quot;;
+   }
+   $request .= &quot;Content-Length: &quot; . strlen($query) . &quot;$n&quot; . &quot;$n&quot;;
+   $request .= $query . &quot;$n&quot;;
+
+   return($request);
+}
+
+
+#-- unpack response from HTTP and XML representation
+function xmlrpc_response_decode(&amp;$response) {
+   global $xmlrpc_response_headers;
+
+   #-- split into headers and content
+   $l1 = strpos($response, &quot;\n\n&quot;);
+   $l2 = strpos($response, &quot;\n\r\n&quot;);
+   if ($l2 &amp;&amp; (!$l1 || ($l2&lt;$l1))) {
+      $head = substr($response, 0, $l2);
+      $response = substr($response, $l2+3);
+   }
+   else {
+      $head = substr($response, 0, $l1);
+      $response = substr($response, $l2+2);
+   }
+
+   #-- decode headers, decompress body
+   foreach (explode(&quot;\n&quot;, $head) as $line) {
+      $xmlrpc_response_headers[strtolower(trim(strtok($line, &quot;:&quot;)))] = trim(strtok(&quot;\000&quot;));
+   }
+   if ($enc = trim(@$xmlrpc_response_headers[&quot;content-encoding&quot;])) {
+      if (($enc == &quot;gzip&quot;) || ($enc == &quot;x-gzip&quot;)) {
+         $response = gzinflate(substr($response, 10, strlen($response)-18));
+      }
+      elseif (($enc == &quot;compress&quot;) || ($enc == &quot;x-compress&quot;)) {
+         $response = gzuncompress($response);
+      }
+      elseif (($enc == &quot;deflate&quot;) || ($enc == &quot;x-deflate&quot;)) {
+         $response = gzinflate($response);
+      }
+   }
+
+   $r = xmlrpc_response_unmarshall($response);
+   if (XMLRPC_DEBUG) {var_dump($r);}
+   return($r);
+}
+
+
+#-- decode XML-RPC from string into array and extract its actual meaning
+function xmlrpc_response_unmarshall(&amp;$response) {
+   global $xmlrpc_response_headers;
+
+   #-- strip encoding
+   if (XMLRPC_AUTO_UTF8) {
+      xmlrpc_decode_utf8xml($response, @$xmlrpc_response_headers[&quot;content-type&quot;].@$xmlrpc_response_headers[&quot;content-charset&quot;]);
+   }
+
+   if (XMLRPC_DEBUG &gt;= 4) { fwrite(fopen(&quot;/tmp/xmlrpc:resp_in_xml&quot;,&quot;w&quot;), $response); }
+   
+   #-- use xmlrpc-epi
+   if (XMLRPC_FAST &amp;&amp; XMLRPC_EPI) {
+      $r = xmlrpc_decode_request($response, $uu);
+      xmlrpc_epi_decode_xtypes($r);
+      if (is_array($r) &amp;&amp; (count($r)==2) &amp;&amp; isset($r[&quot;faultCode&quot;]) &amp;&amp; isset($r[&quot;faultString&quot;])) {
+         return xmlrpc_error($r[&quot;faultCode&quot;], $r[&quot;faultString&quot;], 1, &quot;GLOBALVARS&quot;);
+      }
+      else {
+         return($r);
+      }
+   }
+
+
+   #-- unmarshall XML
+   $response = xml2array($response);
+
+   #-- fetch content (one returned element)
+   if ($r = @$response[&quot;methodResponse,0&quot;][&quot;params,0&quot;][&quot;param,0&quot;][&quot;value,0&quot;]) {
+      $r = xmlrpc_decode_value($r);
+      return($r);
+   }
+  
+   #-- error cases
+   #  (we should rather return an error object here)
+   if (($r = @$response[&quot;methodResponse,0&quot;][&quot;fault,0&quot;][&quot;value,0&quot;]) &amp;&amp; ($r = xmlrpc_decode_value($r))) { 
+      return xmlrpc_error($r[&quot;faultCode&quot;], $r[&quot;faultString&quot;], 1, &quot;GLOBALVARS&quot;);
+   }
+   else {
+      return xmlrpc_error(-32600, &quot;xml+rpc: invalid response&quot;, 0, &quot;GLBLVRS&quot;);
+   }
+   return(NULL);
+}
+
+
+
+#-- Establish a virtual XML+RPC or XML-RPC server connection (a pseudo
+#   handshake is used to determine supported protocol / extensions).
+class xmlrpc_connection {
+
+   #-- init
+   function xmlrpc_connection($url, $autodiscovery=0) {
+      global $xmlrpc_response_headers;
+      $this-&gt;server = $url;
+      $this-&gt;plus = 0;
+      $this-&gt;gzip = 0;
+
+      #-- handshake to check supported protocol
+      $funcs = $this-&gt;call(&quot;system.getVersion&quot;);
+      $this-&gt;plus = (strpos($xmlrpc_response_headers[&quot;accept&quot;], XMLRPC_MIME_NEW) !== false);
+      $this-&gt;gzip = (strpos($xmlrpc_response_headers[&quot;accept_encoding&quot;], &quot;deflate&quot;) !== false);
+      
+      #-- auto-discovery, create 'method' names
+      if ($funcs &amp;&amp; (XMLRPC_AUTODISCOVERY || $autodiscovery)) {
+         foreach ($funcs as $fn) {
+            $short = $fn;
+            if ($l = strpos($fn, &quot;.&quot;)) {
+               $short = substr($fn, $l + 1);
+               if (substr($fn, 0, $l) == &quot;system&quot;) { continue; }
+            }
+            $this-&gt;short = create_function(&quot;&quot;, &quot;return xmlrpc_request('{$this-&gt;server}','$fn',func_get_args(),{$this-&gt;plus},{$this-&gt;gzip});&quot;);
+         }
+      }
+   }
+   
+   #-- generical call (needs func name)
+   function call($method /*, ... */) {
+      $params = func_get_args();
+      shift($params);
+      $r = xmlrpc_request($this-&gt;serverm, $method, $params, $this-&gt;plus, $this-&gt;gzip);
+      return($r);
+   }
+}
+
+#-- an alias
+class xmlrpc extends xmlrpc_connection {
+}
+
+
+
+
+############################################################################
+#                                                                          #
+#  server implementation                                                   #
+#                                                                          #
+############################################################################
+
+
+#-- Check request and execute function if registered in $xmlrpc_methods[]
+#   array.
+function xmlrpc_server() {
+
+   global $xmlrpc_methods;
+
+   #-- server is active
+   define(&quot;XMLRPC_SERVER&quot;, getmypid());
+   if (XMLRPC_DEBUG) { error_reporting(E_ALL^E_NOTICE); }
+   ob_start();
+
+   #-- standard reply headers
+   header(&quot;Accept: &quot;.XMLRPC_MIME_NEW.&quot;, &quot;.XMLRPC_MIME_OLD.&quot;; q=0.5&quot;);
+   header(&quot;Accept-Encoding: deflate&quot;);
+   header(&quot;X-Server: &quot; . XMLRPC_UA);
+   header(&quot;Connection: close&quot;);
+   header(&quot;Cache-Control: private&quot;);
+
+   #-- fixes for PHP/Apache
+   if (function_exists(&quot;getallheaders&quot;)) {
+      foreach (getallheaders() as $i=&gt;$v) {
+         $_SERVER[strtoupper(strtr(&quot;HTTP_$i&quot;, &quot;-&quot;, &quot;_&quot;))] = $v;
+      }
+   }
+
+   #-- check and get call
+   $allowed = array(
+      &quot;REQUEST_METHOD&quot; =&gt; array(&quot;POST&quot;, &quot;PUT&quot;, &quot;CALL&quot;),
+      &quot;CONTENT_TYPE&quot; =&gt; array(XMLRPC_MIME_NEW, XMLRPC_MIME_OLD),
+   );
+   foreach ($allowed as $WHAT=&gt;$WHICH) {
+      if (!in_array(trim(strtok($WRONG=$_SERVER[$WHAT], &quot;;,(&quot;)), $WHICH)) {
+         header(&quot;Status: 400 Go Away, Stupid!&quot;);
+         if (!$WRONG) {
+            $WRONG = &quot;undefined&quot;;
+         }
+         die(&quot;&lt;h2&gt;Error&lt;/h2&gt;Your request was bogus, &lt;b&gt;$WHAT&lt;/b&gt; must be &lt;i&gt;&quot;
+             . implode(&quot;&lt;/i&gt; or &lt;i&gt;&quot;, $WHICH) . &quot;&lt;/i&gt;, but yours was '&lt;tt&gt;$WRONG&lt;/tt&gt;'.\n&quot;);
+      }
+   }
+   if (!($xml_request = xmlrpc_fetch_post_chunk())) {
+      header(&quot;Status: 500 How Sad&quot;);
+      die(&quot;&lt;h2&gt;Error&lt;/h2&gt;Could not fetch POST data.\n&quot;);
+   }
+
+   #-- decipher incoming XML request string
+   $method = &quot;&quot;;
+   if (XMLRPC_FAST &amp;&amp; XMLRPC_EPI) {
+      $params = xmlrpc_decode_request($xml_request, $method);
+      xmlrpc_epi_decode_xtypes($params);
+   }
+   else {
+      $params = xmlrpc_request_unmarshall($xml_request, $method);
+   }
+
+   
+   #-- add the few system.methods()
+   //if (empty($xmlrpc_methods)) {
+   //   $xmlrpc_methods = get_defined_functions();
+   //}
+   $xmlrpc_methods[&quot;system&quot;] = &quot;xmlrpc_system_methods&quot;;   # a class
+
+   #-- call
+   $result = xmlrpc_exec_method($method, $params);
+
+   #-- send back result
+   if (isset($result)) {
+      if (isset($result)) {
+         $resp[&quot;methodResponse&quot;][&quot;params&quot;][&quot;param&quot;] = xmlrpc_compact_value($result);
+      }
+      else {
+         $resp[&quot;methodResponse&quot;][&quot;params&quot;] = array();
+      }
+
+      xmlrpc_send_response($resp);
+   }
+   else {
+      $result = xmlrpc_error(0, &quot;No Result&quot;);
+      xmlrpc_send_response($result);
+   }
+}
+
+
+
+#-- decode &lt;methodCall&gt; XML string into understandable chunks,
+#   gives $params as return value and $method name via pass-by-ref
+function xmlrpc_request_unmarshall(&amp;$xml_request, &amp;$method) {
+
+   #-- mangle charset
+   if (XMLRPC_AUTO_UTF8) {
+      xmlrpc_decode_utf8xml($xml_request, $_SERVER[&quot;CONTENT_TYPE&quot;].$_SERVER[&quot;HTTP_CONTENT_CHARSET&quot;]);
+   }
+
+   #-- decode XML string into PHP arrays
+   $call = xml2array($xml_request, 1);
+   $xml_request = NULL;
+
+   $call = $call[&quot;methodCall,0&quot;];
+   if (!$call) {
+      xmlrpc_send_response(xmlrpc_error(-32600, &quot;Bad Request, &lt;methodCall&gt; missing&quot;));
+   }
+   $method = $call[&quot;methodName,0&quot;][&quot;,0&quot;];
+   if (!$method) {
+      xmlrpc_send_response(xmlrpc_error(-32600, &quot;Bad Request, &lt;methodName&gt; missing&quot;));
+   } 
+
+   $params = array();
+   foreach ($call[&quot;params,1&quot;] as $uu =&gt; $param) {
+      $params[] = xmlrpc_decode_value($param[&quot;value,0&quot;]);
+   }
+
+   return($params);
+}
+
+
+
+#-- Call the requested method (using the XML-method to PHP-function mapping
+#   table and hints).
+function xmlrpc_exec_method($method, $params) {
+
+   global $xmlrpc_methods;
+   if (XMLRPC_DEBUG &gt;= 2) { error_reporting(E_ALL^E_NOTICE); }
+
+   #-- check if allowed call
+   $rf = strtr($method, &quot;.&quot;, &quot;_&quot;);
+   $cl = strtok($method, &quot;.&quot;);
+   if (!$xmlrpc_methods[$method] &amp;&amp; !$xmlrpc_methods[$cl]
+      &amp;&amp; !in_array($method, $xmlrpc_methods)
+      &amp;&amp; !in_array($rf, $xmlrpc_methods) &amp;&amp; !in_array($cl, $xmlrpc_methods) )
+   {
+      xmlrpc_send_response(xmlrpc_error(-32601));
+   }
+
+   #-- real function call
+   if ($php_func_name = $xmlrpc_methods[$method]) {
+      $rf = $method = $php_func_name;
+   }
+   if (function_exists($rf)) {
+      $result = call_user_func_array($rf, $params);
+      if (XMLRPC_DEBUG &gt;= 4) { fwrite(fopen(&quot;/tmp/xmlrpc:func_call_res&quot;,&quot;w&quot;),serialize(array($rf,$result,$params))); }
+      return($result);
+   }
+   #-- PHP object method calls
+   else {
+      $class = strtok($method, &quot;.&quot;);
+      $method = strtok(&quot;\000&quot;);
+      if ($uu = $xmlrpc_methods[$class]) {
+         $class = $uu;
+      }
+      if ($class &amp;&amp; class_exists($class) &amp;&amp; $method) {
+         $obj = new $class;
+         if (method_exists($obj, $method)) {
+            $result = call_user_method_array($method, $obj, $params);  //&lt;DEPRECATED&gt;
+            return($result);
+         }
+      }
+   }
+
+   #-- else error
+   xmlrpc_send_response(xmlrpc_error(-32601));
+}
+
+
+
+#-- Get POST data from PHP (if it gives it to us).
+function xmlrpc_fetch_post_chunk() {
+   global $HTTP_RAW_POST_DATA;
+
+   $data = false;
+   if ($f = fopen(&quot;<A HREF="php://input">php://input</A>&quot;, &quot;rb&quot;)) {
+      $data = fread($f, 0x0100000);
+      fclose($f);
+   }
+   if (empty($data)) {
+      ini_set(&quot;always_populate_raw_post_data&quot;, &quot;true&quot;);  // well, maybe(!?)
+      $data = $HTTP_RAW_POST_DATA;
+      $HTTP_RAW_POST_DATA = &quot;&quot;;
+   }
+   $enc = trim(strtolower($_SERVER[&quot;HTTP_CONTENT_ENCODING&quot;]));
+   $funcs = array(&quot;deflate&quot;=&gt;&quot;gzinflate&quot;, &quot;gzip&quot;=&gt;&quot;gzdecode&quot;, &quot;compress&quot;=&gt;&quot;gzuncompress&quot;, &quot;x-gzip&quot;=&gt;&quot;gzdecode&quot;, &quot;x-bzip2&quot;=&gt;&quot;bzuncompress&quot;);
+   if ($enc &amp;&amp; ($pf = $funcs[$enc]) &amp;&amp; function_exists($pf)) {
+      $data = $pf($data);
+   }
+   return($data);
+}
+
+
+#-- converts UTF-8 documents into Latin-1 ones
+function xmlrpc_decode_utf8xml(&amp;$xml, $ct) {
+   if (strpos(strtolower($ct), &quot;utf-8&quot;) or preg_match('/&lt;\?xml[^&gt;]+encoding=[&quot;\']utf-8/i', $xml)) {
+      $xml = utf8_decode($xml);
+      $xml = preg_replace('/(&lt;\?xml[^&gt;]+encoding=[&quot;\'])utf-8([&quot;\'])/i', '$1iso-8859-1$2', $xml, 1);
+   }
+}
+
+
+
+#-- Creates an error object.
+function xmlrpc_error($no=-32500, $str=&quot;&quot;, $type=1, $into_vars=0) {
+   global $xmlrpc_error, $xmlrpc_errorcode;
+   $errors = array(
+           0 =&gt; &quot;No Result&quot;,
+      -32300 =&gt; &quot;Transport error&quot;,
+      -32400 =&gt; &quot;Internal Server Error&quot;,
+      -32500 =&gt; &quot;Application error&quot;,
+      -32600 =&gt; &quot;Invalid message format / Bad request&quot;,
+      -32601 =&gt; &quot;Method does not exist&quot;,
+      -32602 =&gt; &quot;Parameter type mismatch&quot;,
+      -32603 =&gt; &quot;Internal XML-RPC error&quot;,
+      -32604 =&gt; &quot;Too many parameters&quot;,
+      -32700 =&gt; &quot;Not well-formed XML&quot;,
+      -32701 =&gt; &quot;Unsupported encoding - only ISO-8859-1 and UTF-8 capable&quot;,
+      -32702 =&gt; &quot;Invalid characters, encoding mismatch&quot;,
+   );
+   #-- build response xml/array
+   if (!($str) &amp;&amp; !($str = $errors[$no])) {
+      $str = &quot;Unknown Error&quot;;
+   }
+   if ($into_vars &amp;&amp; !XMLRPC_OO) {
+      $xmlrpc_error = $str;
+      $xmlrpc_errorcode = $no;
+      return(NULL);
+   }
+   else {
+      return new xmlrpc_error($no, $str, $type);
+   }
+}
+
+
+#-- error object
+class xmlrpc_error {
+
+   var $type = 1;   // else an HTTP error
+   var $no;
+   var $str;
+   
+   function xmlrpc_error($no, $str, $type=1) {
+      $this-&gt;type = $type;
+      $this-&gt;no = $no;
+      $this-&gt;str = $str;
+   }
+   
+   function send() {
+      $error = xmlrpc_compact_value(array(
+         &quot;faultCode&quot; =&gt; $no,
+         &quot;faultString&quot; =&gt; $str,
+      ));
+      $resp = array(
+         &quot;methodResponse&quot; =&gt; array(
+            &quot;fault&quot; =&gt; $error
+         )
+      );
+      xmlrpc_send_response($resp);
+   }
+}
+
+
+#-- Sends a response.
+function xmlrpc_send_response($r) {
+
+   #-- error objects send itself (by calling _send_response() again ;-)
+   if (is_object($r)) {
+      $r-&gt;send();
+   }
+
+   #-- answer XML-RPC and XML+RPC requests
+   $ct = trim(strtok(strtolower($_SERVER[&quot;CONTENT_TYPE&quot;]), &quot;;,(&quot;));  // from original request
+   $cs = XMLRPC_CHARSET;
+   header(&quot;Content-Type: $ct; charset=\&quot;$cs\&quot;&quot;);
+   
+   #-- make XML document from it
+   if (is_array($r)) {
+      $r = array2xml($r, 1, 'encoding=&quot;'.$cs.'&quot; ');
+   }
+
+   #-- compress answer?
+   if (!headers_sent()) {
+      $enc = trim(strtolower($_SERVER[&quot;HTTP_ACCEPT_ENCODING&quot;]));
+      $funcs = array(&quot;deflate&quot;=&gt;&quot;gzdeflate&quot;, &quot;gzip&quot;=&gt;&quot;gzencode&quot;, &quot;compress&quot;=&gt;&quot;gzcompress&quot;, &quot;x-gzip&quot;=&gt;&quot;gzencode&quot;, &quot;x-bzip2&quot;=&gt;&quot;bzcompress&quot;);
+      if ($enc &amp;&amp; ($pf = $funcs[$enc]) &amp;&amp; function_exists($pf)) {
+         header(&quot;Content-Encoding: $enc&quot;);
+         $r = $pf($r);
+      }
+   }
+
+   #-- send
+   if (ob_get_level()) {
+      #-- this prevents that PHP errors appear as garbage in our response
+      $add .= &quot;&lt;!--\n&quot; . ob_get_contents() . &quot;\n--&gt;&quot;;
+      ob_end_clean();
+   }
+   header(&quot;Content-Length: &quot; . strlen($r));
+   print $r . $add;
+   die;
+}
+
+
+
+#-- Provides &quot;system.*&quot; method namespace.
+class xmlrpc_system_methods {
+
+   function listMethods() {
+      global $xmlrpc_methods;
+      $r = array();
+      foreach ($xmlrpc_methods as $i=&gt;$i2) {
+         $real = is_int($i) ? $i2 : $i;
+         if (class_exists($real) &amp;&amp; ($i2=$real) || class_exists($i2)) {
+            foreach (get_class_methods($i2) as $add) {
+               $r[] = $real.&quot;.&quot;.$add;
+            }
+         }
+         else {
+            $r[] = $real;
+         }
+      }
+      return($r);
+   }
+
+   function time() {
+      return new xmlrpc_datetime(time());
+   }
+}
+
+
+############################################################################
+#                                                                          #
+#  misc functions                                                          #
+#                                                                          #
+############################################################################
+
+
+function xmlrpc_log($message) {
+}
+
+function xmlrpc_die($error=&quot;&quot;, $str=&quot;&quot;) {
+}
+
+
+
+############################################################################
+#                                                                          #
+#  data representation mangling                                            #
+#                                                                          #
+############################################################################
+
+
+#-- Makes compact-array2xml datavar from a PHP variable.
+function xmlrpc_compact_value($var, $n=0) {
+
+   #-- create compact-array2xml tree
+   $root = array(
+      &quot;value,$n&quot; =&gt; array(),
+   );
+   $r = &amp;$root[&quot;value,$n&quot;];
+
+   #-- detect PHP values to be complex types in XML-RPC
+   if (XMLRPC_AUTO_TYPES &amp;&amp; is_string($var)) {
+      if ((strlen($var) &gt;= 64) &amp;&amp; preg_match('/^[\w]+=*$/', $var)) {
+         $var = new xmlrpc_base64($var);
+      }
+      elseif ((strlen($var)==17) &amp;&amp; ($var[8]==&quot;T&quot;) &amp;&amp; preg_match('/^\d{8}T\d\d:\d\d:\d\d$/', $var)) {
+         $var = new xmlrpc_datetime($var);
+      }
+   }
+
+   #-- complex types
+   if (is_object($var)) {
+      $r = $var-&gt;out();
+   }
+   #-- arrays and hashes(structs)
+   elseif (is_array($var)) {
+      if (isset($var[0]) || empty($var)) {
+         $r = array(&quot;array,$n&quot; =&gt; array(&quot;data,0&quot; =&gt; array()));
+         $r = &amp;$r[&quot;array,$n&quot;][&quot;data,0&quot;];
+         foreach ($var as $n=&gt;$val) {
+            $r = array_merge($r, xmlrpc_compact_value($val, $n));
+         }
+      }
+      else {
+         $r = array(&quot;struct,$n&quot;=&gt;array());
+         $r = &amp;$r[&quot;struct,$n&quot;];
+         $n = 0;
+         foreach ($var as $i=&gt;$val) {
+            $r[&quot;member,$n&quot;] = array_merge(array(
+               &quot;name,0&quot; =&gt; array(&quot;,0&quot; =&gt; &quot;$i&quot;),
+            ), xmlrpc_compact_value($val, 1));
+            $n++;
+         }
+      }
+   }
+   #-- simple types
+   elseif (is_bool($var)) {
+      $r = array(
+         &quot;boolean,$n&quot; =&gt; array(&quot;,0&quot; =&gt; ($var?1:0)),
+      );
+   }
+   elseif (is_int($var)) {
+      $r = array(
+         &quot;int,$n&quot; =&gt; array(&quot;,0&quot; =&gt; $var),
+      );
+   }
+   elseif (is_float($var)) {
+      $r = array(
+         &quot;double,$n&quot; =&gt; array(&quot;,0&quot; =&gt; $var),
+      );
+   }
+   elseif (is_string($var)) {
+      $r = array(
+         &quot;string,$n&quot; =&gt; array(&quot;,0&quot; =&gt; $var),
+      );
+   }
+   return($root);
+}
+
+
+#-- Makes a PHP array from a compact-xml2array representation. $value must
+#   always be the xml2array elements _below_ the [&quot;value,0&quot;] or [&quot;data,0&quot;]
+#   or [&quot;member,N&quot;] entry.
+function xmlrpc_decode_value($value) {
+   $val = NULL;
+   foreach ($value as $i=&gt;$d) {
+
+      #-- use single (text) content xml2array entry as actual $d var
+      if (is_array($d) &amp;&amp; isset($d[&quot;,0&quot;])) {
+         $d = $d[&quot;,0&quot;];
+      }
+
+      #-- convert into PHP var based on type
+      $type = strtok($i, &quot;,&quot;);
+      switch ($type) {
+
+         case &quot;array&quot;:
+            $val = array();
+            foreach ($d[&quot;data,0&quot;] as $i=&gt;$value) {
+               $val[] = xmlrpc_decode_value($value);
+            }
+            break;
+
+         case &quot;struct&quot;:
+            $val = array();
+            foreach ($d as $uu=&gt;$d2) {
+               if (($in=$d2[&quot;name,0&quot;][&quot;,0&quot;]) &amp;&amp; ($pos2=1) || ($in=$d2[&quot;name,1&quot;][&quot;,0&quot;]) &amp;&amp; ($pos2=0)) {
+                  $val[$in] = xmlrpc_decode_value($d2[&quot;value,$pos2&quot;]);
+               }
+            }
+            break;
+
+         case &quot;&quot;:    # handles also '&lt;value&gt;s&lt;/value&gt;' instead
+         case &quot;0&quot;:   # of '&lt;value&gt;&lt;string&gt;s&lt;/string&gt;&lt;/value&gt;'
+         case &quot;string&quot;:
+            $val =  is_array($d) ? &quot;&quot; : (string)$d;
+            break;
+
+         case &quot;base64&quot;:
+            $val = (XMLRPC_AUTO_TYPES&gt;=2) ? base64_decode($d) : (string)$d;
+            if ((XMLRPC_AUTO_UTF8 &gt;= 2) &amp;&amp; ($uu = utf8_decode($val))) {
+               $val = $uu;
+            }
+            break;
+            
+      // case &quot;real&quot;:  case &quot;float&quot;:   // neither is allowed
+         case &quot;double&quot;:
+            $val = (double)$d;
+            break;
+         case &quot;i4&quot;:
+         case &quot;int&quot;:
+            $val = (int)$d;
+            break;
+
+         case &quot;boolean&quot;:
+            $val = (boolean)$d;
+            break;
+
+         case &quot;dateTime.iso8601&quot;:
+            $val = xmlrpc_strtotime($d);
+            break;
+
+         default:
+            if (defined(&quot;XMLRPC_SERVER&quot;)) {
+               xmlrpc_send_response(xmlrpc_error(-32600, &quot;Unknown data type '$type'&quot;));
+            }
+            else {
+               echo $xmlrpc_error = &quot;UNKNOWN XML-RPC DATA TYPE '$type'&lt;br&gt;\n&quot;;
+               $xmlrpc_errorcode = -32207;
+            }
+#           echo &quot;&lt;!-- UNKNOWN TYPE $type --&gt;\n&quot;;
+#           xmlrpc_log(&quot;bad data type '$type' enountered&quot;);
+      }
+   }
+   return($val);
+}
+
+
+#-- More complex XML-RPC data types need object representation to
+#   distinguish them from ordinary string and integer vars.
+class xmlrpc_xtype {
+   var $scalar = &quot;&quot;;
+   var $xmlrpc_type = &quot;string&quot;;
+   var $tag = &quot;string&quot;;
+   function xmlrpc_type($str) {
+      $this-&gt;data = $str;
+   }
+   function out() {
+      return array($this-&gt;tag.&quot;,0&quot; =&gt; array(&quot;,0&quot;=&gt;$this-&gt;scalar));
+   }
+}
+class xmlrpc_base64 extends xmlrpc_xtype {
+   function xmlrpc_base64($str) {
+      $this-&gt;tag = &quot;base64&quot;;
+      $this-&gt;xmlrpc_type = &quot;base64&quot;;
+      if (XMLRPC_AUTO_UTF8 &gt;= 2) {
+         $str = utf8_encode($str);
+      }
+      if (!preg_match(&quot;/^[=\w\s]+$/&quot;, $str)) {
+         $this-&gt;encode=1;
+      }
+      $this-&gt;scalar = $str;
+   }
+   function out() {
+      if (isset($this-&gt;encode)) {
+         $this-&gt;scalar = chunk_split(base64_encode($this-&gt;scalar), 74, &quot;\n&quot;);
+      }
+      return xmlrpc_xtype::out();
+   }
+}
+class xmlrpc_datetime extends xmlrpc_xtype {
+   function xmlrpc_datetime($t) {
+      $this-&gt;tag = &quot;dateTime.iso8601&quot;;
+      $this-&gt;xmlrpc_type = &quot;datetime&quot;;
+      if (($t &gt; 0) &amp;&amp; ($t[8] != &quot;T&quot;)) {
+         $this-&gt;timestamp = $t;
+         $t = xmlrpc_timetostr($t);
+      }
+      $this-&gt;scalar = $t;
+   }
+}
+
+#-- Further simplify use of the above ones.
+function xmlrpc_base64($string) {
+   return(new xmlrpc_base64($string));
+}
+function xmlrpc_datetime($timestr) {
+   return(new xmlrpc_datetime($timestr));
+}
+
+
+#-- Deciphers ISO datetime string into UNIX timestamp.
+function xmlrpc_strtotime($str) {
+   $tm = explode(&quot;:&quot;, substr($str, 9));
+   $t = mktime($tm[0], $tm[1], $tm[2], substr($str, 4, 2), substr($str, 6, 2), substr($str, 0, 4));
+   return($t);
+}
+function xmlrpc_timetostr($time) {
+   return(gmstrftime(&quot;%Y%m%dT%T&quot;, $time));
+}
+
+
+#-- helping hand for the xmlrpc-epi extension of php
+function xmlrpc_epi_decode_xtypes(&amp;$r) {
+   if (is_object($r) &amp;&amp; isset($r-&gt;xmlrpc_type)) {
+      if (isset($r-&gt;timestamp)) {
+         $r = $r-&gt;timestamp;
+      }
+      else {
+         $r = $r-&gt;scalar;
+      }
+   }
+   elseif (is_array($r)) {
+      foreach ($r as $i=&gt;$v) {
+         xmlrpc_epi_decode_xtypes($r[$i]);
+      }
+   }
+}
+
+
+
+
+############################################################################
+#                                                                          #
+#  simplified XML parser                                                   #
+#                                                                          #
+############################################################################
+
+
+#-- Encode the two chars &amp; and &lt; into htmlentities (there is nothing said
+#   about the possible other entities in the XML-RPC spec).
+function xml_entities($str) {
+   $e = array(
+      &quot;&amp;&quot; =&gt; &quot;&amp;&quot;,
+      &quot;&lt;&quot; =&gt; &quot;&lt;&quot;,
+//      &quot;&gt;&quot; =&gt; &quot;&gt;&quot;,
+   );
+   return(strtr($str, $e));
+}
+function xml_decode_entities($str) {
+   $e = array(
+      &quot;&lt;&quot; =&gt; &quot;&lt;&quot;,
+      &quot;&gt;&quot; =&gt; &quot;&gt;&quot;,
+      &quot;&apos;&quot; =&gt; &quot;'&quot;,
+      &quot;&quot;&quot; =&gt; '&quot;',
+      &quot;&amp;&quot; =&gt; &quot;&amp;&quot;,
+   );
+   if (strpos($e, &quot;&amp;#&quot;) !== false) {
+      $e = preg_replace('/&amp;#(\d+);/e', 'chr($1)', $e);
+      $e = preg_replace('/&amp;#x([\da-fA-F]+);/e', 'chr(hexdec(&quot;$1&quot;))', $e);
+   }
+   return(strtr($str, $e));
+}
+
+
+#-- Can split simplified XML into a PHP array structure. The now used
+#   'compact' format will yield tag sub arrays with an &quot;*,0&quot; index and
+#   just [&quot;,0&quot;] for text nodes.
+function xml2array($xml, $compact=&quot;ALWAYS&quot;) {
+   $r = array();
+   if (function_exists(&quot;xml_parser_create&quot;) &amp;&amp; (strlen($xml) &gt;= 512)) {
+      $r = xml2array_php($xml);
+   }
+   else {
+      xml2array_parse($xml, $r, $compact);
+   }
+   return($r);
+}
+
+
+#-- Recursively builds an array of the chunks fetched via strtok() from
+#   the original XML input string.
+function xml2array_parse(&amp;$string, &amp;$r, $compact=1) {
+   $n = 0;
+   do {
+      #-- split chunks
+      $l = strpos($string, &quot;&lt;&quot;);
+      $p = strpos($string, &quot;&gt;&quot;, $l);
+      $text = $attr=$close = $tag = false;
+      if ($l === false) {
+         $text = $string;
+         $string = false;
+      }
+      else {
+         $tag = strtok(substr($string, $l+1, $p-$l-1), &quot; &quot;);
+         if ((strncmp($tag, &quot;![CDATA[&quot;, 8)==0) &amp;&amp; ($p = strpos($string, &quot;]]&gt;&quot;, $l))) {
+            $text = substr($string, $l+9, $p-$l-9);
+         }
+         else {
+            if ($l) {
+               $text = xml_decode_entities(substr($string, 0, $l));
+            }
+            $attr = strtok(&quot;\000&quot;);
+            $close = $attr &amp;&amp; ($attr[strlen($attr)-1]==&quot;/&quot;);
+            $string = substr($string, $p+1);
+         }
+      }
+      #-- insert text/body content into array
+      if (trim($text)) {
+#         if ($compact) {
+             $r[&quot;,$n&quot;] = $text;
+#         }
+#         else {
+#            $r[] = $text;
+#         }
+         $n++;
+      }
+      #-- recurse for tags
+      if ($tag &amp;&amp; ($tag[0] &gt;= 'A')) {    #-- don't read &lt;? &lt;! &lt;/ pseudo-tags
+#         if ($compact) {
+             $r[&quot;$tag,$n&quot;] = array();
+             $new = &amp;$r[&quot;$tag,$n&quot;];
+#         } else {
+#            $r[] = array($tag =&gt; array());
+#            $new = &amp;$r[count($r)-1][$tag];
+#         }
+         if (!$close) {
+            xml2array_parse($string, $new, $compact);
+         }
+         $n++;
+      }
+      #-- stop if no more tags or content
+      if (empty($tag) &amp;&amp; empty($text) || empty($string)) {
+         $tag = &quot;/&quot;;
+      }
+   } while ($tag[0] != &quot;/&quot;);
+}
+
+
+#-- Uses the XML extension of PHP to convert an XML stream into the
+#   compact array representation.
+function xml2array_php(&amp;$xml, $compact=1) {
+
+   $p = xml_parser_create(xml_which_charset($xml));
+   xml_parser_set_option($p, XML_OPTION_CASE_FOLDING, false);
+   xml_parser_set_option($p, XML_OPTION_TARGET_ENCODING, &quot;ISO-8859-1&quot;);
+
+   xml_parse_into_struct($p, $xml, $struct);
+
+   $a = array();  // will hold all tag nodes
+   $tree = array(&amp;$a);  // stack of pointers to last node of any tree level
+   $in = &amp;$a;           // pointer to last created node
+
+   foreach ($struct as $t) {
+      unset($value);
+      extract($t);
+
+      $depth = count($tree) - 1;
+      $in = &amp;$tree[$depth];
+      $tag .= &quot;,&quot; . count($in);
+//echo &quot;#$depth, TAG=\&quot;$tag\&quot;, TYP=$type, LEV=$level, VAL=$value\n&quot;;
+
+      switch ($type[1]) {
+
+         #--  OpEN
+         case &quot;p&quot;:
+            $in[$tag] = array();
+            if ($type==&quot;open&quot;) {
+               $tree[] = &amp;$in[$tag];
+            }
+            if (isset($value) &amp;&amp; trim($value)) {
+               $in[$tag][&quot;,0&quot;] = $value;
+            }
+            break;
+
+         #--  CoMPLETE
+         case &quot;o&quot;:
+            $in[$tag] = array();
+            if (isset($value) &amp;&amp; trim($value)) {
+               $in[$tag][&quot;,0&quot;] = $value;
+            }
+            break;
+
+         #--  ClOSE
+         case &quot;l&quot;:
+            array_pop($tree);
+            break;
+
+         #--  CdATA - usually just whitespace
+         case &quot;d&quot;:
+            if (isset($value) &amp;&amp; trim($value)) {
+               $in[&quot;,&quot;.count($in)] = $value;
+            }
+            break;
+         
+         default:
+            // case &quot;attribute&quot;:
+            // and anything else we do not want
+      }
+      
+   }
+   
+   return($a);
+}
+
+
+
+function xml_which_charset(&amp;$xml) {
+   return( strpos(strtok($xml, &quot;\n&quot;), '-8859-1&quot;') ? &quot;iso-8859-1&quot; : &quot;utf-8&quot; );
+}
+
+
+
+############################################################################
+#                                                                          #
+#  simplified XML creator                                                  #
+#                                                                          #
+############################################################################
+
+
+#-- This is the opposite of the above xml2array, and can also work with the
+#   so called $compact format.
+function array2xml($r, $compact=1, $ins=&quot;&quot;) {
+   $string = &quot;&lt;?xml version=\&quot;1.0\&quot; $ins?&gt;&quot;;
+   array2xml_push($string, $r, $compact);
+   return($string);
+}
+
+
+#-- Recursively throws out the XMLified tree generated by the xml2array()
+#   'parser' function.
+function array2xml_push(&amp;$string, &amp;$r, $compact, $ind=-1) {
+   $old_ind = ++$ind - 1;
+   if ($old_ind &lt; 0) { $old_ind = 0; }
+   foreach ($r as $i=&gt;$d) {
+      $d = &amp;$r[$i];
+      if (is_scalar($d)) {
+         $string .= xml_entities($d);
+      }
+      elseif (is_array($d)) {
+         if ($compact) {
+            $i = strtok($i, &quot;,&quot;); 
+         }
+         $ls = str_repeat(&quot; &quot;, $ind);
+         $string .= &quot;\n$ls&lt;$i&gt;&quot;;
+         $string .=  array2xml_push($string, $d, $compact, $ind);
+         $ls = str_repeat(&quot; &quot;, $old_ind);
+         $string .= &quot;&lt;/$i&gt;\n$ls&quot;;
+      }
+   }
+}
+
+
+
+
+?&gt;
\ No newline at end of file

Added: YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/contrib/xmlrpc.txt
===================================================================
--- YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/contrib/xmlrpc.txt	2006-12-09 18:08:01 UTC (rev 2249)
+++ YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/contrib/xmlrpc.txt	2006-12-09 18:13:10 UTC (rev 2250)
@@ -0,0 +1,402 @@
+
+XML-RPC is a &quot;standard&quot; (well, not yet exactly) for accessing remotely
+provided 'Web services'. More exactly it is just a complicated encoding
+standard for calling functions and procedures on a remote Web server
+(and getting its calculation or data request results of course).
+
+It is still in wide use for many interesting features like accessing
+database content, searching, data conversion, and so on. It started as
+a lightweight alternative to SOAP, which currently is more on the rise.
+While SOAP is much more bloated, also XML-RPC is not the quickest RPC
+format available, is not really standards-compliant (bogus specs over
+the time), and so has probably only a limited lifetime now.
+Therefore you should try to provide your services and access others`
+via vanilla HTTP requests (form or url encoding), when possible; use
+the &quot;http.php&quot; class for this.
+
+(There is also a faster PHP-RPC standard on the rise, which provides
+type-safe data transport over compressed and fast connections, without
+the encoding overhead and charset issues when using XML-RPC.)
+
+
+
+xmlrpc.php
+&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;
+The 'xmlrpc.php' script implements the XML-RPC spec., but adds a few
+extensions, namely use of the (yet unregistered) &quot;application/rpc+xml&quot;
+MIME type and compressed HTTP transportation. It uses a builtin stupid
+XML parser (for the highly simplified XML-RPC message content) and thus
+is totally independent of any PHP extensions. It of course takes
+advantage of the XML extension where present (a lot faster), and it even
+can make use of Epinions XML-RPC extension for PHP (really fast than).
+
+It is mostly not object-oriented, but extremely easy to use for building
+XML-RPC servers or calling remote procedures.
+
+
+configuration
+&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;
+There are a few constants and variables that the 'xmlrpc.php' script
+respects.
+
+XMLRPC_PLUS
+   If set to 1 enables use of the &quot;application/rpc+xml&quot; MIME type and
+   request compression per default (for server and client). In 2004
+   still not the recommended setting.
+
+XMLRPC_AUTO_TYPES
+   Allows the request encoder to automatically determine the &lt;base64&gt;
+   and &lt;dateTime.iso8061&gt; types, even if you just used them as scalar PHP
+   values. Otherwise you had to use 'new xmlrpc_base64(&quot;STrinG==&quot;)' and
+   'new xmlrpc_datetime(&quot;20001020T00:00:00&quot;)' to prepare such values.
+
+XMLRPC_AUTO_UTF8
+   Takes care of transforming the complete RPC messages into/from UTF-8,
+   what is useful if your scripts deal only with Latin1 and always expect
+   this. &lt;base64&gt; are also de/encoded if you set this constant to 2.
+
+XMLRPC_CHARSET
+   The whole script is currently optimized to produce UTF-8 and decode
+   requests from/into Latin-1 for your scripts.
+
+XMLRPC_FAST
+   Enables use of Epinions XML-RPC extension module for PHP automatically
+   where available. You only want to disable this for debugging purposes.
+
+XMLRPC_OO
+   Engages error result objects, else you had to use the two global vars
+   &quot;$xmlrpc_error&quot; and &quot;$xmlrpc_errorstr&quot; to detect such cases. If you
+   enable it you must however compare all xmlrpc_request() result values
+   against being an object (what does not happen for succeeded XML-RPC
+   requests).
+
+XMLRPC_AUTODISCOVERY
+   If you create a &quot;xmlrpc&quot; or &quot;xmlrpc_connection&quot; object and this is
+   enabled, you would get the object with function names of the
+   automatically instantiated methods of the remotely provided service
+   wrapped into one object (not yet), much like in the Python library
+   for xmlrpc.
+
+XMLRPC_LOG
+   Creates a log file for incoming requests to the _server() part of xmlrpc
+   (whenerver you activate it with the _server() call).
+
+
+There are also a few automatically defined values, which you shouldn't
+care about:
+
+XMLRPC_MIME
+   Contains the currently selected default MIME type for transport.
+XMLRPC_MIME_NEW
+   Contains the newer MIME type value. Do not change.
+XMLRPC_MIME_OLD
+   For compatibility with older XML-RPC clients and servers. Do not change.
+XMLRPC_ACCEPT
+   Again the MIME Types wrapped into a HTTP Accept: header for requests
+   and responses.
+XMLRPC_EPI
+   Tells if the Epinions extension is available.
+
+
+server configuration
+&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;
+$xmlrpc_methods[]
+   Every accessible method (for remote calls) must be defined here, for
+   use with the xmlrpc_server(). There is a separate section on this one.
+
+
+making xmlrpc() requests
+&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;
+You can call a remote procedure by just using the short xmlrpc() call
+syntax:
+
+  $result = xmlrpc(&quot;<A HREF="http://example.com/rpc.php">http://example.com/rpc.php</A>&quot;, &quot;the.function&quot;, 1, 2, 3);
+
+Where 1, 2 and 3 would be parameters to &quot;the.function&quot; on the remote server.
+The number of parameters is not limited, and you do not need to give one at
+all (if the remote procedure does not require them. The parameter values
+are automatically encoded into XML-RPC representations except for &lt;base64&gt;
+and &lt;dateTime.iso8061&gt; ones, for which you needed to create objects first.
+The $result of course recieved in ordinary PHP representation of the remote
+functions result value.
+
+
+       xmlrpc_request()
+       &#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;
+       Is basically the same as calling the xmlrpc() function, but that
+       all parameters given to the remote function are now to be passed
+       as array in the third parameter:
+
+         $params = array(  &quot;param1&quot;, &quot;param2&quot;, &quot;param3&quot;  );
+         $r = xmlrpc_request(&quot;server.com:80&quot;, &quot;remoteMethod&quot;, $params);
+
+       Also a fourth parameter to xmlrpc_request (boolean) says if to
+       use the old XML-RPC or the faster XML+RPC interface. But beware,
+       that this could fail if you connect to an older server.
+
+
+       xmlrpc_connection
+       &#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;
+       You can also establish a 'connection' (this is purely virtual) to
+       a remote XML-RPC server, using a xmlrpc_connection object as follows:
+
+         $xc = new xmlrpc_connection(&quot;<A HREF="http://example.com/rpc.php">http://example.com/rpc.php</A>&quot;);
+
+       Then you could regularily call remote functions on that server:
+
+         $result1 = $xc-&gt;call(&quot;function1&quot;);
+         $result2 = $xc-&gt;call(&quot;function2&quot;, 2, $result1, 0x5F02);
+
+       The xmlrpc_connection automatically chooses XML+RPC if available
+       with the remote server.
+
+
+       data types
+       &#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;
+       Unless XMLRPC_AUTO_TYPES was enabled (discouraged, because this is
+       considered 'unreliable type guessing') you need to explicetely mark
+       parameters passed to the xmlrpc() or xmlrpc_request() calls for
+       their later XML-RPC type.
+
+       To do so, you have the two class types 'xmlrpc_datetime' and
+       'xmlrpc_base64' availabe. Use them as follows:
+
+          $param1 = new xmlrpc_base64(  base64_encode($string1)  );
+          $p2 = new xmlrpc_datetime(  time() + 60*60*24*7  );
+          $r = xmlrpc(&quot;www.server.com/rpc/&quot;, &quot;function1&quot;, $param1, $p2);
+
+       Please note, that you needed to call base64_encode() yourself, and
+       that the _datetime() can also use standard Unix timestamps as input.
+
+       The XML-RPC &lt;dateTime.iso8601&gt; entites are, btw, automatically
+       converted into Unix timestamps, if returned as result from xmlrpc()
+       and xmlrpc_request() calls. This happens regardless of
+       XMLRPC_AUTO_TYPES.
+
+       If XMLRPC_AUTO_TYPES is set to 2, then even &lt;base64&gt; result values
+       would be automatically converted into their plain (binary) string
+       representation.
+
+
+       &quot;Bugs&quot;
+       &#175;&#175;&#175;&#175;&#175;&#175;
+       pass-by-reference is not possible ;)
+
+
+
+xmlrpc_server() use
+&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;
+To make a set of functions available for remote calls, you would create
+an interface script and make its URL public. Assuming that you had a
+subdirectory &quot;./myrpc&quot; on your server, you would likely want to create 
+the file &quot;./myrpc/index.php&quot; with following content:
+
+   &lt;?php
+
+      $xmlrpc_methods = array(
+         &quot;myFunction&quot;,
+         &quot;mySecondOne&quot;,
+      );
+ 
+      include(&quot;xmlrpc.php&quot;);
+      xmlrpc_server();
+   ?&gt;
+
+So, by calling the xmlrpc_server() you make all registered functions
+($xmlrpc_methods) available with the URL &quot;xml+<A HREF="rpc://example.com/myrpc/">rpc://example.com/myrpc/</A>&quot; for
+remote calls.
+
+
+       $xmlrpc_methods[]
+       &#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;
+       All function names you list in this array (before calling the
+       xmlrpc_server() function) will be available for remote calls. The
+       function names are mapped to remote method names by having the
+       _ underscore as alias the the . dot, which is commonly used. So a
+       function whose name was &quot;tools_register&quot; was available as remotely
+       callable method &quot;tools_register&quot; or &quot;tools.register&quot;.
+
+       Also with xmlrpc_server() it is possible to register member methods
+       of object classes as remotely callable methods. All you needed to
+       do is list your class in $xmlrpc_methods[].
+
+       You can also give aliases, both for function names and for object
+       classes:
+
+          $xmlrpc_methods[&quot;callable.methodname&quot;] = &quot;here_function_name&quot;;
+          $xmlrpc_methods[&quot;section&quot;] = &quot;here_class_name&quot;;
+
+       The member methods of a class cannot be aliased however.
+
+
+       xmlrpc_server()
+       &#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;
+       Just fetches the current request, decodes it and executes the
+       destination method (PHP function) if listed in the global
+       $xmlrpc_methods[] variable.
+
+       It automatically exits after sending the response or an error. So
+       this is the last command in your xmlrpc wrapper script.
+
+
+       xmlrpc_fetch_post_chunk()
+       &#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;
+       Begs PHP for the complete POST data stream. It only has two options
+       to do so and may fail with some Webservers and earlier PHP versions.
+       In either case try to set the &quot;always_populate_raw_post_data&quot; option
+       in php.ini or from within a .htaccess file.
+
+       To allow the server part to receive the XML-RPC message, you either
+       need PHP 4.3 or later, or configure your PHP interpreter specifically
+       to pass in the POSTed data stream. In you php.ini ([PHP] section) add:
+
+         always_populate_raw_post_data = 1
+
+       Or following in a .htaccess per-dir configuration
+       file for Apache:
+
+         php_option always_populate_raw_post_data=1
+
+
+       xmlrpc_send_response()
+       &#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;
+       Is called from within xmlrpc_server() to send the response for the
+       processed request (also sends error responses).
+
+
+       xmlrpc_error()
+       &#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;
+       Creates a XML-RPC error result array.
+
+
+
+---------------------------------------------------------------------------
+internals
+---------------------------------------------------------------------------
+Unless you are interrested in an in-deep discussion of the &quot;xmlrpc.php&quot;
+you should effectively stop reading here.
+
+
+xmlrpc data representation encoders
+&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;
+This lib uses the simple xml2array() compact format to do the initial work
+of converting a XML file into an array representation. Various design
+restrictions of the XML-RPC message format then impose certain structures
+inside of the xml2array-compact representation, what is taken adavantage of.
+
+For example &lt;struct&gt; entries have in the compact representation sub-elements
+like [&quot;member,0&quot;], [&quot;member,1&quot;], [&quot;member,2&quot;] and so on. Each of which then
+has two sub elements: [&quot;name,0&quot;] and [&quot;value,1&quot;].
+
+The XML-RPC &lt;array&gt; instead had one [&quot;data,0&quot;] with sub-arrays of
+[&quot;value,0&quot;], [&quot;value,1&quot;], [&quot;value,2&quot;] and so on, which would be recursively
+feed through:
+
+
+      xmlrpc_decode_value()
+      &#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;
+      Makes a PHP representation of a part (one must start it with the
+      content of a [&quot;value,0&quot;]) from a xml2array()-compact representation
+      made out of a XML-RPC message.
+
+
+      xmlrpc_compact_value()
+      &#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;
+      Converts a PHP array or scalar variable into an array suitable for
+      transformation into a XML-RPC message string using the array2xml()
+      function then.
+
+
+
+generic functions
+&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;
+The xml2array() and array2xml() functions are stupid XML parsers and
+probably only suitable for XML-RPC messages.
+
+
+       xml2array()
+       &#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;
+       Can decode a SimplifiedXML document into an array structure - and this
+       in two formats. Internall xml+rpc uses only the so called &quot;$compact
+       format&quot;. If we had a XML document like the following:
+
+       &lt;xml&gt;
+         &lt;more&gt; &lt;string&gt; String &lt;/string&gt;
+         &lt;/more&gt;
+         &lt;more&gt; &lt;string&gt; String2 &lt;/string&gt;
+                &lt;int&gt;5&lt;/int&gt;
+         &lt;/more&gt;
+       &lt;/xml&gt;
+
+       It would return for the $compact=1 format, something like:
+
+       array(
+          &quot;xml,0&quot; =&gt; array(
+             &quot;more,0&quot; =&gt; array(
+                &quot;string,0&quot; = array(
+                   &quot;,0&quot; =&gt; &quot; String &quot;
+                )
+             )
+             &quot;more,1&quot; =&gt; array(
+                &quot;string,0&quot; = array(
+                   &quot;,0&quot; =&gt; &quot; String2 &quot;
+                ),
+                &quot;int,1&quot; = array(
+                   &quot;,0&quot; =&gt; 5
+                )
+             )
+          )
+       );
+
+       Where every tagname had a &quot;,&quot;+NUMBER suffix, and text nodes would
+       start with the comma. The numbers are always counted up in each
+       nesting level from 0, regardless if it counted text or tag nodes.
+
+       The not-compact format would hold another subarray to denote a deeper
+       level tag node, but leave the text nodes as entries into the ordering
+       array level. This was more suitable for XML like files, where you had
+       mixed text and tag nodes in a level. For example:
+
+       &lt;html&gt;
+          string1
+          &lt;b&gt;string2&lt;/b&gt;
+       &lt;/html&gt;
+
+       Would become in the not-compact format:
+
+       array(
+          0 =&gt; array(
+             &quot;html&quot; =&gt; array(
+                0 =&gt; &quot;\n   string1\n   &quot;
+                1 =&gt; array(
+                   &quot;b&quot; =&gt; array(
+                       0 =&gt; &quot;string2&quot;,
+                   )
+             )
+          )
+       )
+
+
+       array2xml()
+       &#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;
+       Regenerates a XML stream from an array structure like the one emitted
+       by xml2array().
+
+
+other functions
+&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;
+If you want a different behaviour, you might want to alter one of
+the following functions.
+
+
+      xmlrpc_method_call()
+      &#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;&#175;
+      Is responsible in the _server() part for invoking the requested
+      function. It does so by using the $xmlrpc_methods[] array as mapping
+      to the PHP functions to activate.
+
+      If you would like to have a better mapping support, or even to add
+      parameter type and number checking, then this is where you would
+      want to start editing the code.
+
+

Added: YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/dtools/_dt
===================================================================
--- YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/dtools/_dt	2006-12-09 18:08:01 UTC (rev 2249)
+++ YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/dtools/_dt	2006-12-09 18:13:10 UTC (rev 2250)
@@ -0,0 +1,8 @@
+#!/bin/sh
+# runs the `doctests` utility for a given (param) function,
+# simply has some custom pathnames built-in
+MAN=/usr/local/doc/php5-doc/
+PHP=php412
+
+DIR=$(dirname $(dirname $(realpath $0)))
+$DIR/dtools/doctests $PHP $MAN $@

Added: YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/dtools/ckavail.php
===================================================================
--- YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/dtools/ckavail.php	2006-12-09 18:08:01 UTC (rev 2249)
+++ YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/dtools/ckavail.php	2006-12-09 18:13:10 UTC (rev 2250)
@@ -0,0 +1,70 @@
+&lt;?php
+/*
+   Run this first with an older PHP interpreter, and then with a newer
+   version. This way you get a list (once) of added functions (the func
+   list is stored in a temporary file).
+*/
+$DATA_FILE = &quot;/tmp/ckavail.lst&quot;;
+
+#-- load previous list
+if ($f = @fopen($DATA_FILE, &quot;rb&quot;)) {
+   $oldl = unserialize(fread($f, 1&lt;&lt;20));
+   fclose($f);
+}
+//echo &quot;OLD=&quot;;print_r($oldl);
+
+#-- current func list
+$newl = get_defined_stuff();
+//echo &quot;NEW=&quot;;print_r($newl);
+
+#-- save this one
+if ($f = fopen($DATA_FILE, &quot;wb&quot;)) {
+   fwrite($f, serialize($newl));
+   fclose($f);
+}
+else {
+   echo &quot;ERROR(could not save current list)\n&quot;;
+}
+
+#-- comparison of  current / last run
+echo &quot;old(&quot;.count($oldl[&quot;functions&quot;]).&quot;), new(&quot;.count($newl[&quot;functions&quot;]).&quot;)\n&quot;;
+if ($oldl) {
+
+   #-- funcs
+   $new = array_diff($newl[&quot;functions&quot;], $oldl[&quot;functions&quot;]);
+   echo &quot;New functions added between PHP $oldl[version] and current $newl[version] interpreter:\n&quot;;
+   print_r($new);
+
+   #-- constants
+   $new = array_diff(array_keys($newl[&quot;constants&quot;]), array_keys($oldl[&quot;constants&quot;]));
+   echo &quot;\nNewly added constants:\n&quot;;
+   print_r($new);
+
+   #-- classes
+   $new = array_diff($newl[&quot;classes&quot;], $oldl[&quot;classes&quot;]);
+   echo &quot;\nAnd classes:\n&quot;;
+   print_r($new);
+
+}
+else {
+   echo &quot;Now start this script a 2nd time with the newer interpreter version.\n&quot;;
+}
+
+
+function get_defined_stuff() {
+   $rl = array();
+   $f = get_defined_functions();
+   while ($f[&quot;internal&quot;]) {
+      $f = $f[&quot;internal&quot;];
+   }
+   $rl[&quot;functions&quot;] = $f;
+   $c = get_defined_constants();
+   $rl[&quot;constants&quot;] = $c;
+   $c = get_declared_classes();
+   $rl[&quot;classes&quot;] = $c;
+   $rl[&quot;version&quot;] = PHP_VERSION;
+   return($rl);
+}
+
+
+?&gt;
\ No newline at end of file

Added: YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/dtools/compact
===================================================================
--- YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/dtools/compact	2006-12-09 18:08:01 UTC (rev 2249)
+++ YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/dtools/compact	2006-12-09 18:13:10 UTC (rev 2250)
@@ -0,0 +1,12 @@
+#!/bin/sh
+
+#
+#  creates comment+whitespace free version of upgrade.php script
+#
+
+cd `dirname $0`
+cd ..
+
+php -q -w upgrade.php | perl -pe 's/\s*([{}()\[\]=\-\/\$&lt;&gt;+*&quot;,;!&amp;|])\s*|\n/$1/gmis;' &gt; contrib/upgrade.php.shortened
+
+ls -l upgrade.php contrib/upgrade.php*

Added: YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/dtools/doctests
===================================================================
--- YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/dtools/doctests	2006-12-09 18:08:01 UTC (rev 2249)
+++ YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/dtools/doctests	2006-12-09 18:13:10 UTC (rev 2250)
@@ -0,0 +1,160 @@
+#!/usr/local/bin/php -qC
+&lt;?php
+/*
+   Makes small test scripts, which get extracted from the PHP manual
+   on the fly (but not every function has one there, suddenly).
+*/
+
+#-- config
+$PAUSE = 1;   // (use 3) break between tests; you should use `|less` instead
+$CLEAN = 0;   // remove test scripts after use
+$MANY = 1;    // create one testing script per function
+
+
+#-- help
+if (count($_SERVER[&quot;argv&quot;]) &lt; 3) {
+   echo&lt;&lt;&lt;END
+
+Usage: doctest  [php-interpreter]  [/path/to/your/php/manual/]
+
+   Runs the examples from your locally installed PHP manual (any language
+   will work, but get the latest!) with the given PHP interpreter version
+   (use an older version to really test the emulated functions). You need
+   lynx or w3m installed also. Use only under U*ix/Linux.
+
+   Pipe the output through |less, |more or |most, there are built-in
+   delays. Rarely example scripts may not run (they are examples only).
+
+END;
+}
+
+#-- proceed
+else {
+
+   #-- args
+   $php = $_SERVER[&quot;argv&quot;][1];
+   $php = trim(`which $php`);
+   if (!$php) {
+      die(__FILE__.&quot;: Given PHP interpreter not in your %PATH!\n&quot;);
+   }
+   $dir = $_SERVER[&quot;argv&quot;][2];
+   if (!is_dir($dir) || !file_exists(&quot;$dir/function.print.html&quot;)) {
+      die(__FILE__.&quot;: PHP manual does not live under '$dir'.\n&quot;);
+   }
+   ($html = `which w3m`) or ($html = `which lynx`);
+   if (!($html = trim($html))) {
+      die(__FILE__.&quot;: lynx or w3m required.\n&quot;);
+   }
+   $tmp = &quot;/tmp/upgrade.php.doctest.tmp&quot;;
+   $tmpdir = $tmp;
+   if ($MANY) { @unlink($tmpdir); @mkdir($tmpdir); }
+
+   #-- load emulation script
+   $emu = realpath(dirname(__FILE__) . &quot;/../upgrade.php&quot;);
+   $emu2 = dirname($emu).&quot;/ext/array.php&quot;;
+   $emu3 = dirname($emu).&quot;/ext/mime.php&quot;;
+   require($emu);
+
+   #-- get function names
+   $text = file_get_contents($emu);
+   preg_match_all(&quot;/function[ ]+([_\w\d]+)\s*\(/&quot;, $text, $uu);
+   $funcs = $uu[1];
+   #-- or use user-specified list
+   if (count($_SERVER[&quot;argv&quot;]) &gt;= 4) {
+      $funcs = array_slice($_SERVER[&quot;argv&quot;], 3);
+   }
+
+   #-- generate list of really emulated functions
+   $simulated = `echo '&lt;?php echo serialize(get_defined_functions()); ?&gt;' | $php -q`;
+   $simulated = unserialize($simulated);
+   $simulated = $simulated[&quot;internal&quot;];
+
+   #-- all
+   foreach ($funcs as $func) {
+      if (file_exists($fn = &quot;$dir/function.&quot;.strtr($func, &quot;_&quot;, &quot;-&quot;).&quot;.html&quot;)) {
+         echo &quot;checking function '\033[31m$func\033[37m'... &quot;;
+
+         #-- only run over emulated stuff
+         if (in_array($func, $simulated)) {
+            echo &quot;NOT EMULATED (with your PHP version)... &quot;;
+            // continue;
+         }
+
+         #-- grep example scripts
+         $text = `$html -dump $fn`;
+         preg_match_all(&quot;/&lt;\?php(.+?)\?&quot;.&quot;&gt;/ms&quot;, $text, $uu);
+
+         #-- exec each
+         if ($n = count($uu[1])) {
+
+            #-- note
+            echo &quot;$n examples:\n\n&quot;;
+
+            #-- multiple scripts to run
+            foreach ($uu[1] as $i=&gt;$scr) {
+
+               #-- fix output-less scripts: find last assigned-to variable name
+               if (!strpos($scr, &quot;echo&quot;) &amp;&amp; !strpos($scr, &quot;print&quot;)) {
+                  if (preg_match('/^.+(\$[_\w\d\[\&quot;\'\]]+)\s*=/s', $scr, $uu)) {
+                     $scr .= &quot;\n\n#-- auto-added\nprint_r($uu[1]);\n&quot;;
+                  }
+                  else {
+                     $scr .= &quot;\n\n#-- this script gives no useful output, or does it?&quot;;
+                  }
+               }
+
+               #-- fix compatibility to older PHP versions
+               $scr = preg_replace('/(\s)private(\s\$)/', '$1var$2', $scr);
+
+               #-- output sample script text from doc
+               if ($i) {
+                  echo &quot;\n++++++++++++++++++++++++++++\n\n&quot;;
+                  sleep($PAUSE);
+               }
+               echo &quot;\033[1;30m&lt;?php $scr\n?&quot;.&quot;&gt;\033[0;37m\n&quot;;
+
+               #-- create temp script, run it
+               if ($MANY) {
+                  $tmp = &quot;$tmpdir/$func#$i.php&quot;;
+               }
+               $scr = ltrim($scr);
+               file_put_contents(
+                  $tmp,
+                  &quot;&lt;?php\n\n&quot;.
+                  &quot;#-- a test script for emulated function '$func'\n&quot;.
+                  &quot;if (function_exists('$func')) { echo \&quot;ATTENTION: the native '$func' function will engage for this test\\n\&quot;; }\n&quot;.
+                  &quot;include('$emu');\n&quot;.
+                  &quot;include('$emu2');\n&quot;.
+                  &quot;include('$emu3');\n&quot;.
+                  &quot;error_reporting(E_ALL);\n\n&quot;.
+                  &quot;#-- example[$i] as taken from PHP manual page '$fn'\n&quot;.
+                  &quot;$scr\n&quot;.
+                  &quot;\n?&quot;.&quot;&gt;&quot;
+               );
+               echo &quot;==&gt;\033[32m\n&quot;;
+               passthru(&quot;$php $tmp&quot;);
+               echo &quot;\033[0;37m\n\n&quot;;
+            }
+
+            #-- pause before next func/script
+            sleep($PAUSE);
+            echo &quot;\n-------------------------------------------------------------------\n\n&quot;;
+         }
+
+         else {
+            echo &quot;NO EXAMPLES found in doc, skipping&quot;;
+         }
+         echo &quot;\n&quot;;
+      }
+   }
+
+   #-- clean up
+   if ($CLEAN) {
+      unlink($tmp);
+   }
+}
+
+#-- even more clean
+if ($MANY &amp;&amp; CLEAN) { @rmdir($tmpdir); }
+
+?&gt;
\ No newline at end of file

Added: YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/dtools/listemu
===================================================================
--- YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/dtools/listemu	2006-12-09 18:08:01 UTC (rev 2249)
+++ YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/dtools/listemu	2006-12-09 18:13:10 UTC (rev 2250)
@@ -0,0 +1,31 @@
+#!/usr/local/bin/php -qC
+&lt;?php
+/*
+   Prints the list of emulated functions.
+*/
+
+#-- basedir
+$dir = realpath(dirname(__FILE__) . &quot;/../&quot;);
+
+#-- grep for function definitions
+$text = &quot;&quot;;
+$text .= implode(&quot;&quot;, file(&quot;$dir/upgrade.php&quot;));
+$text .= implode(&quot;&quot;, file(&quot;$dir/ext/array.php&quot;));
+$text .= implode(&quot;&quot;, file(&quot;$dir/ext/bcmath.php&quot;));
+$text .= implode(&quot;&quot;, file(&quot;$dir/ext/gettext.php&quot;));
+$text .= implode(&quot;&quot;, file(&quot;$dir/ext/mime.php&quot;));
+$text .= implode(&quot;&quot;, file(&quot;$dir/ext/old.php&quot;));
+$text .= implode(&quot;&quot;, file(&quot;$dir/ext/posix.php&quot;));
+$text .= implode(&quot;&quot;, file(&quot;$dir/ext/ctype.php&quot;));
+$text .= implode(&quot;&quot;, file(&quot;$dir/ext/odbc.php&quot;));
+if (preg_match_all(&quot;/function[ ]+([_\w\d]+)\s*\(/&quot;, $text, $uu)) {
+   $list = array_unique($uu[1]);
+}
+
+#-- print
+echo &quot;Following functions can be emulated currently:\n&quot;;
+foreach ($list as $func) {
+   echo &quot;&#183; $func\n&quot;;
+}
+
+?&gt;
\ No newline at end of file

Added: YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/dtools/updoc
===================================================================
--- YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/dtools/updoc	2006-12-09 18:08:01 UTC (rev 2249)
+++ YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/dtools/updoc	2006-12-09 18:13:10 UTC (rev 2250)
@@ -0,0 +1,128 @@
+#!/usr/local/bin/php -qC
+&lt;?php
+/*
+   Adds hints about emulation functions to your local PHP documentation.
+*/
+
+#-- help
+if ($_SERVER[&quot;argc&quot;] &lt; 2) {
+
+   echo&lt;&lt;&lt;END
+
+Usage: updoc [.../upgrade.php] /path/to/your/php-doc/directory/
+ 
+   This script will update your PHP documentation, if you have the
+   (DocBook-converted) multi-html-files version installed. The first
+   parameter must be the filepath to the 'upgrade.php' script, so the
+   names of the emulated functions are known.
+
+   You will afterwards find the abbreviation &quot;EMU&quot; in the required-
+   PHP-version line throughout the documentation, so you know which
+   functions you could safely use from now on (= without backwards
+   compatibility stomachaches).
+
+
+END;
+
+}
+
+#-- run
+else {
+   error_reporting(0);
+
+   #-- params
+   $emu = $_SERVER[&quot;argv&quot;][1];
+   $dir = $_SERVER[&quot;argv&quot;][2];
+   if (!$dir) {
+      $dir = $emu;
+      $emu = dirname(__FILE__).&quot;/../upgrade.php&quot;;
+   }
+   if (!is_dir($dir)) {
+      die(&quot;The given 'PHP doc directory' of \&quot;$dir\&quot; isn't!\n&quot;);
+   }
+   if (!file_exists($emu)) {
+      die(&quot;Couldn't find 'upgrade.php' script under the given name \&quot;$emu\&quot;.\n&quot;);
+   }
+   
+   #-- grep for function definitions
+   $text = implode(&quot;&quot;, file($emu));
+   if (preg_match_all(&quot;/function[ ]+([_\w\d]+)\s*\(/&quot;, $text, $uu)) {
+      $list = $uu[1];
+   }
+   
+   #-- go thru doc
+   if ($list) {
+      $chng = 0;
+      foreach ($list as $func) {
+      
+         #-- doc filename
+         if (file_exists($fn = &quot;$dir/function.&quot;.strtr($func, &quot;_&quot;, &quot;-&quot;).&quot;.html&quot;)) {
+            $f = fopen($fn, &quot;r&quot;);
+            $html = fread($f, 1&lt;&lt;20);
+            fclose($f);
+            
+            #-- update if no hint found yet
+            if (!preg_match('/\(.*?(EMU|UP).*?\)/i', $html)) {
+               $l = strpos($html, &quot;)&quot;); 
+               $html = substr($html, 0, $l)
+                     . &quot;, EMU&quot;
+                     . substr($html, $l);
+               $f = fopen($fn, &quot;w&quot;);
+               fwrite($f, $html);
+               fclose($f);
+               
+               $chng += 1;
+            }
+         }
+      }
+      
+      echo &quot;$chng documentation files updated.\n&quot;;
+   }
+
+   #-- add some special files
+   $add_files = array(
+      array(
+         &quot;func&quot;=&gt;&quot;gzdecode&quot;,
+         &quot;data&quot;=&gt;&quot;PGh0bWw+PGhlYWQ+PHRpdGxlPmd6ZGVjb2RlPC90aXRsZT48L2hlYWQ+Cjxib2R5Pgo8ZGl2IGFsaWduPSJjZW50ZXIiPnVwZ3JhZGUucGhwIGRvYzwvZGl2Pgo8dGFibGUgYm9yZGVyPSIwIiB3aWR0aD0iMTAwJSIgY2VsbHBhZGRpbmc9IjAiIGNlbGxzcGFjaW5nPSIwIj48dHI+CiAgPHRkIGFsaWduPSJsZWZ0Ij48YSBocmVmPSJmdW5jdGlvbi5nemRlZmxhdGUuaHRtbCI+YmFjazwvYT48L3RkPgogIDx0ZCBhbGlnbj0icmlnaHQiPjxhIGhyZWY9ImZ1bmN0aW9uLmd6ZW5jb2RlLmh0bWwiPm5leHQ8L2E+PC90ZD4KPC90cj48L3RhYmxlPgo8aHIgYWxpZ249IkxFRlQiIHdpZHRoPSIxMDAlIj4KCjxoMT5nemRlY29kZTwvaDE+Cgo8cD4oUEhQIDYsIEVNVSk8L3A+CgpnemRlY29kZSZuYnNwOy0tJm5ic3A7RGVjb2RlcyBhIGd6aXAgY29tcHJlc3NlZCBzdHJpbmc8L2Rpdj4KCjxoMj5EZXNjcmlwdGlvbjwvaDI+CgpzdHJpbmcgPGIgY2xhc3M9Im1ldGhvZG5hbWUiPmd6ZGVjb2RlPC9iPiAoIHN0cmluZyBkYXRhIFssIGludCBtYXhsZW5dKTxicj4KPGJyPgo8cD5UaGlzIGZ1bmN0aW9uIGRlY29kZXMgYSBzdHJpbmcgY29tcHJlc3NlZCBieSB0aGUgCjxhIGhyZWY9ImZpbGU6Ly8vdXNyL3NoYXJlL21hbi9tYW4xL2d6aXAuMS5neiI+Z3ppcCgxKTwvYT4gdXRpbGl0eSBvcgp0aGUgPGEgY2xhc3M9ImZ1bmN0aW9uIiBocmVmPSJmdW5jdGlvbi5nemVuY29kZS5odG1sIj5nemVuY2!
 9kZSgpPC9hPgpmdW5jdGlvbi4gVGhlIG9wdGlvbmFsIHBhcmFtZXRlciAnbWF4bGVuJyBsaW1pdHMgdGhlIGxlbmd0aCBvZiB0aGUgcmV0dXJuZWQKc3RyaW5nIC0gaWYgdGhlIGluZmxhdGlvbiBwcm9jZXNzIHJldHVybmVkIGEgYmlnZ2VyIHJlc3VsdCBpdCB3b3VsZCBiZSBkcm9wcGVkLgo8L3A+Cgo8cD5UaGUgZ3ppcCBmb3JtYXQgaW50ZXJuYWxseSB1c2VzIHRoZSBkZWZsYXRlIGFsZ29yaXRobSwgYW5kIGFkZHMgYSBmZXcKY2hlY2tzdW1zIGFuZCBvcHRpb25hbCBtZXRhIGRhdGEgZmllbGRzLiBJdCBpcyByZWd1bGFyaWx5IHVzZWQgYXMKY29udGVudC1jb2RpbmcgaW4gSFRUUCByZXF1ZXN0cyBhbmQgcmVzcG9uc2VzLiBTZWUKPGEgaHJlZj0iaHR0cDovL3d3dy5mYXFzLm9yZy9yZmNzL3JmYzE5NTIiPlJGQzE5NTI8L2E+IGZvciB0aGUgZm9ybWF0CmRlc2NyaXB0aW9uLjwvcD4KCjxwPgpTZWUgYWxzbyA8YSBocmVmPSJmdW5jdGlvbi5nemVuY29kZS5odG1sIj48YiBjbGFzcz0iZnVuY3Rpb24iPmd6ZW5jb2RlKCk8L2I+PC9hPgphbmQgPGEgaHJlZj0iZnVuY3Rpb24uZ3ppbmZsYXRlLmh0bWwiPjxiIGNsYXNzPSJmdW5jdGlvbiI+Z3ppbmZsYXRlKCk8L2I+PC9hPi4KPC9wPgoKPHA+Rm9yIGNvbXBhdGliaWxpdHkgd2l0aCBvbGRlciBQSFAgdmVyc2lvbnMgKGFuZCBmb3IgcGVvcGxlIHRoYXQgYXJlCnVud2lsbGluZyB0byBsb2FkICd1cGdyYWRlLnBocCcpLCB5b3UgY2FuIHVzZSBmb2xsb3!
 dpbmcgKHVuY2xlYW4pCndvcmthcm91bmQgZm9yIGRlY29tcHJlc3NpbmcgZ3pp!
 cGVkIGRh
dGE6PGJyPgo8YnI+CjxiPkV4YW1wbGUgMTwvYj46PGJyPgo8YnI+Cjxjb2RlPgombmJzcDsgICRnemRhdGEgPSBnemVuY29kZSgiSSdtIGdldHRpbmcgY29tcHJlc3NlZC4uLiIpOzxicj4KPGJyPgombmJzcDsgICRzdHIgPSBmdW5jdGlvbl9leGlzdHMoImd6ZGVjb2RlIik8YnI+CiZuYnNwOyAmbmJzcDsgJm5ic3A7ICA/IGd6ZGVjb2RlKCRnemRhdGEpPGJyPgombmJzcDsgJm5ic3A7ICZuYnNwOyAgOiBnemluZmxhdGUoc3Vic3RyKCRnemRhdGEsIDEwLCAtOCkpOzxicj4KPGJyPgo8L2NvZGU+CjwvcD4KCjxocj4KPHRhYmxlIGJvcmRlcj0iMCIgd2lkdGg9IjEwMCUiIGNlbGxwYWRkaW5nPSIwIiBjZWxsc3BhY2luZz0iMCI+PHRyPgogIDx0ZCB3aWR0aD0iMzMlIiBhbGlnbj0ibGVmdCI+PGEgaHJlZj0iZnVuY3Rpb24uZ3pkZWZsYXRlLmh0bWwiPmJhY2s8L2E+PGJyPmd6ZGVmbGF0ZTwvdGQ+CiAgPHRkIHdpZHRoPSIzMyUiIGFsaWduPSJjZW50ZXIiPjxhIGhyZWY9InJlZi56bGliLmh0bWwiPnVwPC9hPjxicj56bGliIG92ZXJ2aWV3PC90ZD4KICA8dGQgd2lkdGg9IjMzJSIgYWxpZ249InJpZ2h0Ij48YSBocmVmPSJmdW5jdGlvbi5nemVuY29kZS5odG1sIj5uZXh0PC9hPjxicj5nemVuY29kZTwvdGQ+CjwvdHI+PC90YWJsZT4KCjwvYm9keT4KPC9odG1sPgo=&quot;,
+         &quot;sect&quot;=&gt;&quot;zlib&quot;, &quot;after&quot;=&gt;&quot;gzencode&quot;,
+         &quot;desc&quot;=&gt;&quot;Decode a gzip compressed string&quot;,
+      ),
+   );
+   foreach ($add_files as $data) {
+      extract($data);
+      if (!file_exists($fn = &quot;$dir/function.$func.html&quot;)
+||1) {
+         echo &quot;adding \&quot;$fn\&quot;\n&quot;;
+         $f = fopen($fn, &quot;w&quot;);
+         fwrite($f, base64_decode($data));
+         fclose($f);
+
+         #-- update function list page
+         $fn = array(&quot;$dir/ref.$sect.html&quot;, &quot;$dir/index.functions.html&quot;);
+         update_files($fn, &quot;/(&lt;a\s+href=\&quot;function.$after)/ims&quot;,
+            &quot;&lt;a href=\&quot;function.$func.html\&quot;&gt;$func&lt;/a&gt; -- $desc.&lt;/dt&gt;\n&lt;dt&gt; $1&quot;
+         ); 
+      }
+   }
+
+}
+
+
+#-- inject something into a file
+function update_files($list, $regex, $replace) {
+   if (!is_array($list)) {
+      $list = array($list);
+   }
+   foreach ($list as $fn) {
+echo &quot;+$fn\n&quot;;
+      $f = fopen($fn, &quot;r&quot;);
+      $html = fread($f, 1&lt;&lt;20);
+      fclose($f);
+      $html = preg_replace($regex, $replace, $html);
+      $f = fopen($fn, &quot;w&quot;);
+      fwrite($f, $html);
+      fclose($f);
+   }
+}
+
+?&gt;
\ No newline at end of file

Added: YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/ext/array.php
===================================================================
--- YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/ext/array.php	2006-12-09 18:08:01 UTC (rev 2249)
+++ YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/ext/array.php	2006-12-09 18:13:10 UTC (rev 2250)
@@ -0,0 +1,266 @@
+&lt;?php
+/*
+   Extended PHP array functions - _diff and _intersect() for associative
+   arrays and/or with callback functions (for keys and/or values). These
+   are too rarely used and exotic to be part of the core &quot;upgrade.php&quot;
+   script.
+   
+   NOTHING IN HERE WAS SERIOUSLY TESTED. Please grab the definitions from
+   &quot;PEAR::PHP_Compat&quot; if you want reliable and tested versions.
+*/
+
+
+#-- diff associative arrays with two user callbacks
+#   (if this looks complicated to you, don't even try to look at the manual)
+if (!function_exists(&quot;array_udiff_uassoc&quot;)) {
+   function array_udiff_uassoc() {
+      $in = func_get_args();
+      $key_cb = array_pop($in);
+      $val_cb = array_pop($in);
+      $arr1 = array_shift($in);
+      $r = array();
+      
+      foreach ($arr1 as $i=&gt;$v) {
+         #-- in each array, compare against each key/value pair
+         foreach (array_keys($in) as $c) {
+            foreach ($in[$c] as $i2=&gt;$v2) {
+               
+               $key_cmp = call_user_func_array($key_cb, array($i, $i2));
+               if ($key_cmp == 0) {
+
+                  #-- ok, in this case we must compare the data as well
+                  $val_cmp = call_user_func_array($val_cb, array($v, $v2));
+                  if ($val_cmp == 0) {
+                     continue 3;
+                  }
+               }
+            }
+         }
+
+         #-- this combination isn't really found anywhere else
+         $r[$i] = $v;
+      }
+      return($r);
+   }
+}
+
+
+#-- same, but that keys now are compared normally (without callback)
+if (!function_exists(&quot;array_udiff_assoc&quot;)) {
+   function array_udiff_assoc() {
+      $in = func_get_args();
+      $val_cb = array_pop($in);
+      $arr1 = array_shift($in);
+      $r = array();
+      
+      #-- compare against each key/value pair in other arrays
+      foreach ($arr1 as $i=&gt;$v) {
+         foreach (array_keys($in) as $c) {
+            if (isset($in[$c][$i])) {
+               #-- now compare data by callback
+               $cmp = call_user_func_array($val_cb, array($v, $in[$c][$i]));
+               if ($cmp == 0) {
+                   continue 2;
+               }
+            }
+         }
+         #-- everything exists only in array1
+         $r[$i] = $v;
+      }
+      return($r);
+   }
+}
+
+
+#-- ....
+if (!function_exists(&quot;array_diff_uassoc&quot;)) {
+   function array_diff_uassoc() {
+      $in = func_get_args();
+      $key_cb = array_pop($in);
+      $arr1 = array_shift($in);
+      $num = count($in);
+      $r = array();
+      
+      foreach ($arr1 as $i=&gt;$v) {
+         #-- in other arrays?
+         for ($c=0; $c&lt;$num; $c++) {
+            foreach ($in[$c] as $i2=&gt;$v2) {
+               if ($v == $v2) {
+                  $cmp = call_user_func_array($key_cb, array($i, $i2));
+                  if ($cmp == 0) {
+                     continue 3;
+                  }
+               }
+            }
+         }
+         #-- exists only in array1
+         $r[$i] = $v;
+      }
+      return($r);
+   }
+}
+
+
+#-- diff array, keys ignored, callback for comparing values
+if (!function_exists(&quot;array_udiff&quot;)) {
+   function array_udiff() {
+      $in = func_get_args();
+      $val_cb = array_pop($in);
+      $arr1 = array_shift($in);
+      $num = count($in);
+      $r = array();
+      foreach ($arr1 as $i=&gt;$v) {
+         #-- check other arrays
+         for ($c=0; $c&lt;$num; $c++) {
+            foreach ($in[$c] as $v2) {
+               $cmp = call_user_func_array($val_cb, array($v, $v2));
+               if ($cmp == 0) {
+                  continue 3;
+               }
+            }
+         }
+         #-- exists only in array1
+         $r[$i] = $v;
+      }
+      return($r);
+   }
+}
+
+
+
+
+
+
+
+
+
+
+
+
+#-- same for intersections
+if (!function_exists(&quot;array_uintersect_uassoc&quot;)) {
+   function array_uintersect_uassoc() {
+      $in = func_get_args();
+      $key_cb = array_pop($in);
+      $val_cb = array_pop($in);
+      $all = array();
+      $conc = count($in);
+      foreach ($in[0] as $i=&gt;$v) {
+         #-- must exist in each array (at least once, callbacks may match fuzzy)
+         for ($c=1; $c&lt;$conc; $c++) {
+            $ok = false;
+            foreach ($in[$c] as $i2=&gt;$v2) {
+               $key_cmp = call_user_func_array($key_cb, array($i, $i2));
+               $val_cmp = call_user_func_array($val_cb, array($v, $v2));
+               if (($key_cmp == 0) &amp;&amp; ($val_cmp == 0)) {
+                  $ok = true;
+                  break;
+               }
+            }
+            if (!$ok) {
+               continue 2;
+            }
+         }
+         #-- exists in all arrays
+         $all[$i] = $v;
+      }
+      return($all);
+   }
+}
+
+
+
+
+#-- intersection again
+if (!function_exists(&quot;array_uintersect_assoc&quot;)) {
+   function array_uintersect_assoc() {
+      $in = func_get_args();
+      $val_cb = array_pop($in);
+      $all = array();
+      $conc = count($in);
+      foreach ($in[0] as $i=&gt;$v) {
+         #-- test for that entry in any other array
+         for ($c=1; $c&lt;$conc; $c++) {
+            if (isset($in[$c][$i])) {
+               $cmp = call_user_func_array($val_cb, array($v, $in[$c][$i]));
+               if ($cmp == 0) { continue; }
+            }
+            #-- failed
+            continue 2;
+         }
+         #-- exists in all arrays
+         # (but for fuzzy matching: only the first entry will be returned here)
+         $all[$i] = $v;
+      }
+      return($all);
+   }
+}
+
+
+
+
+
+#-- array intersection, no keys compared, but callback for values
+if (!function_exists(&quot;array_uintersect&quot;)) {
+   function array_uintersect() {
+      $in = func_get_args();
+      $val_cb = array_pop($in);
+      $arr1 = array_shift($in);
+      $num = count($in);
+      $r = array();
+
+      foreach ($arr1 as $i=&gt;$v) {
+         #-- must have equivalent value in all other arrays
+         for ($c=0; $c&lt;$num; $c++) {
+            foreach ($in[$c] as $i2=&gt;$v2) {
+               $cmp = call_user_func_array($val_cb, array($v, $v2));
+               if ($cmp == 0) {
+                  continue 2; //found
+               }
+            }
+            continue 2; //failed
+         }
+         #-- everywhere
+         $r[$i] = $v;
+      }
+      return($r);
+   }
+}
+
+
+
+
+#-- diff array, keys ignored, callback for comparing values
+if (!function_exists(&quot;array_intersect_uassoc&quot;)) {
+   function array_intersect_uassoc() {
+      $args = func_get_args();
+      $key_cb = array_pop($args);
+      $array1 = array_shift($args);
+      $num = count($args);
+      $all = array();
+      foreach ($array1 as $i=&gt;$v) {
+         #-- look through other arrays
+         for ($c=0; $c&lt;$num; $c++) {
+            $ok = 0;
+            foreach ($args[$c] as $i2=&gt;$v2) {
+               $cmp = call_user_func_array($key_cb, array($i, $i2));
+               if (($cmp == 0) &amp;&amp; ($v == $v2)) {
+                  $ok = 1;
+                  continue 2;
+               }
+            }
+            if (!$ok) { 
+               continue 2;
+            }
+         }
+         #-- found in all arrays
+         if ($ok) {
+            $diff[$i] = $v;
+         }
+      }
+      return($diff);
+   }
+}
+
+
+?&gt;
\ No newline at end of file

Added: YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/ext/base64.php
===================================================================
--- YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/ext/base64.php	2006-12-09 18:08:01 UTC (rev 2249)
+++ YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/ext/base64.php	2006-12-09 18:13:10 UTC (rev 2250)
@@ -0,0 +1,39 @@
+&lt;?php
+/*
+   This script implements the base64-encoding functions and base32 and
+   base16 as described in RFC3548.
+*/
+if (!function_exists(&quot;base16_encode&quot;)) {
+
+
+   #-- URL and filename safe variants of base64-encoding
+   function base64_encode_safe($str) {
+      return strtr(base64_encode($str), &quot;+/&quot;, &quot;-_&quot;);
+   }
+   function base64_decode_safe($b64) {
+      return base64_decode(strtr($str, &quot;-_&quot;, &quot;+/&quot;));
+   }
+
+
+   #-- base16
+   function base16_encode($str) {
+      $str = unpack(&quot;H&quot;.(2*strlen($str)), $str);
+      $str = chunk_split($str[1]);
+      return($str);
+   }
+   function base16_decode($b16) {
+      $b16 = preg_replace(&quot;/\s+/&quot;, '', $b16);
+      $b16 = pack(&quot;H*&quot;, $b16);
+      return($b16);
+   }
+
+
+   #-- base32
+   function base32_encode() {
+      
+      # strtoupper()
+      # &quot;A-Z,0-7,=&quot;
+   }
+
+}
+?&gt;
\ No newline at end of file

Added: YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/ext/bcmath.php
===================================================================
--- YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/ext/bcmath.php	2006-12-09 18:08:01 UTC (rev 2249)
+++ YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/ext/bcmath.php	2006-12-09 18:13:10 UTC (rev 2250)
@@ -0,0 +1,164 @@
+&lt;?php
+/*
+   Emulates mathematical functions with arbitrary precision (bcmath)
+   using POSIX systems 'dc' utility or either GMP or PHPs bigint
+   extension module as fallback (were faster, but wouldn't allow to
+   set precisions).
+*/
+
+
+#-- BSD/Linux dc(1)
+if (!function_exists(&quot;bcadd&quot;) &amp;&amp; is_executable(&quot;/usr/bin/dc&quot;)) {
+
+   #-- invokes commandline 'dc' utility (faster than with 'bc')
+   #   (later version should use proc_open() for safer and faster bi-directional I/O)
+   function dc___exec($calc, $scale=NULL) {
+      global $bc___scale;
+
+      #-- assemble dc expression
+      $calc = str_replace(' -', ' _', $calc);  // convert minus signs for dc
+      if (isset($scale) || ($scale = $bc___scale)) {
+         $calc = ((int)$scale) . &quot;k&quot; . $calc;  // inject precision directive
+      }
+      $calc = escapeshellarg($calc);   // could be non-integer from elsewhere
+      
+      #-- prevent any command execution from within dc
+      # (for speed reasons we don't assert parameters to be fully numeric)
+      if (strpos($calc, &quot;!&quot;)) { return; }
+
+      #-- do
+      return str_replace(&quot;\\\n&quot;, &quot;&quot;, `/usr/bin/dc -e $calc`);
+   }
+
+   #-- global state variable
+   $GLOBALS[&quot;bc___scale&quot;] = 0;  //ini_get(&quot;bcmath.scale&quot;);  // =0
+   function bcscale($scale=NULL) {
+      $GLOBALS[&quot;bc___scale&quot;] = $scale;
+   }
+
+   #-- wrapper calls
+   function bcadd($a, $b, $scale=NULL) {
+      return dc___exec(&quot; $a $b +nq&quot;, $scale);
+   }
+   function bcsub($a, $b, $scale=NULL) {
+      return dc___exec(&quot; $a $b-nq&quot;, $scale);  // no space before '-' cmd!
+   }
+   function bcmul($a, $b, $scale=NULL) {
+      return dc___exec(&quot; $a $b *nq&quot;, $scale);
+   }
+   function bcdiv($a, $b, $scale=NULL) {
+      return dc___exec(&quot; $a $b /nq&quot;, $scale);
+   }
+   function bcmod($a, $b, $scale=0) {
+      return dc___exec(&quot; $a $b %nq&quot;, $scale);
+   }
+   function bcpow($a, $b, $scale=NULL) {
+      return dc___exec(&quot; $a $b ^nq&quot;, $scale);
+   }
+   function bcpowmod($x, $y, $mod, $scale=0) {
+      return dc___exec(&quot; $x $y $mod |nq&quot;, $scale);  // bc(1) wouldn't work
+   }
+   function bcsqrt($x, $scale=NULL) {
+      return dc___exec(&quot; $x vnq&quot;, $scale);
+   }
+
+   #-- looks slightly more complicated in dc notation
+   function bccomp($a, $b, $scale=NULL) {
+      bc___scaledown($a, $scale);
+      bc___scaledown($b, $scale);
+      return (int) dc_exec(&quot; $a 1*sA $b 1*sB  lBlA[1nq]sX&gt;X lBlA[_1nq]sX&lt;X 0nq&quot;, $scale);
+   }
+   function bc___scaledown(&amp;$a, $scale) {
+      if (isset($scale) &amp;&amp; ($dot = strpos($a, $dot))) {
+         $a = substr($a, $dot + $scale) . &quot;0&quot;;
+      }
+   }
+
+}//shell version
+
+
+
+#-- GMP
+if (!function_exists(&quot;bcadd&quot;) &amp;&amp; function_exists(&quot;gmp_strval&quot;)) {
+   function bcadd($a, $b) {
+      return gmp_strval(gmp_add($a, $b));
+   }
+   function bcsub($a, $b) {
+      return gmp_strval(gmp_sub($a, $b));
+   }
+   function bcmul($a, $b) {
+      return gmp_strval(gmp_mul($a, $b));
+   }
+   function bcdiv($a, $b, $precision=NULL) {
+      $qr = gmp_div_qr($a, $b);
+      $q = gmp_strval($qr[0]);
+      $r = gmp_strval($qr[1]);
+      if ((!$r) || ($precision===0)) {
+         return($q);
+      }
+      else {
+         if (isset($precision)) {
+            $r = substr($r, 0, $precision);
+         }
+         return(&quot;$q.$r&quot;);
+      }
+   }
+   function bcmod($a, $b) {
+      return gmp_strval(gmp_mod($a, $b));
+   }
+   function bcpow($a, $b) {
+      return gmp_strval(gmp_pow($a, $b));
+   }
+   function bcpowmod($x, $y, $mod) {
+      return gmp_strval(gmp_powm($x, $y, $mod));
+   }
+   function bcsqrt($x) {
+      return gmp_strval(gmp_sqrt($x));
+   }
+   function bccomp($a, $b) {
+      return gmp_cmp($a, $b);
+   }
+   function bcscale($scale=&quot;IGNORED&quot;) {
+      trigger_error(&quot;bcscale(): ignored&quot;, E_USER_ERROR);
+   }
+}//gmp emulation
+
+
+
+#-- bigint
+// @dl(&quot;php_big_int&quot;.PHP_SHLIB_SUFFIX))
+if (!function_exists(&quot;bcadd&quot;) &amp;&amp; function_exists(&quot;bi_serialize&quot;)) {
+   function bcadd($a, $b) {
+      return bi_to_str(bi_add($a, $b));
+   }
+   function bcsub($a, $b) {
+      return bi_to_str(bi_sub($a, $b));
+   }
+   function bcmul($a, $b) {
+      return bi_to_str(bi_mul($a, $b));
+   }
+   function bcdiv($a, $b) {
+      return bi_to_str(bi_div($a, $b));
+   }
+   function bcmod($a, $b) {
+      return bi_to_str(bi_mod($a, $b));
+   }
+   function bcpow($a, $b) {
+      return bi_to_str(bi_pow($a, $b));
+   }
+   function bcpowmod($a, $b, $c) {
+      return bi_to_str(bi_powmod($a, $b, $c));
+   }
+   function bcsqrt($a) {
+      return bi_to_str(bi_sqrt($a));
+   }
+   function bccomp($a, $b) {
+      return bi_cmp($a, $b);
+   }
+   function bcscale($scale=&quot;IGNORED&quot;) {
+      trigger_error(&quot;bcscale(): ignored&quot;, E_USER_ERROR);
+   }
+}
+
+
+?&gt;
\ No newline at end of file

Added: YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/ext/ctype.php
===================================================================
--- YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/ext/ctype.php	2006-12-09 18:08:01 UTC (rev 2249)
+++ YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/ext/ctype.php	2006-12-09 18:13:10 UTC (rev 2250)
@@ -0,0 +1,210 @@
+&lt;?php
+/*
+   These functions emulate the &quot;character type&quot; extension, which is
+   present in PHP first since version 4.3 per default. In this variant
+   only ASCII and Latin-1 characters are being handled. The first part
+   is eventually faster.
+*/
+
+
+#-- regex variants
+if (!function_exists(&quot;ctype_alnum&quot;)) {
+   function ctype_alnum($text) {
+      return preg_match(&quot;/^[A-Za-z\d\300-\377]+$/&quot;, $text);
+   }
+   function ctype_alpha($text) {
+      return preg_match(&quot;/^[a-zA-Z\300-\377]+$/&quot;, $text);
+   }
+   function ctype_digit($text) {
+      return preg_match(&quot;/^\d+$/&quot;, $text);
+   }
+   function ctype_xdigit($text) {
+      return preg_match(&quot;/^[a-fA-F0-9]+$/&quot;, $text);
+   }
+   function ctype_cntrl($text) {
+      return preg_match(&quot;/^[\000-\037]+$/&quot;, $text);
+   }
+   function ctype_space($text) {
+      return preg_match(&quot;/^\s+$/&quot;, $text);
+   }
+   function ctype_upper($text) {
+      return preg_match(&quot;/^[A-Z\300-\337]+$/&quot;, $text);
+   }
+   function ctype_lower($text) {
+      return preg_match(&quot;/^[a-z\340-\377]+$/&quot;, $text);
+   }
+   function ctype_graph($text) {
+      return preg_match(&quot;/^[\041-\176\241-\377]+$/&quot;, $text);
+   }
+   function ctype_punct($text) {
+      return preg_match(&quot;/^[^0-9A-Za-z\000-\040\177-\240\300-\377]+$/&quot;, $text);
+   }
+   function ctype_print($text) {
+      return ctype_punct($text) &amp;&amp; ctype_graph($text);
+   }
+
+}
+
+
+/***&lt;old&gt;
+
+#-- simple char-by-char comparisions
+if (!function_exists(&quot;ctype_alnum&quot;)) {
+
+
+   #-- true if string is made of letters and digits only
+   function ctype_alnum($text) {
+      $r = true;
+      for ($i=0; $i&lt;strlen($text); $i++) {
+         $c = ord($text{$i});
+         $r = $r and (
+                ($c&gt;=65) &amp;&amp; ($c&lt;=90)    // A-Z
+             or ($c&gt;=97) &amp;&amp; ($c&lt;=122)   // a-z
+             or ($c&gt;=48) &amp;&amp; ($c&lt;=59)    // 0-9
+             or ($c&gt;=192)          // Latin-1 letters
+         );
+      }
+      return($r);
+   }
+
+
+   #-- only letters in given string
+   function ctype_alpha($text) {
+      $r = true;
+      for ($i=0; $i&lt;strlen($text); $i++) {
+         $c = ord($text{$i});
+         $r = $r and (
+                ($c&gt;=65) &amp;&amp; ($c&lt;=90)    // A-Z
+             or ($c&gt;=97) &amp;&amp; ($c&lt;=122)   // a-z
+             or ($c&gt;=192)          // Latin-1 letters
+         );
+      }
+      return($r);
+   }
+
+
+   #-- only numbers in string
+   function ctype_digit($text) {
+      $r = true;
+      for ($i=0; $i&lt;strlen($text); $i++) {
+         $c = ord($text{$i});
+         $r = $r and ($c&gt;=48) &amp;&amp; ($c&lt;=59);   // 0-9
+      }
+      return($r);
+   }
+
+
+   #-- hexadecimal numbers only
+   function ctype_xdigit($text) {
+      $r = true;
+      for ($i=0; $i&lt;strlen($text); $i++) {
+         $c = ord($text{$i});
+         $r = $r and (
+                ($c&gt;=48) &amp;&amp; ($c&lt;=59)    // 0-9
+             or ($c&gt;=65) &amp;&amp; ($c&lt;=70)    // A-F
+             or ($c&gt;=97) &amp;&amp; ($c&lt;=102)   // a-f
+         );
+      }
+      return($r);
+   }
+
+
+   #-- hexadecimal numbers only
+   function ctype_cntrl($text) {
+      $r = true;
+      for ($i=0; $i&lt;strlen($text); $i++) {
+         $c = ord($text{$i});
+         $r = $r and ($c &lt; 32);
+      }
+      return($r);
+   }
+
+
+   #-- hexadecimal numbers only
+   function ctype_space($text) {
+      $r = true;
+      for ($i=0; $i&lt;strlen($text); $i++) {
+         $c = $text{$i};
+         $r = $r and (
+              ($c == &quot; &quot;) or ($c == &quot;\240&quot;)
+           or ($c == &quot;\n&quot;) or ($c == &quot;\r&quot;)
+           or ($c == &quot;\t&quot;) or ($c == &quot;\f&quot;)
+         );
+      }
+      return($r);
+   }
+
+
+   #-- all-uppercase
+   function ctype_upper($text) {
+      $r = true;
+      for ($i=0; $i&lt;strlen($text); $i++) {
+         $c = ord($text{$i});
+         $r = $r and (
+                ($c&gt;=65) &amp;&amp; ($c&lt;=90)    // A-Z
+             or ($c&gt;=192) &amp;&amp; ($c&lt;=223)  // Latin-1 letters
+         );
+      }
+      return($r);
+   }
+
+
+   #-- all-lowercase
+   function ctype_lower($text) {
+      $r = true;
+      for ($i=0; $i&lt;strlen($text); $i++) {
+         $c = ord($text{$i});
+         $r = $r and (
+                ($c&gt;=97) &amp;&amp; ($c&lt;=122)   // a-z
+             or ($c&gt;=224) &amp;&amp; ($c&lt;=255)  // Latin-1 letters
+         );
+      }
+      return($r);
+   }
+
+
+   #-- everything except spaces that produces a valid printable output
+   #   (this probably excludes contral chars as well)
+   function ctype_graph($text) {
+      $r = true;
+      for ($i=0; $i&lt;strlen($text); $i++) {
+         $c = ord($text{$i});
+         $r = $r
+           and ($c&gt;=33)
+           and ($c!=160)
+           and (($c&lt;=126) or ($c&gt;=161));
+      }
+      return($r);
+   }
+
+
+   #-- everything printable, but no spaces+letters+digits
+   function ctype_punct($text) {
+      $r = true;
+      for ($i=0; $i&lt;strlen($text); $i++) {
+         $c = ord($text{$i});
+         $r = $r and (
+                ($c&gt;=33) &amp;&amp; ($c&lt;=47)   // !../
+             or ($c&gt;=58) &amp;&amp; ($c&lt;=64)   // :..@
+             or ($c&gt;=91) &amp;&amp; ($c&lt;=96)   // [..`
+             or ($c&gt;=123) &amp;&amp; ($c&lt;=126) // {..~
+             or ($c&gt;=161) &amp;&amp; ($c&lt;=191) // Latin-1 everything else
+         );
+      }
+      return($r);
+   }
+
+
+
+//   - no idea what this means exactly
+//
+//   function ctype_print($text) {
+//   }
+
+
+}
+
+
+&lt;/old&gt;***/
+
+?&gt;
\ No newline at end of file

Added: YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/ext/dba.php
===================================================================
--- YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/ext/dba.php	2006-12-09 18:08:01 UTC (rev 2249)
+++ YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/ext/dba.php	2006-12-09 18:13:10 UTC (rev 2250)
@@ -0,0 +1,61 @@
+&lt;?php
+/*
+   Load this with plugins/db/dba.php if your PHP provides only the
+   older dbm_*() functions.
+*/
+
+
+#-- fake dba_* using dbm_* functions
+if (!function_exists(&quot;dba_open&quot;) &amp;&amp; function_exists(&quot;dbm_open&quot;)) {
+
+   function dba_open($path, $mode, $handler, $a1=0) {
+      if ($handler == &quot;dbm&quot;) {
+         return(dbmopen($path, $mode));
+      }
+      else return(false);
+   }
+
+   function dba_popen($a, $b, $c, $d=0) {
+      return(dba_open($a, $b, $c));
+   }
+
+   function dba_exists($key, $handle) {
+      return(dbmexists($handle, $key));
+   }
+
+   function dba_fetch($key, $handle) {
+      return(dbmfetch($handle, $key));
+   }
+
+   function dba_insert($key, $string, $handle) {
+      return(dbminsert($handle, $key, $string));
+   }
+
+   function dba_replace($key, $string, $handle) {
+      return(dbmreplace($handle, $key, $string));
+   }
+
+   function dba_delete($key, $handle) {
+      return(dbmdelete($handle, $key));
+   }
+
+   function dba_firstkey($handle) {
+      return($GLOBALS[&quot;dbm_lastkey&quot;] = dbmfirstkey($handle));
+   }
+
+   function dba_nextkey($handle) {
+      return(dbmnextkey($handle, $GLOBALS[&quot;dbm_lastkey&quot;]));
+   }
+
+   function dba_close($handle) {
+      return(dbmclose($handle));
+   }
+
+   function dba_handlers() {
+      return(array(&quot;dbm&quot;));
+   }
+
+}
+
+
+?&gt;
\ No newline at end of file

Added: YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/ext/exotic.php
===================================================================
--- YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/ext/exotic.php	2006-12-09 18:08:01 UTC (rev 2249)
+++ YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/ext/exotic.php	2006-12-09 18:13:10 UTC (rev 2250)
@@ -0,0 +1,82 @@
+&lt;?php
+/*
+   Following funtions have been removed from the core emulation script, because
+   they are considered too special to be commonly used in WWW scripts. Anybody
+   using them, probably takes extra precautions prior calling them (you could
+   still load this script). Some of these functions could also be too difficult
+   to be reimplemented 100% exactly.
+*/
+
+
+
+#-- calls PHP interpreter itself (really only works with 4.3 onwards)
+#   (you should use the PHP_Compat implementation of this preferably)
+if (!function_exists(&quot;php_strip_whitespace&quot;)) {
+   function php_strip_whitespace($fn) {
+      // alternatives would be using te tokenizer or
+      // some regexs to strip unwanted content parts
+      // (PEAR::PHP_Compat simply calls the tokenizer)
+      $fn = escapeshellcmd($fn);
+      $text = `php -wqCf '$fn'`;
+      if (!$text) {
+         $text = implode(&quot;&quot;, file($fn));
+      }
+      return $text;
+   }
+}
+
+
+#-- invocates PHP interpreter to do the syntax check (nothing else can do)
+#   (you should use the PHP_Compat implementation of this preferably)
+if (!function_exists(&quot;php_check_syntax&quot;)) {
+   function php_check_syntax($fn) {
+      $args = func_get_args();
+      if (count($args)&gt;1) {
+         $result = &amp; $args[1];
+      }
+      $fn = escapeshellcmd($fn);
+      $result = system(&quot;php -lqCf '$fn'&quot;, $err);
+      return($err==0);
+   }
+}
+
+
+#-- print enumerated lsit of last-called functions
+if (!function_exists(&quot;debug_print_backtrace&quot;) &amp;&amp; function_exists(&quot;debug_backtrace&quot;)) {
+   function debug_print_backtrace() {
+      $d = debug_backtrace();
+      foreach ($d as $i=&gt;$info) {
+         #-- index
+         echo &quot;#&quot; . ($i) . &quot;  &quot;;
+         
+         #-- function name
+         if (isset($info[&quot;class&quot;])) {
+            echo &quot;$info[class]::&quot;;
+         }
+         if (isset($info[&quot;object&quot;])) {
+            echo &quot;\$$info[object]-&gt;&quot;;
+         }
+         echo &quot;$info[function]&quot;;
+         
+         #-- args
+         echo &quot;(&quot;;
+         foreach ($info[&quot;args&quot;] as $a) {
+            echo str_replace(&quot;\n&quot;, &quot;&quot;, var_export($a, 1)) . &quot;, &quot;;
+         }
+         echo &quot;)&quot;;
+         
+         #-- caller
+         echo &quot; called at [&quot;;
+         if ($info[&quot;file&quot;]) {
+            echo $info[&quot;file&quot;] . &quot;:&quot; . $info[&quot;line&quot;];
+         }
+         else {
+            echo &quot;unknown_location&quot;;
+         }
+         echo &quot;]\n&quot;;
+      }
+   }
+}
+
+
+?&gt;
\ No newline at end of file

Added: YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/ext/fakezlib.php
===================================================================
--- YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/ext/fakezlib.php	2006-12-09 18:08:01 UTC (rev 2249)
+++ YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/ext/fakezlib.php	2006-12-09 18:13:10 UTC (rev 2250)
@@ -0,0 +1,162 @@
+&lt;?php
+/*
+   This script simulates the gz*() functions, without actually providing
+   compression functionality. The generated data streams will be correct,
+   but reading compressed files isn't possible.
+   
+   Not very useful; should only be used if there is no other way. But if
+   your provider seriously doesn't have PHP with builtin zlib support,
+   you were better off simply switching to someone else!
+*/
+
+
+ #-- fake zlib
+ if (!function_exists(&quot;gzopen&quot;)) {
+
+    function gzopen($fp, $mode) {
+       $mode = preg_replace('/[^carwb+]/', '', $mode);
+       return(fopen($fp, $mode));
+    }
+    function gzread($fp, $len) {
+       return(fread($fp, $len));
+    }
+    function gzwrite($fp, $string) {
+       return(fwrite($fp, $string));
+    }
+    function gzputs($fp, $string) {
+       return(fputs($fp, $string));
+    }
+    function gzclose($fp) {
+       return(fclose($fp));
+    }
+    function gzeof($fp) {
+       return(feof($fp));
+    }
+    function gzseek($fp, $offs) {
+       return(fseek($fp, $offs, SEEK_SET));
+    }
+    function gzrewind($fp) {
+       return(frewind($fp));
+    }
+    function gztell($fp) {
+       return(ftell($fp));
+    }
+
+    function gzpassthru($fp) {
+       while (!gzeof($fp)) {
+          print(gzred($fp, 1&lt;&lt;20));
+       }
+       gzclose($fp);
+    }
+    function readgzfile($fn) {
+       if ($fp = gzopen($fn, &quot;rb&quot;)) {
+          gzpassthru($fp);
+       }
+    }
+   
+    function gzfile($fn) {
+       return(file($fn));
+    }
+
+    function gzgetc($fp) {
+       return(fgetc($fp));
+    }
+    function gzgets($fp, $len) {
+       return(fgets($fp, $len));
+    }
+    function gzgetss($fp, $len, $allowedtags=&quot;&quot;) {
+       return(fgetss($fp, $len, $allowedtags));
+    }
+
+ }
+
+
+ #-- fake compression methods
+ if (!function_exists(&quot;gzdeflate&quot;)) {
+
+    // only returns uncompressed deflate streams
+    function gzdeflate($data, $level=0) {
+        $gz = &quot;&quot;;
+        $end = strlen($data);
+        $p = 0;
+        do {
+           $c = $end - $pos;
+           if ($c &gt;= 65536) {
+              $c = 0xFFFF;
+              $end = 0x00;
+           }
+           else {
+              $end = 0x01;
+           }
+           $gz .= pack(&quot;Cvv&quot;,
+                     ($end &lt;&lt; 7) + (00 &lt;&lt; 5),  // LAST=0/1, BTYPE=00
+                     $c,                       // LEN
+                     $c ^ 0xFFFF               // NLEN
+                  );
+           $gz .= substr($data, $p, $c);
+           $p += $c;
+        }
+        while ($p &lt; $end);
+        return($gz);
+    }
+
+    // only can strip deflate headers, cannot decompress
+    function gzinflate($data, $length=NULL) {
+       $end = strlen($data);
+       $gz = &quot;&quot;;
+       if (isset($length) &amp;&amp; (($max*0.99) &gt; $length)) {
+          trigger_error(&quot;gzinflate(): gave up, decompressed string is likely longer than requested&quot;, E_USER_ERROR);
+          return;
+       }
+       $out = &quot;&quot;;
+       $p = 0;
+       do {
+          $head = ord($data[$p]);
+          $last = ($head &gt;&gt; 7);
+          if (($head &amp; 0x60) != 00) {
+             trigger_error(&quot;gzinflate(): cannot decode compressed stream&quot;, E_USER_ERROR);
+             return;
+          }
+          $head = unpack(&quot;v1LEN/v1NLEN&quot;, substr($data, $p+1, 4));
+          $c = $head[&quot;LEN&quot;];
+          if (($c ^ 0xFFFF) != $head[&quot;NLEN&quot;]) {
+             trigger_error(&quot;gzinflate(): data error in stream&quot;, E_USER_ERROR);
+             return;
+          }
+          $p += 5;
+          $out .= substr($data, $p, $c);
+          $p += $c;
+       }
+       while (($p &lt; $end) &amp;&amp; !$last);
+       return($out);
+    }
+
+
+//    function gzcompress() {
+//    }
+//    function gzuncompress() {
+//    }
+
+    // without real compression support again
+    function gzencode($data, $level=0) {
+       $isize = strlen($data);
+       $crc32 = crc32($data);
+       $gz = &quot;&quot;;
+       {
+          $gz .= pack(&quot;nCCVCC&quot;,
+             $_ID = 0x1f8b,
+             $_CM = 0x08,  // deflate fmt
+             $_FLG = 0x00, // nothing extra
+             $_MTIME = time(),
+             $_XFL = 0x00, // no bonus flags
+             $_OS = 255    // &quot;unknown&quot;
+          );
+          $gz .= gzdeflate($data);
+          $gz .= pack(&quot;VV&quot;, $crc32, $isize);
+       }
+       return($gz);
+    }
+
+ }
+
+?&gt;
\ No newline at end of file

Added: YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/ext/ftp.php
===================================================================
--- YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/ext/ftp.php	2006-12-09 18:08:01 UTC (rev 2249)
+++ YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/ext/ftp.php	2006-12-09 18:13:10 UTC (rev 2250)
@@ -0,0 +1,619 @@
+&lt;?php
+/*
+   Provides the usual ftp_() functions (or at least work-alikes)
+   for PHP versions compiled without.
+
+   Hint: If you want to use it with PHP versions with compiled-in FTP
+   support, then simply let your text editor replace all occourences
+   of &quot;ftp_&quot; into &quot;xftp_&quot; or something similar.
+
+   FreeWare, 2004, milky*users&#183;sf&#183;net
+*/
+
+if (!function_exists(&quot;ftp_connect&quot;)) {
+
+ #-- config
+ define(&quot;FTP_DEBUG&quot;, 0);
+ define(&quot;FTP_PASV&quot;, 0);   // default data transfer mode
+
+ #-- constants
+ define(&quot;FTP_ASCII&quot;, &quot;A&quot;);
+ define(&quot;FTP_BINARY&quot;, &quot;I&quot;);
+
+
+ #-- establish socket connection,
+ #   returns status+data array
+ function ftp_connect($server, $port=21, $proxy_server=NULL, $proxy_port=21) {
+    $fc = array();
+
+    #-- proxy or direct connection
+    if ($proxy_server) {
+       $f = fsockopen($proxy_server, $proxy_port, $errno, $errstr, 15);
+       $fc[&quot;proxy&quot;] = 1;
+    }
+    else {
+       if (strpos($server, &quot;:&quot;)) {
+          $server = strtok($server, &quot;:&quot;);
+          $port = strtok(&quot;:&quot;);
+       }
+       $f = fsockopen($server, (int)$port, $errno, $errstr, 15);
+    }
+
+    #-- socket connection established
+    if ($f) {
+       #-- socket connection settings
+       socket_set_blocking($f, 1);
+
+       #-- mk connection data hash
+       $fc[&quot;host&quot;] = $server;
+       $fc[&quot;port&quot;] = $port;
+       $fc[&quot;f&quot;] = $f;
+       $fc[&quot;d&quot;] = false;
+       $fc[&quot;dport&quot;] = false;
+       $fc[&quot;pasv&quot;] = FTP_PASV;
+
+       #-- read greeting
+       ftp_send($fc, &quot;&quot;, 1);
+       if (!$fc[&quot;err&quot;] == 220) {
+          ftp_err(&quot;server rejected further communication (after successful TCP/IP connection)&quot;);
+          return(false);
+       }
+
+       #-- ret handle
+       return($fc);
+    }
+    else {
+       ftp_err(&quot;connecting to $server:$port$add_err failed [err$errno: \&quot;$errstr\&quot;]&quot;);
+       return(false);
+    }
+ }
+
+
+ #-- internal use
+ function ftp_send(&amp;$fc, $command, $wait100=0, $break100=0) {
+    if ($fc) {
+
+       #-- send command
+       fwrite($fc[&quot;f&quot;], $command);
+
+       #-- read reply, line by line
+       $r = &quot;&quot;;
+       while (!feof($fc[&quot;f&quot;]) &amp;&amp; ($line = fgets($fc[&quot;f&quot;], 768))) {
+          $r .= $line;
+
+          #-- error/status number separated by space
+          if ($line{3} === &quot; &quot;) {
+             $err = (int) substr($line, 0, 3);
+             if ($err &gt;= 100) {
+                $fc[&quot;err&quot;] = $err;
+                $fc[&quot;msg&quot;] = rtrim(substr($line, 4));
+                if (($err &gt;= 200) || $break100) {
+                   break;
+                }
+                elseif ($wait100) {
+                   // nop, loop on until real status reply
+                }
+                elseif (FTP_DEBUG) {
+                   trigger_error(&quot;ftp delay ($err): $fc[msg]&quot;, E_USER_NOTICE);
+                }
+          }  }
+       }
+
+       #-- general faults, closed connection
+       switch ($err) {
+
+          case 421:
+            ftp_err(&quot;server closed connection - $fc[msg]&quot;);
+            ftp_close($fc);
+            $fc = false;
+            break;
+
+          case 332:
+            $r = ftp_send(&quot;ACCT $fc[user]&quot;);
+            break;
+
+          default:
+            if ($err &gt;= 400) {
+               trigger_error(&quot;ftp ($err): $fc[msg]&quot;, E_USER_NOTICE);
+            }
+       }
+
+       #-- done
+       if (FTP_DEBUG) {
+          echo &quot;&#187;&#187;&#187; $command&quot;;
+          echo &quot;&#171;&#171;&#171; $r&quot;;
+       }
+       return($r);
+    }
+    else {
+       ftp_err(&quot;invalid connection handle passed to ftp_send() function&quot;);
+    }
+ }
+
+
+ #-- simply check for successful result
+ function ftp_result(&amp;$fc) {
+    if ( ($fc[&quot;err&quot;] &lt;= 399) &amp;&amp; ($fc[&quot;err&quot;] &gt;= 200) ) {
+       return(true);
+    }
+ }
+
+
+ #-- internal use
+ function ftp_err($str) {
+    if (is_array($str)) {
+       $str = $str[&quot;err&quot;] . &quot; &quot; . $str[&quot;msg&quot;];
+    }
+    trigger_error(&quot;ftp: $str&quot;, E_USER_WARNING);
+ }
+
+
+ #-- authentification
+ function ftp_login(&amp;$fc, $user, $pw=&quot;&quot;) {
+
+    #-- send user name
+    $fc[&quot;user&quot;] = $user;
+    if ($user) {
+       $user .= ($fc[&quot;proxy&quot;] ? &quot;@&quot;.$fc[&quot;host&quot;] : &quot;&quot;);
+       ftp_send($fc, &quot;USER $user\n&quot;);
+
+       #-- password if required
+       if ($pw || ($fc[&quot;err&quot;] == 331)) {
+          ftp_send($fc, &quot;PASS $pw\n&quot;);
+       }
+       $r = ftp_result($fc);
+
+       if ($fc[&quot;err&quot;] != 230) {
+          ftp_err(&quot;unsuccessful login&quot;);
+       }
+    }
+
+    #-- check capabilities
+    @ftp_send($fc, &quot;MODE B\n&quot;);     // block mode supported?
+    if ($fc[&quot;err&quot;] == 200) {
+       $fc[&quot;mode&quot;] = &quot;B&quot;;
+    }
+    else {
+       $fc[&quot;mode&quot;] = &quot;S&quot;;
+       ftp_send($fc, &quot;MODE S\n&quot;);   // else stream mode (unreliable)
+    }
+
+    #-- pre-fetch system type
+    ftp_send($fc, &quot;SYST\n&quot;);
+    $fc[&quot;sys&quot;] = strtok($fc[&quot;msg&quot;], &quot; \r\n\t\f&quot;);
+
+    #-- set default options
+    @ftp_send($fc, &quot;SITE UMASK 0022\n&quot;);
+    ftp_send($fc, &quot;TYPE A\n&quot;);
+    ftp_send($fc, &quot;PWD\n&quot;);
+    if ($fc[&quot;err&quot;] != 257)  {
+       ftp_err(&quot;incompatible connection&quot;);
+    }
+
+    return($r);
+ }
+
+
+ #-- set data connection method/mode (will later be negotiated with server)
+ function ftp_pasv(&amp;$fc, $bool=1) {
+    $fc[&quot;pasv&quot;] = $bool ?1:0;
+    // ftp_err(&quot;this <A HREF="ftp://">ftp://</A> access module always uses the PASV server data connection mode&quot;);
+ }
+
+
+ #-- terminate ftp session
+ function ftp_quit(&amp;$fc) {
+    ftp_send($fc, &quot;QUIT\n&quot;);   // the server closes the tcp/ip connection
+    ftp_close($fc);            // so this is not necessary
+    $fc = false;
+ }
+
+
+ #-- close connections
+ function ftp_close(&amp;$fc) {
+    if ($fc[&quot;d&quot;] &amp;&amp; !feof($fc[&quot;d&quot;])) {
+       @fclose($fc[&quot;d&quot;]);
+    }
+    if (!feof($fc[&quot;f&quot;])) {
+       @fclose($fc[&quot;f&quot;]);
+    }
+ }
+
+
+ #-- simple functions -----------------------------------------------------
+
+ function ftp_cdup(&amp;$fc) {
+    ftp_send($fc, &quot;CDUP\n&quot;);
+    return ftp_result($fc);
+ }
+ function ftp_chdir(&amp;$fc, $path) {
+    ftp_send($fc, &quot;CWD $path\n&quot;);
+    return ftp_result($fc);
+ }
+ function ftp_mkdir(&amp;$fc, $path) {
+    ftp_send($fc, &quot;MKD $path\n&quot;);
+    return ftp_result($fc);
+ }
+ function ftp_rmdir(&amp;$fc, $path) {
+    ftp_send($fc, &quot;RMD $path\n&quot;);
+    return ftp_result($fc);
+ }
+ function ftp_pwd(&amp;$fc) {
+    ftp_send($fc, &quot;PWD $path\n&quot;);
+    $d = $fc[&quot;msg&quot;];
+    $l = strpos($d, '&quot;');
+    $d = substr($d, $l+1, strrpos($d, '&quot;')-$l-1);
+    return($d);
+ }
+
+ function ftp_delete(&amp;$fc, $file) {
+    ftp_send($fc, &quot;DELE $path\n&quot;);
+    return ftp_result($fc);
+ }
+ function ftp_mv(&amp;$fc, $from, $to) {
+    ftp_send($fc, &quot;RNFR $from\n&quot;);
+    ftp_send($fc, &quot;RNTO $to\n&quot;);
+    return ftp_result($fc);
+ }
+ function ftp_chmod(&amp;$fc, $perm, $path) {
+    $perm = &quot;0&quot; . base_convert($perm, 10, 8);
+    ftp_send($fc, &quot;SITE CHMOD $perm $path\n&quot;);
+    return ftp_result($fc);
+ }
+
+ function ftp_site(&amp;$fc, $cmd) {
+    $cmd = rtrim($cmd);
+    ftp_send($fc, &quot;SITE $cmd\n&quot;);
+    return ftp_result($fc);
+ }
+ function ftp_exec(&amp;$fc, $cmd) {
+    ftp_site($fc, &quot;EXEC $cmd\n&quot;);
+    return ftp_result($fc);
+ }
+ function ftp_raw(&amp;$fc, $str) {
+    $str = rtrim($str) . &quot;\n&quot;;
+    $r = ftp_send($fc, $str);
+    return(explode(&quot;\n&quot;, $r));
+ }
+
+ function ftp_systype(&amp;$fc) {
+    return $fc[&quot;sys&quot;];
+ }
+
+
+ #-- file transfer calls --------------------------------------------------
+
+
+ #-- file upload
+ function ftp_fput(&amp;$fc, $to, $fh, $mode=FTP_BINARY, $chunksize=65536) {
+    if (!$fh) { return; }
+
+    #-- data connection
+    ftp_data_connection($fc);
+    if ($chunksize &gt;= 65536) {
+       $chunksize = 65535;
+    }
+
+    #-- initiate file transfer
+    ftp_send($fc, &quot;TYPE $mode\n&quot;);
+    set_time_limit(240);
+    ftp_send($fc, &quot;STOR $to\n&quot;, 0, 1);
+
+    #-- server waiting for transfer?
+    if (($fc[&quot;err&quot;] == 150) || ($fc[&quot;err&quot;] == 125)) {
+
+       #-- connection mode
+       if (!$fc[&quot;pasv&quot;]) {
+          $d = socket_accept($fc[&quot;s&quot;]);
+          $data_write = &quot;socket_write&quot;;
+          $data_close = &quot;socket_close&quot;;
+       }
+       else {
+          $d = &amp; $fc[&quot;d&quot;];
+          $data_write = &quot;fwrite&quot;;
+          $data_close = &quot;fclose&quot;;
+       }
+
+       #-- stream mode, simple
+       if ($fc[&quot;mode&quot;] == &quot;S&quot;) {
+          while ($fh &amp;&amp; !feof($fh)) {
+             $dat = fread($fh, $chunksize);
+             $data_write($d, $dat);
+          }
+       }
+       else {
+          while ($fh &amp;&amp; !feof($fh)) {
+             $dat = fread($fh, $chunksize);
+             $n = strlen($dat);
+             $data_write($d, pack(&quot;cn&quot;, 0, $n));   // block header
+             $data_write($d, $dat);
+          }
+          $data_write($fc[&quot;d&quot;], pack(&quot;ccc&quot;, 0x40, 0, 0));   // EOF
+       }
+
+       #-- close server socket
+       if (!$fc[&quot;pasv&quot;]) {
+          socket_close($d);
+       }
+
+       #-- transmission ok
+       ftp_data_end($fc);
+       ftp_send($fc, &quot;&quot;, 1);
+       $r = ($fc[&quot;err&quot;] == 226) || ($fc[&quot;err&quot;] == 250);
+
+       #-- reset options
+       if ($mode != FTP_ASCII) {
+          ftp_send($fc, &quot;TYPE A\n&quot;);
+       }
+
+    }
+    else {
+       ftp_err(&quot;$fc[err] $fc[msg]&quot;);
+       $r = 0;
+    }
+
+    return($r);
+ }
+
+
+ function ftp_put(&amp;$fc, $to, $fn, $mode=FTP_BINARY) {
+    if (!is_resource($fn)) {
+       $fn = fopen($fn, &quot;rb&quot;);
+    }
+    $r = ftp_fput($fc, $to, $fn, $mode);
+    fclose($fn);
+    return($r);
+ }
+
+
+
+
+ #-- download
+ function ftp_fget(&amp;$fc, $to, $fh, $mode=FTP_BINARY, $chunksize=65536) {
+    if (!$fh) { return; }
+
+    #-- open connection
+    ftp_data_connection($fc);
+
+    #-- initiate file transfer
+    ftp_send($fc, &quot;TYPE $mode\n&quot;);
+    set_time_limit(240);
+    ftp_send($fc, &quot;RETR $to\n&quot;, 0, 1);
+
+    #-- server waiting for transfer?
+    if (($fc[&quot;err&quot;] == 150) || ($fc[&quot;err&quot;] == 125)) {
+
+       #-- connection mode
+       if (!$fc[&quot;pasv&quot;]) {
+          $d = socket_accept($fc[&quot;s&quot;]);
+          $data_read = &quot;socket_read&quot;;
+          $data_close = &quot;socket_close&quot;;
+       }
+       else {
+          $d = &amp; $fc[&quot;d&quot;];
+          $data_read = &quot;fread&quot;;
+          $data_close = &quot;fclose&quot;;
+       }
+
+       #-- stream mode, simple
+       if ($fc[&quot;mode&quot;] == &quot;S&quot;) {
+          $dat = &quot;+&quot;;
+          while (strlen($dat)) {
+             $dat = $data_read($d, $chunksize);
+             fwrite($fh, $dat);
+          }
+       }
+       else {
+          $eof = 0;
+          while (!$eof) {
+             list($flags, $len) = unpack(&quot;cn&quot;, $data_read($d, 3));
+             $eof = $flags &amp; (0x40|0x80);
+
+             if ($len) {
+                $dat = $data_read($d, $len);
+                fwrite($fh, $dat);
+             }
+          }
+       }
+
+       #-- close server socket
+       if (!$fc[&quot;pasv&quot;]) {
+          $data_close($d);
+       }
+
+       #-- transmission ok
+       ftp_data_end($fc);
+       ftp_send($fc, &quot;&quot;, 1);
+       $r = ($fc[&quot;err&quot;] == 226) || ($fc[&quot;err&quot;] == 250);
+
+       #-- reset options
+       if ($mode != FTP_ASCII) {
+          ftp_send($fc, &quot;TYPE A\n&quot;);
+       }
+
+    }
+    else {
+       ftp_err(&quot;$fc[err] $fc[msg]&quot;);
+       $r = 0;
+    }
+
+    return($r);
+ }
+
+
+ #-- directly into file
+ function ftp_get(&amp;$fc, $to, $fn, $mode=FTP_BINARY) {
+    if (!is_resource($fn)) {
+       $fn = fopen($fn, &quot;wb&quot;);
+    }
+    $r = ftp_fget($fc, $to, $fn, $mode);
+    fclose($fn);
+    return($r);
+ }
+
+
+
+ #-- establishes a data connection ---------------------------------------
+ function ftp_data_connection(&amp;$fc) {
+    if (!$fc[&quot;d&quot;] || feof($fc[&quot;d&quot;])) {
+
+       #-- make client establish connection (PASsiVe server)
+       if ($fc[&quot;pasv&quot;]) {
+          ftp_send($fc, &quot;PASV\n&quot;);
+
+          #-- reply ok?
+          if ($fc[&quot;err&quot;] == 227) {
+             $l = strpos($fc[&quot;msg&quot;], &quot;(&quot;);
+             $r = strpos($fc[&quot;msg&quot;], &quot;)&quot;, $l);
+             $uu = explode(&quot;,&quot;, substr($fc[&quot;msg&quot;], $l + 1, $r - $l - 1));
+             $ip = &quot;$uu[0].$uu[1].$uu[2].$uu[3]&quot;;
+             $port = ((int)$uu[4]&lt;&lt;8) + ((int)$uu[5]);
+
+             #-- all done
+             if ($port) {
+                if (!$fc[&quot;d&quot;] = @fsockopen($ip, $port, $errno, $errstr, 25)) {
+                   ftp_err(&quot;data socket connection could not be established [$errno - $errstr]&quot;);
+                }
+             }
+             else {
+                ftp_err(&quot;data connection negotiation problem (server uses wrong syntax)&quot;);
+             }
+          }
+
+          #-- fall back
+          else {
+             $fc[&quot;pasv&quot;] = 0;
+             ftp_err(&quot;falling back to standard (ACTiVe server) connection mode&quot;);
+             ftp_data_connection($fc);
+          }
+       }
+
+       #-- else choose port we wish the server to contact us
+       elseif (!$fc[&quot;s&quot;]) {
+          if (!function_exists(&quot;socket_listen&quot;)) {
+             ftp_err(&quot;could not establish data connection, because PHP socket I/O functions are absent&quot;);
+          }
+          else {
+             $ip = strtr(gethostbyname(&quot;localhost&quot;), &quot;.&quot;, &quot;,&quot;);
+
+             #-- loop, test randomly choosen ports
+             $retry = 20;
+             $s = 0;
+             while ((!$s) &amp;&amp; ($retry-- &gt;= 0)) {
+                $port = rand(3072, 65535);
+                $p1 = ($port &gt;&gt; 8);
+                $p2 = ($port &amp; 0xFF);
+                ftp_send($fc, &quot;PORT $ip,$p1,$p2\n&quot;);
+                if ($fc[&quot;err&quot;] == 200) {
+                   $s = socket_create_listen($port);
+                }
+             }
+             if ($s) {
+                $fc[&quot;s&quot;] = $s;
+             }
+             else {
+                ftp_err(&quot;could not create listening socket for (ACTiVe server) data connection&quot;);
+             }
+       }  }
+    }
+ }
+
+
+ #-- closes data connection, (in stream mode)
+ function ftp_data_end(&amp;$fc) {
+    if (($fc[&quot;d&quot;]) &amp;&amp; ($fc[&quot;mode&quot;] == &quot;S&quot;)) {
+       if ($fc[&quot;pasv&quot;]) {
+          fclose($fc[&quot;d&quot;]);
+       }
+       else {
+          socket_close($fc[&quot;d&quot;]);
+       }
+       $fc[&quot;d&quot;] = false;
+    }
+ }
+
+
+}
+
+
+
+#------------------------------------------------------------- add-ons ---
+# require a connection in $GLOBALS['fc'];
+
+
+#-- transfers a file tree from source dir to destination on connected server
+function ftp_xcopy($from, $to=NULL) {
+   global $fc, $DEBUG;
+   #-- dir
+   if ($to) {
+      ftp_xmkdir($to);
+   }
+   else {
+      ftp_xmkdir($from);
+      $to = $from;
+   }
+   if (!$from) {
+      return;
+   }
+   #-- store files
+   if (is_dir($from)) {
+      if ($dh = opendir($from)) {
+         $from = trim($from, &quot;/&quot;);
+         while ($fn = readdir($dh)) {
+            if ($fn[0] != &quot;.&quot;) {
+               ftp_xcopy(&quot;$from/$fn&quot;);
+            }
+         }
+         closedir($dh);
+      }
+      else {
+         echo &quot;error reading directory '$from'&lt;br&gt;\n&quot;;
+      }
+   }
+   else {
+      if ($f = fopen($from, &quot;rb&quot;)) {
+         if (!$DEBUG) {
+#$cwd=getcwd(); echo &quot;PUT $cwd/$from to $to  &lt;br&gt;\n&quot;;
+            ftp_put($fc, $to, $from, FTP_BINARY);
+            ftp_site($fc, &quot;CHMOD 0644 $to&quot;);
+         }
+         else {
+            echo &quot;upload '$from' to '<A HREF="ftp://.../$to">ftp://.../$to</A>'&lt;br&gt;\n&quot;;
+         }
+         fclose($f);
+      }
+      else {
+         echo &quot;error reading file '$from'&lt;br&gt;\n&quot;;
+      }
+   }
+}
+
+
+#-- creates directory trees for given filename strings and keeps track
+#   of what it created, so you can call it without thought
+function ftp_xmkdir($file) {
+   global $fc, $ftp_dirs, $DEBUG;
+   $p = strrpos($file, &quot;/&quot;);
+   if (!$p) {
+      return;
+   }
+   $file = substr($file, 0, $p);
+   if (in_array($file, $ftp_dirs)) {
+      return;
+   }
+   $p = 0;
+   $file .= &quot;/&quot;;
+   while ($p = strpos($file, &quot;/&quot;, $p+1)) {
+      $dir = substr($file, 0, $p);
+      if (!in_array($dir, $ftp_dirs)) {
+         if (!$DEBUG) {
+            @ftp_mkdir($fc, $dir);
+            @ftp_site($fc, &quot;CHMOD 0755 $dir&quot;);
+         }
+         $ftp_dirs[] = $dir;
+      }
+   }
+}
+
+
+?&gt;
\ No newline at end of file

Added: YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/ext/gettext.meta
===================================================================
--- YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/ext/gettext.meta	2006-12-09 18:08:01 UTC (rev 2249)
+++ YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/ext/gettext.meta	2006-12-09 18:13:10 UTC (rev 2250)
@@ -0,0 +1,6 @@
+api: PHP
+type: functions
+title: gettext()
+description: emulates gettext functionality
+priority: auto
+category: library

Added: YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/ext/gettext.php
===================================================================
--- YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/ext/gettext.php	2006-12-09 18:08:01 UTC (rev 2249)
+++ YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/ext/gettext.php	2006-12-09 18:13:10 UTC (rev 2250)
@@ -0,0 +1,381 @@
+&lt;?php
+/*
+   This include script simulates gettext() functionality.
+    - It could read translation data from .mo and .po files.
+    - Lookup of plural forms mostly work (but not 100% compliant,
+      no real interpreter for Plural-Forms: expression).
+    - Categories/codesets are ignored.
+
+   Besides using setlocale() you should change the $_ENV[&quot;LANG&quot;] var
+   to the desired language manually. Additionally all your scripts
+   could contain following (may also work with standard gettext):
+     $_ENV[&quot;LANGUAGE&quot;] = $_SERVER[&quot;HTTP_ACCEPT_LANGUAGE&quot;];
+   What's often more user-friendly than hardwired server-side values.
+*/
+
+
+#-- emulate only if not present in current PHP interpreter
+if (!function_exists(&quot;gettext&quot;)) {
+
+
+   #-- all-in-one combined implementation
+   #   (in original API only the first parameter is present)
+   function gettext($msg, $msg2=NULL, $domain=NULL, $category=NULL, $plural=NULL) {
+      global $_GETTEXT;
+
+      #-- get default params if corresponding args are empty
+      if (!isset($domain)) {
+         $domain = $_GETTEXT[&quot;%domain&quot;];
+      }
+      if (empty($_GETTEXT[$domain])) {
+         bindtextdomain($domain);  // auto load from system dirs
+      }
+
+      #-- plural array position
+      if (!isset($plural)) {
+         $pli = 0;
+      }
+      elseif ($ph = $_GETTEXT[$domain][&quot;%plural-c&quot;]) {
+         $pli = gettext___plural_guess($ph, $plural);
+      }
+      else {
+         $pli = ($plural != 1) ? 1 : 0;   // English
+      }
+
+      #-- look up string
+      if (($trans = $_GETTEXT[$domain][$msg])
+      or ($pli) and ($trans = $_GETTEXT[$domain][$msg2]))
+      {
+         // handle plural entries
+         if (is_array($trans)) {
+            if (!isset($trans[$pli])) {
+               $pli = 0;   // missing translation
+            }
+            $trans = $trans[$pli];
+         }
+         // only return, if something found
+         if (strlen($trans)) {
+            $msg = $trans;
+         }
+      }
+
+      #-- handle $category (???)
+      // recode() ...
+
+      #-- give out whatever we have
+      return($msg);
+   }
+   
+
+   #-- return plural form array index for algorithm type
+   #   (compacted from C expression string beforehand)
+   function gettext___plural_guess(&amp;$type, $n) {
+   
+      #-- guess from string with C expression and set integer shorthand
+      if (is_string($type)) {
+         if (($type == &quot;nplurals=1;plural=0;&quot;) || !strlen($type)) {
+            $type = -1; // no plurals
+         }
+         elseif ($type == &quot;nplurals=2;plural=n!=1;&quot;) {
+            $type = 1;  // English
+         }
+         elseif ($type == &quot;nplurals=2;plural=n&gt;1;&quot;) {
+            $type = 2;  // French
+         }
+         // special cases
+         elseif (strpos($type, &quot;n%100!=11&quot;)) {
+            if (strpos($type, &quot;n!=0&quot;)) {
+               $type == 21;  // Latvian
+            }
+            if (strpos($type, &quot;n%10&lt;=4&quot;)) {
+               $type = 22;   // a few Slavic langs (code similar to Polish below)
+            }
+            if (strpos($type, &quot;n%10&gt;=2&quot;)) {  // Lithuanian
+               $type = 23;
+            }
+            $type = 0;
+         }
+         // specials, group 2
+         elseif (strpos($type, &quot;n&lt;=4&quot;)) {   // Slovak
+            $type = 25;
+         }
+         elseif (strpos($type, &quot;n==2&quot;)) {   // Irish
+            $type = 31;
+         }
+         elseif (strpos($type, &quot;n%10&gt;=2&quot;)) {   // Polish
+            $type = 26;
+         }
+         elseif (strpos($type, &quot;n%100==3&quot;)) {   // Slovenian
+            $type = 28;
+         }
+         // fallbacks
+         elseif (strpos($type, &quot;;plural=n;&quot;)) {
+            $type = 7;  // unused
+         }
+         // first at this point a tokenizer/parser/interpreter would have made sense
+         else {
+            $type = 0;  // no plurals
+         }
+      }
+
+      #-- return plural index value from pre-set formulas
+      switch ($type) {
+         case -1:  // no plural forms
+            return(0);
+         case 1:   // English, and lots of others...
+            return($n != 1 ? 1 : 0);
+         case 2:   // French, Brazilian Protuguese
+            return($n &gt; 1 ? 1 : 0);
+         case 7:   // unused
+            return($n);
+
+         case 21:  // Latvian
+            return  (($n%10==1) &amp;&amp; ($n%100!=11)) ? (0) :  ($n!=0 ? 1 : 2)  ;
+         case 22:  // Slavic langs
+            return  ($n%10==1) &amp;&amp; ($n%100!=11) ? 0 :
+               ( ($n%10&gt;=2) &amp;&amp; ($n%10&lt;=4) &amp;&amp; ($n%100&lt;10 || $n%100&gt;=20) ? 1 : 2  )  ;
+         case 23:  // Lithuanian
+            return  ($n%10==1) &amp;&amp; ($n%100!=11) ? 0 :
+               ( ($n%10&gt;=2) &amp;&amp; ($n%100&lt;10 || $n%100&gt;=20) ? 1 : 2  )  ;
+         case 25:  // Slovak
+            return  $n==1 ? 0 : ($n&gt;=2 &amp;&amp; $n&lt;=4 ? 1 : 2)  ;
+         case 26:  // Polish
+             return  $n==1 ? 0 : ( $n%10&gt;=2 &amp;&amp; $n%10&lt;=4 &amp;&amp; ($n%100&lt;10 || $n%100&gt;=20) ? 1 : 2 )  ;
+         case 28:  // Slovenian
+            return  $n%100==1 ? 0 : ($n%100==2 || $n%100==3 || $n%100==4 ? 2 : 3)  ;
+         case 31:  // Irish
+            return  ($n == 1) ? (0) : (($n == 2) ? 1 : 2)  ;
+
+         default:
+            $type = -1;
+      }   // unsupported, always return non-plural index [0]
+      return(0);
+   }
+
+
+   #-- wrappers around monster function above
+   function ngettext($msg1, $msg2, $plural) {
+      return gettext($msg1, $msg2, NULL, NULL, $plural);
+   }
+   function dngettext($domain, $msg1, $msg2, $plural) {
+      return gettext($msg1, $msg2, $domain, NULL, $plural);
+   }
+   function dcngettext($domain, $msg1, $msg2, $plural, $category) {
+      return gettext($msg1, $msg2, $domain, $category, $plural);
+   }
+   function dcgettext($domain, $msg, $category) {
+      return gettext($msg, NULL, $domain, $category);
+   }
+   function dgettext($domain, $msg) {
+      return gettext($msg, NULL, $domain);
+   }
+
+
+   #-- sets current translation data source
+   #   (must have been loaded beforehand)
+   function textdomain($default=&quot;NULL&quot;) {
+      global $_GETTEXT;
+      $prev = $_GETTEXT[&quot;%domain&quot;];
+      if (isset($default)) {
+         $_GETTEXT[&quot;%domain&quot;] = $default;
+      }
+      return $prev;
+   }
+
+
+   #-- loads data files
+   function bindtextdomain($domain, $directory=&quot;/usr/share/locale:/usr/local/share/locale:./locale&quot;) {
+      global $_GETTEXT;
+      if (isset($_GETTEXT[&quot;domain&quot;]) &amp;&amp; (count($_GETTEXT[&quot;domain&quot;]) &gt; 3)) {
+         return;  // don't load twice
+      }
+      $_GETTEXT[$domain][&quot;%dir&quot;] = $directory;
+      $_GETTEXT[&quot;%locale&quot;] = setlocale(LC_CTYPE, 0);
+
+      #-- allowed languages
+      $langs = &quot;$_ENV[LANGUAGE],$_ENV[LC_ALL],$_ENV[LC_MESSAGE],$_ENV[LANG],&quot;
+             . $_GETTEXT[&quot;%locale&quot;] . &quot;,$_SERVER[HTTP_ACCEPT_LANGUAGE],C,en&quot;;
+          
+      #-- add shortened language codes (en_UK.UTF-8 -&gt; + en_UK, en)
+      foreach (explode(&quot;,&quot;,$langs) as $d) {
+         $d = trim($d);
+         // $dir2[] = $d;
+         $d = strtok($d, &quot;@.-+=%:; &quot;);
+         if (strlen($d)) {
+            $dir2[] = $d;
+         }
+         if (strpos($d, &quot;_&quot;)) {
+            $dir2[] = strtok($d, &quot;_&quot;);
+         }
+      }
+      
+      #-- search for matching directory and load data file
+      foreach (explode(&quot;:&quot;, $directory) as $directory) {
+         foreach ($dir2 as $lang) {
+            $base_fn = &quot;$directory/$lang/LC_MESSAGES/$domain&quot;;
+
+            #-- binary format
+            if (file_exists($fn = &quot;$base_fn.mo&quot;) &amp;&amp; ($f = fopen($fn, &quot;rb&quot;)))
+            {
+               gettext___load_mo($f, $domain);
+               break 2;
+            }
+
+            #-- text file
+            elseif (function_exists(&quot;gettext___load_po&quot;)
+            and file_exists($fn = &quot;$base_fn.po&quot;) &amp;&amp; ($f = fopen($fn, &quot;r&quot;)))
+            {
+               gettext___load_po($f, $domain);
+               break 2;
+            }
+         }
+      }//foreach
+      
+      #-- extract headers
+      if ($head = $_GETTEXT[$domain][&quot;&quot;]) {
+         foreach (explode(&quot;\n&quot;, $head) as $line) {
+            $header = strtok(&quot;:&quot;, $line);
+            $line = trim(strtok(&quot;\n&quot;));
+            $_GETTEXT[$domain][&quot;%po-header&quot;][strtolower($header)] = $line;
+         }
+      
+         #-- plural-forms header
+         if (function_exists(&quot;gettext___plural_guess&quot;)
+         and ($h = $_GETTEXT[$domain][&quot;%po-header&quot;][&quot;plural-forms&quot;]))
+         {
+            $h = preg_replace(&quot;/[(){}\[\]^\s*\\]+/&quot;, &quot;&quot;, $h);  // rm whitespace
+            gettext___plural_guess($h, 0);  // pre-decode into algorithm type integer
+            $_GETTEXT[$domain][&quot;%plural-c&quot;] = $h;
+         }
+      }
+
+      #-- set as default textdomain
+      if (empty($_GETTEXT[&quot;%domain&quot;])) {
+         textdomain($domain);
+      }
+      return($domain);
+   }
+
+
+   #-- load string data from binary .mo files (ign checksums)
+   function gettext___load_mo($f, $domain) {
+      global $_GETTEXT;
+
+      #-- read in data file completely
+      $data = fread($f, 1&lt;&lt;20);
+      fclose($f);
+
+      #-- extract header fields and check file magic
+      if ($data) {
+         $header = substr($data, 0, 20);
+         $header = unpack(&quot;L1magic/L1version/L1count/L1o_msg/L1o_trn&quot;, $header);
+         extract($header);
+         if ((dechex($magic) == &quot;950412de&quot;) &amp;&amp; ($version == 0)) {
+
+            #-- fetch all entries
+            for ($n=0; $n&lt;$count; $n++) {
+
+               #-- msgid
+               $r = unpack(&quot;L1len/L1offs&quot;, substr($data, $o_msg + $n * 8, 8));
+               $msgid = substr($data, $r[&quot;offs&quot;], $r[&quot;len&quot;]);
+               unset($msgid_plural);
+               if (strpos($msgid, &quot;\000&quot;)) {
+                  list($msgid, $msgid_plural) = explode(&quot;\000&quot;, $msgid);
+               }
+
+               #-- translation(s)
+               $r = unpack(&quot;L1len/L1offs&quot;, substr($data, $o_trn + $n * 8, 8));
+               $msgstr = substr($data, $r[&quot;offs&quot;], $r[&quot;len&quot;]);
+               if (strpos($msgstr, &quot;\000&quot;)) {
+                  $msgstr = explode(&quot;\000&quot;, $msgstr);
+               }
+
+               #-- add
+               $_GETTEXT[$domain][$msgid] = $msgstr;
+               if (isset($msgid_plural)) {
+                  $_GETTEXT[$domain][$msgid_plural] = &amp;$_GETTEXT[$domain][$msgid];
+               }
+            }
+
+         }
+      }
+   }
+
+
+   #-- read from textual .po source file (not fully correct, and redundant
+   #   because the original gettext/libintl doesn't support this at all)
+   function gettext___load_po($f, $domain) {
+      global $_GETTEXT;
+      $c_esc = array(&quot;\\n&quot;=&gt;&quot;\n&quot;, &quot;\\r&quot;=&gt;&quot;\r&quot;, &quot;\\\\&quot;=&gt;&quot;\\&quot;, &quot;\\f&quot;=&gt;&quot;\f&quot;, &quot;\\t&quot;=&gt;&quot;\t&quot;, &quot;\\&quot;=&gt;&quot;&quot;);
+
+      #-- read line-wise from text file   
+      do {
+         $line = trim(fgets($f));
+
+         #-- check what's in the current line
+         $space = strpos($line, &quot; &quot;);
+         // comment
+         if ($line[0] == &quot;#&quot;) {
+            //continue;
+         }
+         // msgid
+         elseif (strncmp($line, &quot;msgid&quot;, 5)==0) {
+            $msgid[] = trim(substr($line, $space+1), '&quot;');
+         }
+         // translation
+         elseif (strncmp($line, &quot;msgstr&quot;, 6)==0) {
+            $msgstr[] = trim(substr($line, $space+1), '&quot;');
+         }
+         // continued (could be _id or _str)
+         elseif ($line[0] == '&quot;') {
+            $line = trim($line, '&quot;');
+            if (isset($msggstr)) {
+               $msgstr[count($msgstr)] .= $line;
+            }
+            else {
+               $msgid[count($msgid)] .= $line;
+            }
+         }
+
+         #-- append to global $_GETTEXT hash as soon as we have a complete dataset
+         if (isset($msgid) &amp;&amp; isset($msgstr) &amp;&amp; (empty($line) || ($line[0]==&quot;#&quot;) || feof($f)) )
+         {
+            $msgid[0] = strtr($msgid[0], $c_esc);
+            foreach ($msgstr as $v) {
+               $_GETTEXT[$domain][$msgid[0]] = strtr($v, $c_esc);
+            }
+            if ($msgid[1]) {
+               $msgid[1] = strtr($msgid[1], $c_esc);
+               $_GETTEXT[$domain][$msgid[1]] = &amp;$_GETTEXT[$domain][$msgid[0]];
+            }
+
+            $msgid = array();
+            $msgstr = array();
+         }
+
+      } while (!feof($f));
+      fclose($f);
+   }
+
+
+   #-- ignored setting (no idea what it really should do)
+   function bind_textdomain_codeset($domain, $codeset) {
+      global $_GETTEXT;
+      $_GETTEXT[$domain][&quot;%codeset&quot;] = $codeset;
+      return($domain);
+   }
+
+
+}
+
+
+#-- define gettexts preferred function name _ separately
+if (!function_exists(&quot;_&quot;)) {
+   function _($str) {
+      return gettext($str);
+   }
+}
+
+
+
+?&gt;
\ No newline at end of file

Added: YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/ext/gettext.txt
===================================================================
--- YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/ext/gettext.txt	2006-12-09 18:08:01 UTC (rev 2249)
+++ YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/ext/gettext.txt	2006-12-09 18:13:10 UTC (rev 2250)
@@ -0,0 +1,57 @@
+
+PHP-only gettext emulation
+--------------------------
+
+The &quot;gettext.php&quot; include script tries to reimplement GNU gettext in
+pure PHP. It is incomplete and divergent in many ways, but seems to
+work well in its goal to be a quick drop-in replacement.
+
+You load the script, like you'd include the &quot;upgrade.php&quot; script, and
+then have the family of gettext functions always available - if they
+are compiled in into your PHP binary or not. This way you can freely
+use standardized i18n features safely on any web server and with all
+your applications.
+
+There are however a few minor obstacles and differences in between
+the original and the emulation which you have to take care of. Most
+of the incompatibilites descend from lousily documented behaviour of
+the original and from lack of extensqive testing of the emulated
+versions.
+
+ - You should use setlocale() before any bindtextdomain(), because
+   this emulation does load the .mo/.po data files only once.
+
+ - The emulation only ever loads one translation file (it never
+   retrieves translation strings from different localizations,
+   so it is less useful in conjunction with Accept-Language header
+   settings - where multiple languages could be given).
+   [Original gettext may or may not load from multiple files??]
+
+ - To be compliant with the native implementation, you have to make
+   sure, that the .mo files are built from the *.po source files.
+   (The emulation tries to work on both, but it really shouldn't do
+   that.)
+
+ - Order of environment variable precedence is:
+     1. LANGUAGE
+     2. LC_ALL
+     3. LC_MESSAGE
+     4. LANG                    (multiple langs)
+     5. setlocale()
+     6. HTTP_ACCEPT_LANGUAGE    (incompliant with GNU gettext)
+
+ - There is a second variant of the script, which tries to handle
+   plural forms. This has multiple limitations:
+     - does not employ a full Plural-Forms parser (a C expression
+       which must be interpreted at runtime)
+     - matches and works only with a few built-in language plural
+       form syntaxes and orderings
+     - and it's fully untested as of yet
+
+ - It constructs a global $_GETTEXT[] variable which contains all
+   messages and translations at runtime in-memory. That means, it
+   is far more memory-hungry and less scalable than the original
+   GNU libintl in C.
+
+
+

Added: YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/ext/mime.php
===================================================================
--- YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/ext/mime.php	2006-12-09 18:08:01 UTC (rev 2249)
+++ YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/ext/mime.php	2006-12-09 18:13:10 UTC (rev 2250)
@@ -0,0 +1,358 @@
+&lt;?php
+/*
+   Simulates the mime_magic extension. Was originally implemented for
+   [<A HREF="http://nanoweb.si.kz/">http://nanoweb.si.kz/</A>], but that mime magic data reading was
+   reinjected for this version (more unclean, though).
+   You still need to get the &quot;mime_magic&quot; file to use this, please see
+   file(1) for more informations.
+   Also simulates the image type/mime/ext functions.
+*/
+
+
+#-- mime-magic, type will be detected by analyzing the content
+if (!function_exists(&quot;mime_content_type&quot;)) {
+   function mime_content_type($fn) {
+
+      static $mime_magic_data;
+
+      #-- fallback
+      $type = false;
+
+      #-- read in first 3K of given file
+      if (is_dir($fn)) {
+         return(&quot;httpd/unix-directory&quot;);
+      }
+      elseif (is_resource($fn) || ($fn = @fopen($fn, &quot;rb&quot;))) {
+         $bin = fread($fn, $maxlen=3072);
+         fclose($fn);
+      }
+      elseif (!file_exists($fn)) {
+         return false;
+      }
+      else {
+         return(&quot;application/octet-stream&quot;);   // give up
+      }
+
+      #-- use PECL::fileinfo when available
+      if (function_exists(&quot;finfo_buffer&quot;)) {
+         if (!isset($mime_magic_data)) {
+            $mime_magic_data = finfo_open(MAGIC_MIME);
+         }
+         $type = finfo_buffer($bin);
+         return($type);
+      }
+      
+      #-- read in magic data, when called for the very first time
+      if (!isset($mime_content_type)) {
+      
+         if ((file_exists($fn = ini_get(&quot;mime_magic.magicfile&quot;)))
+          or (file_exists($fn = &quot;/usr/share/misc/magic.mime&quot;))
+          or (file_exists($fn = &quot;/etc/mime-magic&quot;))   )
+         {
+            $mime_magic_data = array();
+
+            #-- read in file
+            $f = fopen($fn, &quot;r&quot;);
+            $fd = fread($f, 1&lt;&lt;20);
+            fclose($f);
+            $fd = str_replace(&quot;       &quot;, &quot;\t&quot;, $fd);
+
+            #-- look at each entry
+            foreach (explode(&quot;\n&quot;, $fd) as $line) {
+
+               #-- skip empty lines
+               if (!strlen($line) or ($line[0] == &quot;#&quot;) or ($line[0] == &quot;\n&quot;)) {
+                  continue;
+               }
+
+               #-- break into four fields at tabs
+               $l = preg_split(&quot;/\t+/&quot;, $line);
+               @list($pos, $typestr, $magic, $ct) = $l;
+#print_r($l);
+
+               #-- ignore &gt;continuing lines
+               if ($pos[0] == &quot;&gt;&quot;) {
+                  continue;
+               }
+               #-- real mime type string?
+               $ct = strtok($ct, &quot; &quot;);
+               if (!strpos($ct, &quot;/&quot;)) {
+                  continue;
+               }
+
+               #-- mask given?
+               $mask = 0;
+               if (strpos($typestr, &quot;&amp;&quot;)) {
+                  $typestr = strtok($typestr, &quot;&amp;&quot;);
+                  $mask = strtok(&quot; &quot;);
+                  if ($mask[0] == &quot;0&quot;) {
+                     $mask = ($mask[1] == &quot;x&quot;) ? hexdec(substr($mask, 2)) : octdec($mask);
+                  }
+                  else {
+                     $mask = (int)$mask;
+                  }
+               }
+
+               #-- strip prefixes
+               if ($magic[0] == &quot;=&quot;) {
+                  $magic = substr($magic, 1);
+               }
+
+               #-- convert type
+               if ($typestr == &quot;string&quot;) {
+                  $magic = stripcslashes($magic);
+                  $len = strlen($magic);
+                  if ($mask) { 
+                     continue;
+                  }
+               }
+               #-- numeric values
+               else {
+
+                  if ((ord($magic[0]) &lt; 48) or (ord($magic[0]) &gt; 57)) {
+#echo &quot;\nmagicnumspec=$line\n&quot;;
+#var_dump($l);
+                     continue;  #-- skip specials like  &gt;, x, &lt;, ^, &amp;
+                  }
+
+                  #-- convert string representation into int
+                  if ((strlen($magic) &gt;= 4) &amp;&amp; ($magic[1] == &quot;x&quot;)) {
+                     $magic = hexdec(substr($magic, 2));
+                  }
+                  elseif ($magic[0]) {
+                     $magic = octdec($magic);
+                  }
+                  else {
+                     $magic = (int) $magic;
+                     if (!$magic) { continue; }   // zero is not a good magic value anyhow
+                  }
+
+                  #-- different types               
+                  switch ($typestr) {
+
+                     case &quot;byte&quot;:
+                        $len = 1;
+                        break;
+                        
+                     case &quot;beshort&quot;:
+                        $magic = ($magic &gt;&gt; 8) | (($magic &amp; 0xFF) &lt;&lt; 8);
+                     case &quot;leshort&quot;:
+                     case &quot;short&quot;:
+                        $len = 2;
+                        break;
+                     
+                     case &quot;belong&quot;:
+                        $magic = (($magic &gt;&gt; 24) &amp; 0xFF)
+                               | (($magic &gt;&gt; 8) &amp; 0xFF00)
+                               | (($magic &amp; 0xFF00) &lt;&lt; 8)
+                               | (($magic &amp; 0xFF) &lt;&lt; 24);
+                     case &quot;lelong&quot;:
+                     case &quot;long&quot;:
+                        $len = 4;
+                        break;
+
+                     default:
+                        // date, ldate, ledate, leldate, beldate, lebelbe...
+                        continue;
+                  }
+               }
+               
+               #-- add to list
+               $mime_magic_data[] = array($pos, $len, $mask, $magic, trim($ct));
+            }
+         }
+#print_r($mime_magic_data);
+      }
+      
+      
+      #-- compare against each entry from the mime magic database
+      foreach ($mime_magic_data as $def) {
+
+         #-- entries are organized as follows
+         list($pos, $len, $mask, $magic, $ct) = $def;
+         
+         #-- ignored entries (we only read first 3K of file for opt. speed)
+         if ($pos &gt;= $maxlen) {
+            continue;
+         }
+
+         $slice = substr($bin, $pos, $len);
+         #-- integer comparison value
+         if ($mask) {
+            $value = hexdec(bin2hex($slice));
+            if (($value &amp; $mask) == $magic) {
+               $type = $ct;
+               break;
+            }
+         }
+         #-- string comparison
+         else {
+            if ($slice == $magic) {
+               $type = $ct;
+               break;
+            }
+         }
+      }// foreach
+      
+      #-- built-in defaults
+      if (!$type) {
+      
+         #-- some form of xml
+         if (strpos($bin, &quot;&lt;&quot;.&quot;?xml &quot;) !== false) {
+            return(&quot;text/xml&quot;);
+         }
+         #-- html
+         elseif ((strpos($bin, &quot;&lt;html&gt;&quot;) !== false) || (strpos($bin, &quot;&lt;HTML&gt;&quot;) !== false)
+         || strpos($bin, &quot;&lt;title&gt;&quot;) || strpos($bin, &quot;&lt;TITLE&gt;&quot;)
+         || (strpos($bin, &quot;&lt;!--&quot;) !== false) || (strpos($bin, &quot;&lt;!DOCTYPE HTML &quot;) !== false)) {
+            $type = &quot;text/html&quot;;
+         }
+         #-- mail msg
+         elseif ((strpos($bin, &quot;\nReceived: &quot;) !== false) || strpos($bin, &quot;\nSubject: &quot;)
+         || strpos($bin, &quot;\nCc: &quot;) || strpos($bin, &quot;\nDate: &quot;)) {
+            $type = &quot;message/rfc822&quot;;
+         }
+         #-- php scripts
+         elseif (strpos($bin, &quot;&lt;&quot;.&quot;?php&quot;) !== false) {
+            return(&quot;application/x-httpd-php&quot;);
+         }
+         #-- plain text, C source or so
+         elseif (strpos($bin, &quot;function &quot;) || strpos($bin, &quot; and &quot;)
+         || strpos($bin, &quot; the &quot;) || strpos($bin, &quot;The &quot;)
+         || (strpos($bin, &quot;/*&quot;) !== false) || strpos($bin, &quot;#include &quot;)) {
+            return(&quot;text/plain&quot;);
+         }
+
+         #-- final fallback
+         else {
+            $type = &quot;application/octet-stream&quot;;
+         }
+      }
+      
+      
+
+      #-- done
+      return $type;
+   }
+}
+
+
+
+#-- gives Media Type for the index numbers getimagesize() returned
+if (!function_exists(&quot;image_type_to_mime_type&quot;)) {
+   define(&quot;IMAGETYPE_GIF&quot;, 1);
+   define(&quot;IMAGETYPE_JPEG&quot;, 2);
+   define(&quot;IMAGETYPE_PNG&quot;, 3);
+   define(&quot;IMAGETYPE_SWF&quot;, 4);
+   define(&quot;IMAGETYPE_PSD&quot;, 5);  // post-4.3 from here ...
+   define(&quot;IMAGETYPE_BMP&quot;, 6);
+   define(&quot;IMAGETYPE_TIFF_II&quot;, 7);
+   define(&quot;IMAGETYPE_TIFF_MM&quot;, 8);
+   define(&quot;IMAGETYPE_JPC&quot;, 9);
+   define(&quot;IMAGETYPE_JP2&quot;, 10);
+   define(&quot;IMAGETYPE_JPX&quot;, 11);
+   define(&quot;IMAGETYPE_JB2&quot;, 12);
+   define(&quot;IMAGETYPE_SWC&quot;, 13);
+   define(&quot;IMAGETYPE_IFF&quot;, 14);
+   define(&quot;IMAGETYPE_WBMP&quot;, 15);
+   define(&quot;IMAGETYPE_XBM&quot;, 16);
+   define(&quot;IMAGETYPE_MNG&quot;, 77);
+   define(&quot;IMAGETYPE_XPM&quot;, 88);
+   define(&quot;IMAGETYPE_ZIF&quot;, 90);
+   define(&quot;IMAGETYPE_PBM&quot;, 80);
+   define(&quot;IMAGETYPE_PGM&quot;, 81);
+   define(&quot;IMAGETYPE_PPM&quot;, 82);
+   function image_type_to_mime_type($id) {
+      static $mime = array(
+         IMAGETYPE_GIF =&gt; &quot;gif&quot;,
+         IMAGETYPE_JPEG =&gt; &quot;jpeg&quot;,
+         IMAGETYPE_PNG =&gt; &quot;png&quot;,
+         IMAGETYPE_SWF =&gt; &quot;application/x-shockwave-flash&quot;,
+         IMAGETYPE_BMP =&gt; &quot;bmp&quot;,
+         IMAGETYPE_JP2 =&gt; &quot;jp2&quot;,
+         IMAGETYPE_WBMP =&gt; &quot;vnd.wap.wbmp&quot;,
+         IMAGETYPE_XBM =&gt; &quot;xbm&quot;,
+         IMAGETYPE_PSD =&gt; &quot;x-photoshop&quot;,
+         IMAGETYPE_TIFF_II =&gt; &quot;tiff&quot;,
+         IMAGETYPE_TIFF_MM =&gt; &quot;tiff&quot;,
+         IMAGETYPE_JPC =&gt; &quot;application/octet-stream&quot;,
+         IMAGETYPE_JP2 =&gt; &quot;jp2&quot;,
+//         IMAGETYPE_JPX =&gt; &quot;&quot;,
+//         IMAGETYPE_JB2 =&gt; &quot;&quot;,
+         IMAGETYPE_SWC =&gt; &quot;application/x-shockwave-flash&quot;,
+         IMAGETYPE_IFF =&gt; &quot;iff&quot;,
+         IMAGETYPE_XPM =&gt; &quot;x-xpm&quot;,
+         IMAGETYPE_ZIF =&gt; &quot;unknown&quot;,
+         IMAGETYPE_MNG =&gt; &quot;video/mng&quot;,
+         IMAGETYPE_PBM =&gt; &quot;x-portable-bitmap&quot;,
+         IMAGETYPE_PGM =&gt; &quot;x-portable-greymap&quot;,
+         IMAGETYPE_PPM =&gt; &quot;x-portable-pixmap&quot;,
+      );
+      if (isset($mime[$id])) {
+         $m = $mime[$id];
+         strpos($m, &quot;/&quot;) || ($m = &quot;image/$m&quot;);
+      }
+      else {
+         $m = &quot;image/unknown&quot;;
+      }
+      return($m);
+   }
+}
+
+#-- still in CVS
+if (!function_exists(&quot;image_type_to_extension&quot;)) {
+   function image_type_to_extension($id, $dot=true) {
+      static $ext = array(
+         0=&gt;false,
+         1=&gt;&quot;gif&quot;, 2=&gt;&quot;jpeg&quot;, 3=&gt;&quot;png&quot;,
+         &quot;swf&quot;, &quot;psd&quot;, &quot;bmp&quot;,
+         &quot;tiff&quot;, &quot;tiff&quot;,
+         &quot;jpc&quot;, &quot;jp2&quot;, &quot;jpx&quot;, &quot;jb2&quot;,
+         &quot;swc&quot;, &quot;wbmp&quot;, &quot;xbm&quot;,
+         77=&gt;&quot;mng&quot;, 88=&gt;&quot;xpm&quot;, 90=&gt;&quot;zif&quot;,
+         80=&gt;&quot;pbm&quot;, 81=&gt;&quot;pgm&quot;, 82=&gt;&quot;ppm&quot;,
+      );
+      $m = $ext[$id];
+      if ($m &amp;&amp; $dot) {
+         $m = &quot;.$m&quot;;
+      }
+      return($m);
+   }
+}
+
+
+
+#-- we need this then, too
+if (!function_exists(&quot;exif_imagetype&quot;)) {
+   function exif_imagetype($fn) {
+      $magic = array(
+         &quot;\211PNG&quot; =&gt; IMAGETYPE_PNG,
+         &quot;\377\330&quot; =&gt; IMAGETYPE_JPEG,
+         &quot;GIF89a&quot; =&gt; IMAGETYPE_GIF,
+         &quot;GIF94z&quot; =&gt; IMAGETYPE_ZIF,
+         &quot;FWS&quot; =&gt; IMAGETYPE_SWF,
+         &quot;II&quot; =&gt; IMAGETYPE_TIFF_II,
+         &quot;MM&quot; =&gt; IMAGETYPE_TIFF_MM,
+         &quot;/* XPM&quot; =&gt; IMAGETYPE_XPM,
+         &quot;BM&quot; =&gt; IMAGETYPE_BMP,  // also for OS/2
+         &quot;\212MNG&quot; =&gt; IMAGETYPE_MNG,
+         &quot;P1&quot; =&gt; IMAGETYPE_PBM,
+         &quot;P4&quot; =&gt; IMAGETYPE_PBM,
+         &quot;P2&quot; =&gt; IMAGETYPE_PGM,
+         &quot;P5&quot; =&gt; IMAGETYPE_PGM,
+         &quot;P3&quot; =&gt; IMAGETYPE_PPM,
+         &quot;P6&quot; =&gt; IMAGETYPE_PPM,
+      );
+      if ($f = fopen($fn, &quot;rb&quot;)) {
+         $bin = fread($f, 8);
+         fclose($f);
+         foreach ($magic as $scn=&gt;$id) {
+            if (!strncmp($bin, $scn, strlen($scn))) {
+               return $id;
+            }
+         }
+      }
+   }
+}
+
+?&gt;
\ No newline at end of file

Added: YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/ext/odbc.php
===================================================================
--- YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/ext/odbc.php	2006-12-09 18:08:01 UTC (rev 2249)
+++ YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/ext/odbc.php	2006-12-09 18:13:10 UTC (rev 2250)
@@ -0,0 +1,113 @@
+&lt;?php
+
+die(&quot;'odbc.php' is incomplete. Don't use this yet.\n&quot;);
+
+/*
+   This is just another SQL interface wrapper. It reimplements the ODBC
+   functions in PHP by itself chaining to PEAR::DB (a double wrapper,
+   to simplify this initial version).
+    - does not use integers as connection_id
+
+   Because any mysql_*() calls are easier replaced with odbc_() funcs,
+   but at the same time offer the same degree of database independence,
+   this can often make more sense than transitioning to PEAR::DB or the
+   ADOdb classes.
+    - PEAR::DB provides the saner OO-interface
+    - ADOdb is slightly faster, but has a less nicely abstracted API
+*/
+
+
+#-- declare odbc interface functions
+if (!function_exists(&quot;odbc_connect&quot;)) {
+
+   #-- load PEAR::DB
+   require_once(&quot;DB.php&quot;);
+
+
+   #-- initialize connection
+   function odbc_connect($dsn, $user, $password, $cursor_type=NULL) {
+
+      #-- mangle $dsn for PEAR
+      $dsn = str_replace(&quot;://&quot;, &quot;://$user:$password@&quot;, $dsn);
+      // ... rename dbtype identifiers
+
+      #-- connect
+      $c = DB::connect($dsn);
+      if (!PEAR::isError($c)) {
+         return($c);
+      }
+   }
+
+   #-- incomplete
+   function odbc_pconnect($dsn, $user, $password, $cursor_type=NULL) {
+      return odbc_connect($dsn, $user, $password, $cursor_type);
+   }
+   
+   #-- end connection
+   function odbc_close($db) {
+      $db-&gt;disconnect();
+   }
+   
+   
+   #-- SQL command execution
+   function odbc_exec($db, $query) {
+      return $db-&gt;query($db);
+   }
+   function odbc_do($db, $query) {
+      return odbc_exec($db, $query);
+   }
+
+
+   #-- sql pre-parsing
+   function odbc_prepare($db, $query) {
+      return( array($db, $db-&gt;prepare($db)) );
+   }
+   #-- and execution of prepared query
+   function odbc_execute($pq, $args=NULL) {
+      return $pq[0]-&gt;execute($pq[1], $args);
+   }
+
+
+   #-- return result row
+   function odbc_fetch_array($res) {
+      return $res-&gt;fetchRow(DB_FETCHMODE_ASSOC);
+   }
+   function odbc_fetch_row($res) {
+      return $res-&gt;fetchRow(DB_FETCHMODE_ORDERED);
+   }
+   function odbc_fetch_object($res) {
+      return $res-&gt;fetchRow(DB_FETCHMODE_OBJECT);
+   }
+   function odbc_fetch_into($res, $count, &amp;$array) {
+      $array = array();
+      while ($count--) {
+         $array[] =  $res-&gt;fetchRow(DB_FETCHMODE_ORDERED);
+      }
+   }
+   
+   
+   #-- more functions on result sets
+   function odbc_free_result(&amp;$res) {
+      $res-&gt;free();
+      $res = NULL;
+   }
+   function odbc_next_result($res) {
+      return $res-&gt;nextResult();
+   }
+   function odbc_num_fields($res) {
+      return $res-&gt;numCols();
+   }
+   function odbc_num_rows($res) {
+      return $res-&gt;numRows();
+   }
+   
+   
+   #-- and there's more
+   //...
+
+   
+
+}
+
+
+?&gt;
\ No newline at end of file

Added: YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/ext/old.php
===================================================================
--- YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/ext/old.php	2006-12-09 18:08:01 UTC (rev 2249)
+++ YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/ext/old.php	2006-12-09 18:13:10 UTC (rev 2250)
@@ -0,0 +1,399 @@
+&lt;?php
+/*
+   Here we collect PHP functions for versions before 4.1 - it should be
+   noted that 4.0.x versions can't be made compatible with newer
+   versions anyhow, because the newer superglobals ($_GET, $_REQUEST) are
+   missing. Most of this is untested.
+   Have a look at PEAR::PHP_Compat for emulation of some of these (it's
+   not complete in this regard, too).
+*/
+
+#---------------------------------------------------------------- 4.0.7 ---
+
+#-- simulate superglobals
+# you still had to put &quot;global $_REQUEST,$_GET,...&quot; into any function that
+# used them - so this workaround is not all too useful anyhow, you should
+# not accept PHP versions prior 4.0.7 for your scripts in any case!
+if (!isset($GLOBALS[&quot;_REQUEST&quot;])) {
+   $GLOBALS[&quot;_GET&quot;] = &amp; $HTTP_GET_VARS;
+   $GLOBALS[&quot;_POST&quot;] = &amp; $HTTP_POST_VARS;
+   $GLOBALS[&quot;_SERVER&quot;] = &amp; $HTTP_SERVER_VARS;
+   $GLOBALS[&quot;_ENV&quot;] = &amp; $HTTP_ENV_VARS;
+   $GLOBALS[&quot;_COOKIE&quot;] = &amp; $HTTP_COOKIE_VARS;
+   $GLOBALS[&quot;_FILES&quot;] = &amp; $HTTP_POST_FILES;
+   $GLOBALS[&quot;_REQUEST&quot;] = array_merge($HTTP_GET_VARS, $HTTP_POST_VARS, $HTTP_COOKIE_VARS);
+}
+
+
+#---------------------------------------------------------------- 4.0.6 ---
+
+
+#-- uses callback function to remove entries from array
+if (!function_exists(&quot;array_filter&quot;)) {
+   function array_filter($array, $callback=&quot;is_int&quot;) {
+      foreach ($array as $key=&gt;$val) {
+         if (!call_user_func_array($callback, array($val))) {
+            unset($array[$key]);
+         }
+      }
+      return($array);
+   }
+}
+
+
+#-- uses callback function to change array values, multiple input arrays
+if (!function_exists(&quot;array_map&quot;)) {
+   function array_map() {
+      $arrays = get_func_args();
+      $callback = shift($arrays);
+      $r = &amp;$arrays[0];
+      foreach ($r as $key=&gt;$val) {
+         $val = call_user_func_array($callback, $arrays);
+         $r[$key] = $val;
+      }
+      return($r);
+   }
+}
+
+
+#-- checks for existence or only syntax of function or obj/class+method name
+if (!function_exists(&quot;is_callable&quot;)) {
+   function is_callable($var, $syntax_only=0) {
+      $a = get_func_args();
+      if (count($a) &gt;= 3) {
+         $fin = &amp; $a[2];
+      }
+
+      #-- class/object+method
+      if (is_array($var)) {
+         if (count($var)!=2) {
+            return false;
+         }
+         list($obj, $method) = $var;
+         $class = $obj;
+         if (is_object($obj)) {
+            $class = get_class($obj);
+         }
+
+         if ($syntax_only) {
+            $r = preg_match('/^\w+$/', $method);
+            if (!is_object($obj)) {
+               $r = $r &amp;&amp; preg_match('/^\w+$/', $obj);
+            }
+         }
+         else {
+            if (is_object($obj)) {
+               $r = method_exists($obj, $method);
+            }
+            else {
+               $all = get_class_methods($obj);
+               $r = in_array($method, $all);
+            }
+         }
+         if ($r) { $fin = strtolower(&quot;$class:$method&quot;); }
+      }
+      #-- simple function name
+      elseif (is_string($var)) {
+         if ($syntax_only) {
+            $r = preg_match('/^\w+$/', $var);
+         }
+         else {
+            $r = function_exists($var);
+         }
+         if ($r) { $fin = strtolower($var); }
+      }
+      #-- ooops
+      else {
+         $r = false;
+      }
+      return $r;
+   }
+}
+
+
+
+
+#---------------------------------------------------------------- 4.0.5 ---
+# chroot
+
+
+#-- return index of value in array
+if (!function_exists(&quot;array_search&quot;)) {
+   function array_search($value, $array, $strict=false) {
+      $strict = $strict ? true : false;
+      foreach ($array as $key=&gt;$v) {
+         if ($strict&amp;&amp;($v===$value) || !$strict&amp;&amp;($v==$value)) {
+            return($key);
+         }
+      }
+      return(NULL);  // PHP prior 4.2 also did so
+   }
+}
+
+
+#-- recursively collapse array into one value (via user callback)
+if (!function_exists(&quot;array_reduce&quot;)) {
+   function array_reduce($array, $callback, $value=NULL) {
+      foreach ($array as $v) {
+         if (is_array($v)) {
+            $v = array_reduce($v, $callback);
+         }
+         else {
+            $v = call_user_func_array($callback, array($value, $v));
+         }
+         $value = $v;
+      }
+      return($value);
+   }
+}
+
+
+#-- checks variable to be of a simple type
+if (!function_exists(&quot;is_scalar&quot;)) {
+   function is_scalar($var) {
+      return( !is_array($var) &amp;&amp; !is_object($var) );
+   }
+}
+
+#-- only static value (mix of C/English/European/US)
+if (!function_exists(&quot;localeconv&quot;)) {
+   function localeconv() {
+      return array (
+        'decimal_point' =&gt; '.',
+        'thousands_sep' =&gt; '',
+        'int_curr_symbol' =&gt; 'EUR ',   // more international than USD
+        'currency_symbol' =&gt; '&#164;',      // unnamed/trans currency symbol
+        'mon_decimal_point' =&gt; '.',
+        'mon_thousands_sep' =&gt; ',',
+        'positive_sign' =&gt; '',
+        'negative_sign' =&gt; '-',
+        'int_frac_digits' =&gt; 2,
+        'frac_digits' =&gt; 2,
+        'p_cs_precedes' =&gt; 1,
+        'p_sep_by_space' =&gt; 0,
+        'n_cs_precedes' =&gt; 1,
+        'n_sep_by_space' =&gt; 0,
+        'p_sign_posn' =&gt; 1,
+        'n_sign_posn' =&gt; 1,
+        'grouping' =&gt; array (0=&gt;3, 1=&gt;3,),
+        'mon_grouping' =&gt; array(0=&gt;3, 1=&gt;3,),
+      );
+   }
+}
+
+
+#-- function by name
+if (!function_exists(&quot;call_user_func_array&quot;)) {
+   function call_user_func_array($callback, $param_array=array()) {
+      if ($param_array) {
+         $param_array = array_values($param_array);
+         $params = &quot;'&quot; . implode(&quot;','&quot;, $param_array) . &quot;'&quot;;
+      }
+      if (is_array($callback)) {
+         $obj = &amp;$callback[0];
+         $method = $callback[1];
+         if (!method_exists($obj, $method)) {
+            trigger_error(&quot;call_user_method_array: method '$method' does not exist&quot;, E_ERROR);
+         }
+         elseif (is_object($obj)) {
+            eval(&quot;return \$obj-&gt;$method($params);&quot;);
+         }
+         else {
+            eval(&quot;return $obj::$method($params);&quot;);
+         }
+      }
+      elseif (!function_exists(&quot;$callback&quot;)) {
+         trigger_error(&quot;call_user_func_array: function '$method' does not exist&quot;, E_ERROR);
+      }
+      else {
+         switch (count($param_array)) {
+            case 0:
+               return $callback();
+            case 1:
+               return $callback($param_array[0]);
+            case 2:
+               return $callback($param_array[0], $param_array[1]);
+            case 3:
+               return $callback($param_array[0], $param_array[1], $param_array[2]);
+            case 4:
+               return $callback($param_array[0], $param_array[1], $param_array[2], $param_array[3]);
+            default:
+               eval(&quot;return $callback($params);&quot;);
+         }
+      }
+   }
+   function call_user_method_array($method, &amp;$obj, $param_array=array()) {
+      call_user_func_array(array(&amp;$obj, $method), $param_array);
+   }
+}
+
+
+
+
+#---------------------------------------------------------------- 4.0.4 ---
+
+
+
+#-- adds all values of given array into total sum
+if (!function_exists(&quot;array_sum&quot;)) {
+   function array_sum($array) {
+      $sum = 0;
+      foreach ($array as $val) {
+         $sum += $val;
+      }
+      return $sum;
+   }
+}
+
+#-- value of constant (if their name was returned as string from somewhere)
+if (!function_exists(&quot;constant&quot;)) {
+   function constant($name) {
+      if (defined($name)) {
+         eval(&quot;return $name&quot;);
+      }
+      else {
+         return NULL;
+      }
+   }
+}
+
+#-- more a language construct
+if (!function_exists(&quot;is_null&quot;)) {
+   function is_null($var) {
+      return($var === NULL);
+   }
+}
+
+
+
+#---------------------------------------------------------------- 4.0.3 ---
+# register_tick_function
+# unregister_tick_function
+
+if (!function_exists(&quot;pathinfo&quot;)) {
+   function pathinfo($fn) {
+      preg_match(&quot;#^(?:(.+)/)?([^/]+?(?:\.([^/\.]+))?)$#&quot;, $fn, $uu);
+      return array(
+         &quot;dirname&quot; =&gt; $uu[1],
+         &quot;basename&quot; =&gt; $uu[2],
+         &quot;extension&quot; =&gt; $uu[3],
+      );
+   }
+}
+
+if (!function_exists(&quot;escapeshellarg&quot;)) {
+   function escapeshellarg($arg) {
+      $arg = str_replace(&quot;'&quot;, &quot;'\\''&quot;, $arg);
+      return &quot;'$arg'&quot;;
+   }
+}
+
+if (!function_exists(&quot;is_uploaded_file&quot;)) {
+   function is_uploaded_file($fn) {
+      ( $dir = get_cfg_var(&quot;upload_tmp_dir&quot;) )
+       or
+      ( $dir = dirname(tempnam(&quot;&quot;, &quot;&quot;)) );
+      return( realpath($dir) == realpath(dirname($fn)) );
+   }
+}
+
+if (!function_exists(&quot;move_uploaded_file&quot;)) {
+   function move_uploaded_file($fn, $dest) {
+      if (is_uploaded_file($fn)) {
+         return copy($fn, $dest) &amp;&amp; unlink($fn);
+      }
+   }
+}
+
+
+#---------------------------------------------------------------- 4.0.2 ---
+# ob_get_length
+
+
+
+if (!function_exists(&quot;strncasecmp&quot;)) {
+   function strncasecmp($str1, $str2, $len=0) {
+      if ($len &gt; 0) {
+         $str1 = substr($str1, 0, $len);
+         $str2 = substr($str2, 0, $len);
+      }
+      return strcasecmp($str1, $str2);
+   }
+}
+
+
+if (!function_exists(&quot;wordwrap&quot;)) {
+   function wordwrap($text, $width=75, $break=&quot;\n&quot;, $hardcut=0) {
+      $out = &quot;&quot;;
+      foreach (explode(&quot;\n&quot;, $text) as $line) {
+         if ($out) {
+            $out .= &quot;\n&quot;;
+         }
+         while (strlen($line)) {
+            if ($hardcut) {
+               $l = $width;
+            }
+            else {
+               $l = strrpos(substr($text, 0, $width), &quot; &quot;);
+               if ($l &amp;&amp; ($l &lt; strlen($line))) {
+                  $l = strlen($line);
+               }
+               if ($l === false) {
+                  $l = $width;
+               }
+            }
+            $out .= substr($line, 0, $l);
+            $out .= &quot;\n&quot;;
+            $line = substr(0, $l);
+         }
+      }
+      return($out);
+   }
+}
+
+if (!function_exists(&quot;php_uname&quot;)) {
+   function php_uname($mode=&quot;a&quot;) {
+      switch ($mode) {
+         case &quot;s&quot;:  $p = &quot;--kernel-name&quot;;  break;
+         case &quot;n&quot;:  $p = &quot;--node-name&quot;;  break;
+         case &quot;r&quot;:  $p = &quot;--release&quot;;  break;
+         case &quot;v&quot;:  $p = &quot;--kernel-version&quot;;  break;
+         case &quot;m&quot;:  $p = &quot;--machine&quot;;  break;
+         default:  $p = &quot;--all&quot;;  break;
+      }
+      return `uname $p`;
+   }
+}
+
+
+
+#---------------------------------------------------------------- 4.0.1 ---
+# levensth
+# fflush() - unimplementable
+# array_unique
+# array_diff
+# array_intersect
+# array_merge_recursive
+# crc32
+# fscanf
+# sscanf
+# str_pad
+# set_file_buffer
+# spliti
+
+if (!function_exists(&quot;php_sapi_name&quot;)) {
+   function php_sapi_name() {
+      if (isset($_ENV[&quot;CGI_INTERFACE&quot;])) {
+         return &quot;cgi&quot;;
+      }
+      elseif (strpos($_ENV[&quot;SERVER_SOFTWARE&quot;], &quot;Apache&quot;) !== false) {
+         return &quot;apache&quot;;
+      }
+      // ...
+      else {
+         return &quot;cgi&quot;;  // the silly &quot;cli&quot; variation didn't exist before 4.2
+      }
+   }
+}
+
+?&gt;
\ No newline at end of file

Added: YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/ext/openssl.php
===================================================================
--- YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/ext/openssl.php	2006-12-09 18:08:01 UTC (rev 2249)
+++ YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/ext/openssl.php	2006-12-09 18:13:10 UTC (rev 2250)
@@ -0,0 +1,5 @@
+&lt;?php
+/*
+   Ok, that's a joke. (Not that this wasn't possible, though ...)
+*/
+?&gt;
\ No newline at end of file

Added: YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/ext/posix.php
===================================================================
--- YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/ext/posix.php	2006-12-09 18:08:01 UTC (rev 2249)
+++ YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/ext/posix.php	2006-12-09 18:13:10 UTC (rev 2250)
@@ -0,0 +1,40 @@
+&lt;?php
+/*
+   POSIX subsystem functions are emulated using regular commandline
+   utilities or by invoking Perl.  Of course not the full spectrum
+   of features can be simulated this way.  And normally all these
+   functions should be present.
+*/
+
+if (!function_exists(&quot;posix_mkfifo&quot;) &amp;&amp; strlen($_ENV[&quot;SHELL&quot;]) &amp;&amp; !ini_get(&quot;safe_mode&quot;)) {
+
+   function posix_mkfifo($pathname, $mode=0400) {
+      $cmd = &quot;/usr/bin/mkfifo -m 0&quot; . decoct($mode) . &quot; &quot; . escape_shell_arg($pathname);
+      exec($cmd, $uu, $error);
+      return(!$error);
+   }
+   
+   function posix_getcwd() {
+      return realpath(getcwd());
+   }
+   
+   function posix_kill($pid, $sig) {
+      $cmd = &quot;kill -&quot; . ((int)$sig) . &quot; &quot; . ((int)$pid);
+      exec($cmd, $uu, $error);
+      return(!$error);
+   }
+
+   function posix_uname() {
+      return array(
+         &quot;sysname&quot; =&gt; `/bin/uname -s`,
+         &quot;nodename&quot; =&gt; `/bin/uname -n`,
+         &quot;release&quot; =&gt; `/bin/uname -r`,
+         &quot;version&quot; =&gt; `/bin/uname -v`,
+         &quot;machine&quot; =&gt; `/bin/uname -m`,
+         &quot;domainname&quot; =&gt; `/bin/domainname`,
+      );
+   }
+}
+
+
+?&gt;
\ No newline at end of file

Added: YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/_listemulated
===================================================================
--- YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/_listemulated	2006-12-09 18:08:01 UTC (rev 2249)
+++ YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/_listemulated	2006-12-09 18:13:10 UTC (rev 2250)
@@ -0,0 +1,10 @@
+&lt;?php
+
+include(&quot;../upgrade.php&quot;);
+
+$r = get_defined_functions();
+$r = $r[&quot;user&quot;];
+echo &quot;emulated functions are:\n&quot;;
+print_r($r);
+
+?&gt;
\ No newline at end of file

Added: YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/_runparts
===================================================================
--- YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/_runparts	2006-12-09 18:08:01 UTC (rev 2249)
+++ YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/_runparts	2006-12-09 18:13:10 UTC (rev 2250)
@@ -0,0 +1,28 @@
+#!/bin/bash
+
+#-- params
+if [ -z &quot;$1&quot; ]
+then
+   echo &quot;syntax:  _runparts [php412] [php501]  | more&quot;
+   echo &quot;Runs all PHP scripts in the tests/ directory with two interpreter versions&quot;
+   echo &quot;side by side, for comparison. If you don't have two of them installed, you&quot;
+   echo &quot;could simply specify 'cat' or 'false' as the second argument.&quot;
+else
+
+   #-- go
+   cd `dirname $0`
+   OLD=$1
+   NEW=$2
+   [ -z &quot;$NEW&quot; ] &amp;&amp; NEW=&quot;cat&quot;
+   for SCRIPT in *
+   do
+      $OLD $SCRIPT | tr -d &quot;\r&quot; | fmt -w 36 -s &gt; /tmp/1
+      $NEW $SCRIPT | tr -d &quot;\r&quot; | fmt -w 36 -s &gt; /tmp/2
+      echo &quot;-----------------------------------------------------------------&quot;
+      echo &quot;[32m$SCRIPT[37m&quot;
+      echo &quot;-----------------------------------------------------------------&quot;
+      pr -m --columns=2 -t  /tmp/1 /tmp/2
+      echo &quot;--&quot;
+   done
+
+fi   

Added: YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/array_change_key_case
===================================================================
--- YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/array_change_key_case	2006-12-09 18:08:01 UTC (rev 2249)
+++ YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/array_change_key_case	2006-12-09 18:13:10 UTC (rev 2250)
@@ -0,0 +1,13 @@
+&lt;?php
+
+include(&quot;../upgrade.php&quot;);
+
+$a = array(&quot;low&quot;=&gt;32, &quot;CamelCase&quot;=&gt;&quot;Wiki&quot;);
+print_r($a);
+echo &quot;\n&quot;;
+$a = array_change_key_case($a, CASE_UPPER);
+print_r($a);
+
+?&gt;
+
+

Added: YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/array_chunk
===================================================================
--- YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/array_chunk	2006-12-09 18:08:01 UTC (rev 2249)
+++ YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/array_chunk	2006-12-09 18:13:10 UTC (rev 2250)
@@ -0,0 +1,12 @@
+&lt;?php
+
+include(&quot;../upgrade.php&quot;);
+
+$a = array(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;);
+$r = array_chunk($a, 2, 1);
+echo 'array_chunk($a, 2, 1) = ';
+print_r($r);
+
+?&gt;
+
+

Added: YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/array_combine
===================================================================
--- YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/array_combine	2006-12-09 18:08:01 UTC (rev 2249)
+++ YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/array_combine	2006-12-09 18:13:10 UTC (rev 2250)
@@ -0,0 +1,19 @@
+&lt;?php
+
+include(&quot;../upgrade.php&quot;);
+
+
+?&gt;
+$a = array('green', 'red', 'yellow');
+$b = array('avocado', 'apple', 'banana');
+$c = array_combine($a, $b);
+
+print_r($c);
+&lt;?php
+$a = array('green', 'red', 'yellow');
+$b = array('avocado', 'apple', 'banana');
+$c = array_combine($a, $b);
+
+print_r($c);
+?&gt;
+

Added: YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/array_diff_assoc
===================================================================
--- YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/array_diff_assoc	2006-12-09 18:08:01 UTC (rev 2249)
+++ YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/array_diff_assoc	2006-12-09 18:13:10 UTC (rev 2250)
@@ -0,0 +1,18 @@
+&lt;?php
+
+include(&quot;../upgrade.php&quot;);
+
+
+?&gt;
+$a = array(5=&gt;5, 14=&gt;10000, &quot;ccc&quot;=&gt;555, 555);
+$b = array(5=&gt;5, 13=&gt;10000,         15=&gt;555);
+$res = array_diff_assoc($a, $b);
+
+print_r($res);
+&lt;?php
+$a = array(5=&gt;5, 14=&gt;10000, &quot;ccc&quot;=&gt;555, 555);
+$b = array(5=&gt;5, 13=&gt;10000,         15=&gt;555);
+$res = array_diff_assoc($a, $b);
+print_r($res);
+?&gt;
+

Added: YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/array_fill
===================================================================
--- YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/array_fill	2006-12-09 18:08:01 UTC (rev 2249)
+++ YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/array_fill	2006-12-09 18:13:10 UTC (rev 2250)
@@ -0,0 +1,10 @@
+&lt;?php
+
+include(&quot;../upgrade.php&quot;);
+
+$a = 17;
+$a = array_fill(1, 17, $a);
+print_r($a);
+
+?&gt;
+

Added: YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/array_intersect_assoc
===================================================================
--- YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/array_intersect_assoc	2006-12-09 18:08:01 UTC (rev 2249)
+++ YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/array_intersect_assoc	2006-12-09 18:13:10 UTC (rev 2250)
@@ -0,0 +1,17 @@
+&lt;?php
+
+include(&quot;../upgrade.php&quot;);
+
+?&gt;
+$a = array(5=&gt;5, 14=&gt;10000, &quot;ccc&quot;=&gt;555, 555);
+$b = array(5=&gt;5, 13=&gt;10000, 555);
+$res = array_intersect_assoc($a, $b);
+
+print_r($res);
+&lt;?php
+$a = array(5=&gt;5, 14=&gt;10000, &quot;ccc&quot;=&gt;555, 555);
+$b = array(5=&gt;5, 13=&gt;10000, 555);
+$res = array_intersect_assoc($a, $b);
+print_r($res);
+?&gt;
+

Added: YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/array_udiff_uassoc
===================================================================
--- YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/array_udiff_uassoc	2006-12-09 18:08:01 UTC (rev 2249)
+++ YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/array_udiff_uassoc	2006-12-09 18:13:10 UTC (rev 2250)
@@ -0,0 +1,54 @@
+&lt;?php
+
+include(&quot;../ext/array.php&quot;);
+
+#-- from manual --
+
+class cr {
+    var $priv_member;
+    function cr($val)
+    {
+        $this-&gt;priv_member = $val;
+    }
+}
+    function comp_func_cr($a, $b)
+    {
+        if ($a-&gt;priv_member === $b-&gt;priv_member) return 0;
+        return ($a-&gt;priv_member &gt; $b-&gt;priv_member)? 1:-1;
+    }
+    
+    function comp_func_key($a, $b)
+    {
+        if ($a === $b) return 0;
+        return ($a &gt; $b)? 1:-1;
+    }
+
+
+$a = array(
+   &quot;0.1&quot; =&gt; new cr(9),
+   &quot;0.5&quot; =&gt; new cr(12),
+   0 =&gt; new cr(23),
+   1=&gt; new cr(4),
+   2 =&gt; new cr(-15),
+);
+$b = array(
+   &quot;0.2&quot; =&gt; new cr(9),
+   &quot;0.5&quot; =&gt; new cr(22),
+   0 =&gt; new cr(3),
+   1=&gt; new cr(4),
+   2 =&gt; new cr(-15),
+);
+
+$result = array_udiff_uassoc($a, $b, &quot;comp_func_cr&quot;, &quot;comp_func_key&quot;);
+$expected = array (
+  '0.1' =&gt; new cr(9),
+  '0.5' =&gt; new cr(12),
+  0 =&gt; new cr(23),
+);
+print_r($result);
+
+if ($result == $expected) {
+   echo &quot;\n--&gt; works correctly\n&quot;;
+}
+
+?&gt;
\ No newline at end of file

Added: YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/array_walk_recursive
===================================================================
--- YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/array_walk_recursive	2006-12-09 18:08:01 UTC (rev 2249)
+++ YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/array_walk_recursive	2006-12-09 18:13:10 UTC (rev 2250)
@@ -0,0 +1,26 @@
+&lt;?php
+
+include(&quot;../upgrade.php&quot;);
+
+$a = array(
+  &quot;x1&quot;,
+  &quot;x2\\&quot;,
+  array(
+     &quot;x3aaa1&quot;,
+     &quot;x3a\\a2&quot;,
+  ),
+  &quot;x4\+end&quot;,
+);
+
+echo &quot;__start:\n&quot;;
+array_walk_recursive($a, &quot;outp&quot;);
+
+function outp(&amp;$a) {
+   var_dump($a);
+   $a = stripslashes($a);
+}
+
+echo &quot;\n__result:\n&quot;;
+var_dump($a);
+
+?&gt;
\ No newline at end of file

Added: YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/base16
===================================================================
--- YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/base16	2006-12-09 18:08:01 UTC (rev 2249)
+++ YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/base16	2006-12-09 18:13:10 UTC (rev 2250)
@@ -0,0 +1,8 @@
+&lt;?php
+include &quot;../ext/base64.php&quot;;
+
+echo base16_encode(&quot;123&quot;);
+echo &quot;\n&quot;;
+echo base16_decode(&quot;313233&quot;);
+
+?&gt;

Added: YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/bcmath
===================================================================
--- YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/bcmath	2006-12-09 18:08:01 UTC (rev 2249)
+++ YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/bcmath	2006-12-09 18:13:10 UTC (rev 2250)
@@ -0,0 +1,14 @@
+&lt;?php
+
+include(&quot;../ext/bcmath.php&quot;);
+
+bcscale(50);
+echo &quot;1/17=&quot;;
+echo bcdiv(&quot;1&quot;, &quot;17&quot;);
+echo &quot;\n&quot;;
+
+echo &quot;2^55%77777=&quot;;
+echo bcpowmod(2, 55, 77777);
+echo &quot;\n&quot;;
+
+?&gt;
\ No newline at end of file

Added: YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/class_parents
===================================================================
--- YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/class_parents	2006-12-09 18:08:01 UTC (rev 2249)
+++ YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/class_parents	2006-12-09 18:13:10 UTC (rev 2250)
@@ -0,0 +1,15 @@
+&lt;?php
+
+include(&quot;../upgrade.php&quot;);
+
+class a {}
+class x extends a {}
+class y extends x {}
+class z extends a {}
+class eve extends y {}
+
+$y = new y;
+$r = class_parents($y);
+print_r($r);
+
+?&gt;
\ No newline at end of file

Added: YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/file_put_contents
===================================================================
--- YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/file_put_contents	2006-12-09 18:08:01 UTC (rev 2249)
+++ YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/file_put_contents	2006-12-09 18:13:10 UTC (rev 2250)
@@ -0,0 +1,17 @@
+&lt;?php
+
+include(&quot;../upgrade.php&quot;);
+
+$FN = &quot;/tmp/test_fpc&quot;;
+
+echo 'file_put_contents(&quot;/tmp/test_fpc&quot;, &quot;abc-test-text&quot;);'.&quot;\n&quot;;
+file_put_contents($FN, &quot;abc-test-text&quot;);
+
+echo 'echo file_get_contents(&quot;/tmp/test_fpc&quot;);'.&quot;\n =&gt; &quot;;
+echo file_get_contents($FN);
+
+unlink($FN);
+
+?&gt;
+
+

Added: YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/floatval
===================================================================
--- YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/floatval	2006-12-09 18:08:01 UTC (rev 2249)
+++ YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/floatval	2006-12-09 18:13:10 UTC (rev 2250)
@@ -0,0 +1,8 @@
+floatval(&quot;1234.567abc&quot;) = &lt;?php
+
+include(&quot;../upgrade.php&quot;);
+
+$str = &quot;1234.567abc&quot;;
+echo floatval($str);
+
+?&gt;
\ No newline at end of file

Added: YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/fmod
===================================================================
--- YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/fmod	2006-12-09 18:08:01 UTC (rev 2249)
+++ YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/fmod	2006-12-09 18:13:10 UTC (rev 2250)
@@ -0,0 +1,8 @@
+&lt;?php
+
+include(&quot;../upgrade.php&quot;);
+
+$r = fmod(5.7, 1.3);
+echo &quot;fmod(5.7, 1.3) = $r\n&quot;;
+
+?&gt;
\ No newline at end of file

Added: YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/fnmatch
===================================================================
--- YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/fnmatch	2006-12-09 18:08:01 UTC (rev 2249)
+++ YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/fnmatch	2006-12-09 18:13:10 UTC (rev 2250)
@@ -0,0 +1,17 @@
+&lt;?php
+
+include(&quot;../upgrade.php&quot;);
+
+$text = &quot;Some text goes here...&quot;;
+echo '$text = &quot;Some text goes here...&quot;;';
+echo &quot;\nfnmatch('go*', $text) = &quot;. (fnmatch('go*', $text) ?1:0);
+echo &quot;\nfnmatch('*go', $text) = &quot;. (fnmatch('*go', $text) ?1:0);
+echo &quot;\nfnmatch('*go*', $text) = &quot;. (fnmatch('*go*', $text) ?1:0);
+echo &quot;\nfnmatch('*te?x*', $text) = &quot;. (fnmatch('*te?x*', $text) ?1:0);
+echo &quot;\nfnmatch('*te?t*', $text) = &quot;. (fnmatch('*te?t*', $text) ?1:0);
+echo &quot;\nfnmatch('So?m*', $text) = &quot;. (fnmatch('So?m*', $text) ?1:0);
+echo &quot;\nfnmatch('So*m*', $text) = &quot;. (fnmatch('*So*m*', $text) ?1:0);
+
+?&gt;
+
+

Added: YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/get_headers
===================================================================
--- YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/get_headers	2006-12-09 18:08:01 UTC (rev 2249)
+++ YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/get_headers	2006-12-09 18:13:10 UTC (rev 2250)
@@ -0,0 +1,8 @@
+&lt;?php
+
+include(&quot;../upgrade.php&quot;);
+
+$r = get_headers(&quot;<A HREF="http://localhost/">http://localhost/</A>&quot;);
+print_r($r);
+
+?&gt;
\ No newline at end of file

Added: YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/gettext
===================================================================
--- YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/gettext	2006-12-09 18:08:01 UTC (rev 2249)
+++ YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/gettext	2006-12-09 18:13:10 UTC (rev 2250)
@@ -0,0 +1,15 @@
+&lt;?php
+
+include(&quot;../ext/gettext.php&quot;);
+
+#-- load
+echo &quot;bindtextdomain(\&quot;tar\&quot;);\n&quot;;
+bindtextdomain(&quot;tar&quot;);
+textdomain(&quot;tar&quot;);
+
+#-- query
+echo &quot;_(\&quot;stdin\&quot;) == \&quot;&quot;;
+echo _(&quot;stdin&quot;);
+echo &quot;\&quot;\n&quot;;
+
+?&gt;
\ No newline at end of file

Added: YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/glob
===================================================================
--- YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/glob	2006-12-09 18:08:01 UTC (rev 2249)
+++ YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/glob	2006-12-09 18:13:10 UTC (rev 2250)
@@ -0,0 +1,11 @@
+&lt;?php
+
+include(&quot;../upgrade.php&quot;);
+
+echo 'glob(&quot;../tests/*m*&quot;) = ';
+$r = glob(&quot;../tests/*m*&quot;);
+print_r($r);
+
+
+?&gt;
+

Added: YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/gzdecode
===================================================================
--- YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/gzdecode	2006-12-09 18:08:01 UTC (rev 2249)
+++ YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/gzdecode	2006-12-09 18:13:10 UTC (rev 2250)
@@ -0,0 +1,15 @@
+&lt;?php
+
+include(&quot;../upgrade.php&quot;);
+
+$orig =
+&quot;ORIGINAL_TEXT.................................................................................................................................................................................................................................End&quot;;
+$gz = gzencode($orig);
+echo &quot;strlen(\$orig) == &quot;.strlen($orig).&quot;\n&quot;;
+echo &quot;strlen(\$gz) == &quot;.strlen($gz).&quot;\n...\n&quot;;
+
+$text = gzdecode($gz);
+echo &quot;gzdecode(\$gz) = \&quot;$text\&quot;\n\n&quot;;
+
+
+?&gt;
\ No newline at end of file

Added: YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/headers_list
===================================================================
--- YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/headers_list	2006-12-09 18:08:01 UTC (rev 2249)
+++ YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/headers_list	2006-12-09 18:13:10 UTC (rev 2250)
@@ -0,0 +1,16 @@
+&lt;?php
+
+include(&quot;../upgrade.php&quot;);
+
+header(&quot;Content-Type: text/x-display-on-console&quot;);
+header(&quot;X-Server: upgradephp-test/2.75.01d&quot;);
+echo &quot;header(\&quot;...\&quot;);\n\n&quot;;
+
+echo &quot;\$r = headers_list();\n\n&quot;;
+error_reporting(E_ALL);
+$r = headers_list();
+print_r($r);
+
+?&gt;
+
+

Added: YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/html_entity_decode
===================================================================
--- YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/html_entity_decode	2006-12-09 18:08:01 UTC (rev 2249)
+++ YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/html_entity_decode	2006-12-09 18:13:10 UTC (rev 2250)
@@ -0,0 +1,10 @@
+&lt;?php
+
+include(&quot;../upgrade.php&quot;);
+
+echo 'html_entity_decode(&quot;&lt;&amp;&gt;&auml;&szlig;&quot;) = ';
+echo html_entity_decode(&quot;&lt;&amp;&gt;&auml;&szlig;&quot;);
+
+?&gt;
+
+

Added: YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/http_build_query
===================================================================
--- YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/http_build_query	2006-12-09 18:08:01 UTC (rev 2249)
+++ YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/http_build_query	2006-12-09 18:13:10 UTC (rev 2250)
@@ -0,0 +1,15 @@
+&lt;?php
+
+include(&quot;../upgrade.php&quot;);
+
+
+?&gt;
+$data = array('foo', 'bar', &quot;sub&quot;=&gt;array('b', 'c'), 'cow' =&gt; 'milk', 'php' =&gt;'hypertext processor');
+echo http_build_query($data, &quot;num_&quot;);
+
+&lt;?php
+$data = array('foo', 'bar', &quot;sub&quot;=&gt;array('b', 'c'), 'cow' =&gt; 'milk', 'php' =&gt;'hypertext processor');
+echo http_build_query($data, &quot;num_&quot;);
+?&gt;
+
+

Added: YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/is_a
===================================================================
--- YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/is_a	2006-12-09 18:08:01 UTC (rev 2249)
+++ YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/is_a	2006-12-09 18:13:10 UTC (rev 2250)
@@ -0,0 +1,15 @@
+&lt;?php
+
+include(&quot;../upgrade.php&quot;);
+
+class y {}
+class x extends y {}
+$x = new x;
+
+echo is_a($x, &quot;x&quot;) ? &quot;works&quot; : &quot;failed&quot;;
+echo &quot;\n&quot;;
+echo is_a($x, &quot;y&quot;) ? &quot;works&quot; : &quot;failed&quot;;
+
+?&gt;
+
+

Added: YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/md5_file
===================================================================
--- YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/md5_file	2006-12-09 18:08:01 UTC (rev 2249)
+++ YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/md5_file	2006-12-09 18:13:10 UTC (rev 2250)
@@ -0,0 +1,9 @@
+md5_file(__FILE__) = &lt;?php
+
+include(&quot;../upgrade.php&quot;);
+
+echo md5_file(__FILE__);
+
+?&gt;
+
+

Added: YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/mhash
===================================================================
--- YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/mhash	2006-12-09 18:08:01 UTC (rev 2249)
+++ YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/mhash	2006-12-09 18:13:10 UTC (rev 2250)
@@ -0,0 +1,27 @@
+&lt;?php
+
+include(&quot;../upgrade.php&quot;);
+
+echo &quot;HMAC-MD5 test cases (RFC2104/page 9):\n\n&quot;;
+
+# 1
+$k = str_pad(&quot;&quot;, 16, chr(0x0b));
+$text = &quot;Hi There&quot;;
+$end = unpack(&quot;H32&quot;, mhash(MHASH_MD5, $text, $k));
+echo &quot;key =     0x0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b\n&quot;;
+echo &quot;data =    \&quot;$text\&quot;\n&quot;;
+echo &quot;digest =  0x$end[1]\n&quot;;
+echo &quot;should =  0x9294727a3638bb1c13f48ef8158bfc9d\n\n&quot;;
+
+# 2
+$k = &quot;Jefe&quot;;
+$text = &quot;what do ya want for nothing?&quot;;
+$end = unpack(&quot;H32&quot;, mhash(MHASH_MD5, $text, $k));
+echo &quot;key =     \&quot;$k\&quot;\n&quot;;
+echo &quot;data =    \&quot;$text\&quot;\n&quot;;
+echo &quot;digest =  0x$end[1]\n&quot;;
+echo &quot;should =  0x750c783e6ab0b503eaa86e310a5db738\n\n&quot;;
+
+
+
+?&gt;
\ No newline at end of file

Added: YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/mime_content_type
===================================================================
--- YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/mime_content_type	2006-12-09 18:08:01 UTC (rev 2249)
+++ YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/mime_content_type	2006-12-09 18:13:10 UTC (rev 2250)
@@ -0,0 +1,9 @@
+&lt;?php
+
+include(&quot;../upgrade.php&quot;);
+include(&quot;../ext/mime.php&quot;);
+
+$t = mime_content_type(__FILE__);
+echo &quot;mime_content_type(__FILE__) = $t\n\n&quot;;
+
+?&gt;
\ No newline at end of file

Added: YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/scandir
===================================================================
--- YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/scandir	2006-12-09 18:08:01 UTC (rev 2249)
+++ YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/scandir	2006-12-09 18:13:10 UTC (rev 2250)
@@ -0,0 +1,9 @@
+&lt;?php
+
+include(&quot;../upgrade.php&quot;);
+
+$r = scandir(&quot;..&quot;);
+echo &quot;..\n\n&quot;;
+print_r($r);
+
+?&gt;
\ No newline at end of file

Added: YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/spl_classes
===================================================================
--- YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/spl_classes	2006-12-09 18:08:01 UTC (rev 2249)
+++ YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/spl_classes	2006-12-09 18:13:10 UTC (rev 2250)
@@ -0,0 +1,9 @@
+&lt;?php
+
+include(&quot;../upgrade.php&quot;);
+
+echo &quot;print_r(spl_classes());\n\n&quot;;
+$r=spl_classes();
+print_r($r);
+
+?&gt;
\ No newline at end of file

Added: YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/str_ireplace
===================================================================
--- YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/str_ireplace	2006-12-09 18:08:01 UTC (rev 2249)
+++ YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/str_ireplace	2006-12-09 18:13:10 UTC (rev 2250)
@@ -0,0 +1,12 @@
+&lt;?php
+
+include(&quot;../upgrade.php&quot;);
+
+$text = &quot;ABC_abc_DEF_def_AAaaAAaa_DDddEEee&quot;;
+echo &quot;\$text = \&quot;$text\&quot;;\n&quot;;
+echo 'str_ireplace(&quot;abc&quot;, &quot;xxx&quot;, $text);'.&quot;\n\n&quot;;
+
+$text = str_ireplace(&quot;abc&quot;, &quot;xxx&quot;, $text);
+echo &quot;\$text = \&quot;$text\&quot;;\n&quot;;
+
+?&gt;
\ No newline at end of file

Added: YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/str_rot13
===================================================================
--- YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/str_rot13	2006-12-09 18:08:01 UTC (rev 2249)
+++ YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/str_rot13	2006-12-09 18:13:10 UTC (rev 2250)
@@ -0,0 +1,9 @@
+str_rot13('upgrade.php v4') = &quot;&lt;?php
+
+include(&quot;../upgrade.php&quot;);
+
+echo str_rot13('upgrade.php v4');
+
+?&gt;&quot;
+
+

Added: YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/str_shuffle
===================================================================
--- YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/str_shuffle	2006-12-09 18:08:01 UTC (rev 2249)
+++ YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/str_shuffle	2006-12-09 18:13:10 UTC (rev 2250)
@@ -0,0 +1,10 @@
+str_shuffle(&quot;ABCDEF&quot;) == &quot;&lt;?php
+
+include(&quot;../upgrade.php&quot;);
+
+srand(17);
+echo str_shuffle(&quot;ABCDEF&quot;);
+
+?&gt;&quot;
+
+

Added: YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/str_split
===================================================================
--- YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/str_split	2006-12-09 18:08:01 UTC (rev 2249)
+++ YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/str_split	2006-12-09 18:13:10 UTC (rev 2250)
@@ -0,0 +1,15 @@
+&lt;?php
+
+include(&quot;../upgrade.php&quot;);
+
+
+?&gt;
+$str = &quot;Hello Friend&quot;;
+$r = str_split($str, 3);
+print_r($r);
+
+&lt;?php
+$str = &quot;Hello_Friend&quot;;
+$r = str_split($str, 3);
+print_r($r);
+?&gt;
\ No newline at end of file

Added: YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/str_word_count
===================================================================
--- YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/str_word_count	2006-12-09 18:08:01 UTC (rev 2249)
+++ YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/str_word_count	2006-12-09 18:13:10 UTC (rev 2250)
@@ -0,0 +1,14 @@
+&lt;?php
+
+include(&quot;../upgrade.php&quot;);
+
+
+$r = str_word_count(&quot;This is-a sample string.&quot;, 2);
+echo 'str_word_count(&quot;This is-a sample string.&quot;, 2) = ';
+print_r($r);
+
+
+?&gt;
+
+
+

Added: YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/stripos
===================================================================
--- YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/stripos	2006-12-09 18:08:01 UTC (rev 2249)
+++ YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/stripos	2006-12-09 18:13:10 UTC (rev 2250)
@@ -0,0 +1,11 @@
+&lt;?php
+
+include(&quot;../upgrade.php&quot;);
+
+$l = stripos(&quot;ABCDEFef&quot;, &quot;e&quot;);
+echo &quot;stripos(\&quot;ABCDEFef\&quot;, \&quot;e\&quot;) == $l\n\n&quot;;
+
+$r = strripos(&quot;ABCDefEF&quot;, &quot;e&quot;);
+echo &quot;strripos(\&quot;ABCDefEF\&quot;, \&quot;e\&quot;) == $r\n\n&quot;;
+
+?&gt;
\ No newline at end of file

Added: YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/strpbrk
===================================================================
--- YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/strpbrk	2006-12-09 18:08:01 UTC (rev 2249)
+++ YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/strpbrk	2006-12-09 18:13:10 UTC (rev 2250)
@@ -0,0 +1,15 @@
+&lt;?php
+
+include(&quot;../upgrade.php&quot;);
+
+?&gt;
+$text = 'This is a Simple text.';
+
+echo strpbrk($text, 'mi');
+&lt;?php
+$text = 'This is a Simple text.';
+echo strpbrk($text, 'mi').&quot;\n\n&quot;;
+
+echo 'echo strpbrk($text, &quot;S&quot;);'.&quot;\n&quot;;
+echo strpbrk($text, &quot;S&quot;).&quot;\n\n&quot;;
+?&gt;

Added: YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/strripos
===================================================================
--- YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/strripos	2006-12-09 18:08:01 UTC (rev 2249)
+++ YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/strripos	2006-12-09 18:13:10 UTC (rev 2250)
@@ -0,0 +1,10 @@
+&lt;?php
+
+include(&quot;../upgrade.php&quot;);
+
+echo 'strripos(&quot;aaaabc_DEFff_ABCccc&quot;, &quot;a&quot;) == ';
+echo strripos(&quot;aaaabc_DEFff_ABCccc&quot;, &quot;a&quot;);
+
+?&gt;
+
+

Added: YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/substr_compare
===================================================================
--- YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/substr_compare	2006-12-09 18:08:01 UTC (rev 2249)
+++ YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/substr_compare	2006-12-09 18:13:10 UTC (rev 2250)
@@ -0,0 +1,12 @@
+&lt;?php
+
+include(&quot;../upgrade.php&quot;);
+
+
+echo 'substr_compare(&quot;abcde&quot;, &quot;bc&quot;, 1, 2) == '. substr_compare(&quot;abcde&quot;, &quot;bc&quot;, 1, 2) . &quot;   // 0\n&quot;;
+echo 'substr_compare(&quot;abcde&quot;, &quot;bcg&quot;, 1, 2) == '. substr_compare(&quot;abcde&quot;, &quot;bcg&quot;, 1, 2). &quot;   // 0\n&quot;; 
+echo 'substr_compare(&quot;abcde&quot;, &quot;BC&quot;, 1, 2, true) == '. substr_compare(&quot;abcde&quot;, &quot;BC&quot;, 1, 2, true) . &quot;   // 0\n&quot;;
+echo 'substr_compare(&quot;abcde&quot;, &quot;bc&quot;, 1, 3) == '. substr_compare(&quot;abcde&quot;, &quot;bc&quot;, 1, 3) .&quot;   // 1\n&quot;;
+echo 'substr_compare(&quot;abcde&quot;, &quot;cd&quot;, 1, 2) == '. substr_compare(&quot;abcde&quot;, &quot;cd&quot;, 1, 2) .&quot;  // -1\n&quot;;
+echo 'substr_compare(&quot;abcde&quot;, &quot;abc&quot;, 5, 1) == '. substr_compare(&quot;abcde&quot;, &quot;abc&quot;, 5, 1) . &quot;   // warning\n&quot;;
+?&gt;

Added: YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/uuencode
===================================================================
--- YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/uuencode	2006-12-09 18:08:01 UTC (rev 2249)
+++ YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/uuencode	2006-12-09 18:13:10 UTC (rev 2250)
@@ -0,0 +1,11 @@
+&lt;?php
+
+include(&quot;../upgrade.php&quot;);
+
+$uu = convert_uuencode(&quot;ABCDEFGHIJ&quot;);
+echo &quot;\$uu = \&quot;$uu\&quot;\n\n&quot;;
+
+$text = convert_uudecode($uu);
+echo &quot;\$text = \&quot;$text\&quot;\n\n&quot;;
+
+?&gt;
\ No newline at end of file

Added: YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/vprintf
===================================================================
--- YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/vprintf	2006-12-09 18:08:01 UTC (rev 2249)
+++ YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/tests/vprintf	2006-12-09 18:13:10 UTC (rev 2250)
@@ -0,0 +1,8 @@
+&lt;?php
+
+include(&quot;../upgrade.php&quot;);
+
+vprintf(&quot;%d, %d\n&quot;, array(17, 5));
+
+?&gt;
+

Added: YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/upgrade.meta
===================================================================
--- YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/upgrade.meta	2006-12-09 18:08:01 UTC (rev 2249)
+++ YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/upgrade.meta	2006-12-09 18:13:10 UTC (rev 2250)
@@ -0,0 +1,11 @@
+api: PHP
+type: emulation
+priority: auto
+category: library
+sort: -200
+provides: upgrade-php
+title: PHP-Upgrade
+description: backwards-compatility layer for older PHP versions
+license: Public Domain
+url: <A HREF="http://freshmeat.net/p/upgradephp">http://freshmeat.net/p/upgradephp</A>
+version: 13

Added: YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/upgrade.php
===================================================================
--- YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/upgrade.php	2006-12-09 18:08:01 UTC (rev 2249)
+++ YDFramework2.0/trunk/YDFramework2/3rdparty/upgrade/upgrade.php	2006-12-09 18:13:10 UTC (rev 2250)
@@ -0,0 +1,1612 @@
+&lt;?php
+/*
+   This include() script adds missing PHP functions to earlier interpreter
+   versions, so you can make downwards compatible scripts without having
+   to stick to the least common denominator. It only defines the ones that
+   are really missing - the faster native functions will be used whenever
+   available.
+
+   - many of the emulation functions are one-liners
+   - a few features have been added that never made it into one of the
+     official versions (CVS code and the ever-absent &quot;gzdecode&quot; and
+     &quot;file_put_contents&quot; for example)
+   - a few very extravagant functions (array_u?diff*_u*assoc?) and other
+     extensions have been separated out into ext/
+   - the advanced OO-capabilities and language syntax extensions of PHP5
+     and ZE2 cannot seriously be emulated here, this emulation only takes 
+     care of procedural interfaces
+   - with only this part loaded, you get &quot;PHP 4.1 COMPATIBILITY&quot;
+   - this is PuplicDomain (no copyright, no license, no warranty) so you
+     can melt it into anything, regardless of your preferred license (you
+     may strip this paragraph and turn it all into GPL, BSD, GNU LGPL,
+     Artistic, MPL, PHP license, M$ EULA, or whatever you like best)
+   
+   Get update notes via &quot;<A HREF="http://freshmeat.net/projects/upgradephp">http://freshmeat.net/projects/upgradephp</A>&quot; or
+   google for it. Any contribution is appreciated. &lt;milky*users&#183;sf&#183;net&gt;
+*/
+
+
+
+#------------------------------------------------------------------ CVS ---
+// most of this appeared in 5.0
+// ...
+
+
+
+
+#------------------------------------------------------------------ 6.0 ---
+// following functions were never implemented in PHP
+
+
+#-- inflates a string enriched with gzip headers
+#   (this is the logical counterpart to gzencode(), but don't tell anyone!)
+if (!function_exists(&quot;gzdecode&quot;)) {
+   function gzdecode($data, $maxlen=NULL) {
+
+      #-- decode header
+      $len = strlen($data);
+      if ($len &lt; 20) {
+         return;
+      }
+      $head = substr($data, 0, 10);
+      $head = unpack(&quot;n1id/C1cm/C1flg/V1mtime/C1xfl/C1os&quot;, $head);
+      list($ID, $CM, $FLG, $MTIME, $XFL, $OS) = array_values($head);
+      $FTEXT = 1&lt;&lt;0;
+      $FHCRC = 1&lt;&lt;1;
+      $FEXTRA = 1&lt;&lt;2;
+      $FNAME = 1&lt;&lt;3;
+      $FCOMMENT = 1&lt;&lt;4;
+      $head = unpack(&quot;V1crc/V1isize&quot;, substr($data, $len-8, 8));
+      list($CRC32, $ISIZE) = array_values($head);
+
+      #-- check gzip stream identifier
+      if ($ID != 0x1f8b) {
+         trigger_error(&quot;gzdecode: not in gzip format&quot;, E_USER_WARNING);
+         return;
+      }
+      #-- check for deflate algorithm
+      if ($CM != 8) {
+         trigger_error(&quot;gzdecode: cannot decode anything but deflated streams&quot;, E_USER_WARNING);
+         return;
+      }
+
+      #-- start of data, skip bonus fields
+      $s = 10;
+      if ($FLG &amp; $FEXTRA) {
+         $s += $XFL;
+      }
+      if ($FLG &amp; $FNAME) {
+         $s = strpos($data, &quot;\000&quot;, $s) + 1;
+      }
+      if ($FLG &amp; $FCOMMENT) {
+         $s = strpos($data, &quot;\000&quot;, $s) + 1;
+      }
+      if ($FLG &amp; $FHCRC) {
+         $s += 2;  // cannot check
+      }
+      
+      #-- get data, uncompress
+      $data = substr($data, $s, $len-$s);
+      if ($maxlen) {
+         $data = gzinflate($data, $maxlen);
+         return($data);  // no checks(?!)
+      }
+      else {
+         $data = gzinflate($data);
+      }
+      
+      #-- check+fin
+      $chk = crc32($data);
+      if ($CRC32 != $chk) {
+         trigger_error(&quot;gzdecode: checksum failed (real$chk != comp$CRC32)&quot;, E_USER_WARNING);
+      }
+      elseif ($ISIZE != strlen($data)) {
+         trigger_error(&quot;gzdecode: stream size mismatch&quot;, E_USER_WARNING);
+      }
+      else {
+         return($data);
+      }
+   }
+}
+
+
+#-- get all already made headers(),
+#   CANNOT be emulated, because output buffering functions
+#   already swallow up any sent http header
+if (!function_exists(&quot;ob_get_headers&quot;)) {
+   function ob_get_headers() {
+      return (array)NULL;
+   }
+}
+
+
+#-- encodes required named XML entities, like htmlentities(),
+#   but does not re-encode numeric &amp;#xxxx; character references
+#   - could screw up scripts which then implement this themselves
+#   - doesn't fix bogus or invalid numeric entities
+if (!function_exists(&quot;xmlentities&quot;)) {
+   function xmlentities($str) {
+      return strtr($str, array(
+        &quot;&amp;#&quot;=&gt;&quot;&amp;#&quot;, &quot;&amp;&quot;=&gt;&quot;&amp;&quot;, &quot;'&quot;=&gt;&quot;&apos;&quot;,
+        &quot;&lt;&quot;=&gt;&quot;&lt;&quot;, &quot;&gt;&quot;=&gt;&quot;&gt;&quot;, &quot;\&quot;&quot;=&gt;&quot;&quot;&quot;, 
+      ));
+   }
+}
+
+
+
+#------------------------------------------------------------------ 5.0 ---
+# set_exception_handler - unimpl.
+# restore_exception_handler - unimpl.
+# debug_print_backtrace - unimpl.
+# class_implements - unimplementable
+# proc_terminate - unimpl?
+# proc_get_status - unimpl.
+# --
+# proc_nice
+# dns_get_record
+# date_sunrise - undoc.
+# date_sunset - undoc.
+
+
+
+#-- constant: end of line
+if (!defined(&quot;PHP_EOL&quot;)) {
+   define(&quot;PHP_EOL&quot;, ( (DIRECTORY_SEPARATOR == &quot;\\&quot;) ?&quot;\015\012&quot; :(strncmp(PHP_OS,&quot;D&quot;,1)?&quot;\012&quot;:&quot;\015&quot;) )  ); #&quot;
+}
+
+
+#-- case-insensitive string search function,
+#   - finds position of first occourence of a string c-i
+#   - parameters identical to strpos()
+if (!function_exists(&quot;stripos&quot;)) {
+   function stripos($haystack, $needle, $offset=NULL) {
+   
+      #-- simply lowercase args
+      $haystack = strtolower($haystack);
+      $needle = strtolower($needle);
+      
+      #-- search
+      $pos = strpos($haystack, $needle, $offset);
+      return($pos);
+   }
+}
+
+
+#-- case-insensitive string search function
+#   - but this one starts from the end of string (right to left)
+#   - offset can be negative or positive
+if (!function_exists(&quot;strripos&quot;)) {
+   function strripos($haystack, $needle, $offset=NULL) {
+
+      #-- lowercase incoming strings
+      $haystack = strtolower($haystack);
+      $needle = strtolower($needle);
+
+      #-- [-]$offset tells to ignore a few string bytes,
+      #   we simply cut a bit from the right
+      if (isset($offset) &amp;&amp; ($offset &lt; 0)) {
+         $haystack = substr($haystack, 0, strlen($haystack) - 1);
+      }
+
+      #-- let PHP do it
+      $pos = strrpos($haystack, $needle);
+
+      #-- [+]$offset =&gt; ignore left haystack bytes
+      if (isset($offset) &amp;&amp; ($offset &gt; 0) &amp;&amp; ($pos &gt; $offset)) {
+         $pos = false;
+      }
+
+      #-- result      
+      return($pos);
+   }
+}
+
+
+#-- case-insensitive version of str_replace
+if (!function_exists(&quot;str_ireplace&quot;)) {
+   function str_ireplace($search, $replace, $subject, $count=NULL) {
+
+      #-- call ourselves recursively, if parameters are arrays/lists 
+      if (is_array($search)) {
+         $replace = array_values($replace);
+         foreach (array_values($search) as $i=&gt;$srch) {
+            $subject = str_ireplace($srch, $replace[$i], $subject);
+         }
+      }
+      
+      #-- sluice replacement strings through the Perl-regex module
+      #   (faster than doing it by hand)
+      else {
+         $replace = addcslashes($replace, &quot;$\\&quot;);
+         $search = &quot;{&quot; . preg_quote($search) . &quot;}i&quot;;
+         $subject = preg_replace($search, $replace, $subject);
+      }
+
+      #-- result
+      return($subject);
+   }
+}
+
+
+#-- performs a http HEAD request
+if (!function_exists(&quot;get_headers&quot;)) {
+   function get_headers($url, $parse=0) {
+   
+      #-- extract URL parts ($host, $port, $path, ...)
+      $c = parse_url($url);
+      extract($c);
+      if (!isset($port)) { 
+         $port = 80;
+      }
+      
+      #-- try to open TCP connection      
+      $f = fsockopen($host, $port, $errno, $errstr, $timeout=15);
+      if (!$f) {
+         return;
+      }
+
+      #-- send request header
+      socket_set_blocking($f, true);
+      fwrite($f, &quot;HEAD $path HTTP/1.0\015\012&quot;
+               . &quot;Host: $host\015\012&quot;
+               . &quot;Connection: close\015\012&quot;
+               . &quot;Accept: */*, xml/*\015\012&quot;
+               . &quot;User-Agent: &quot;.trim(ini_get(&quot;user_agent&quot;)).&quot;\015\012&quot;
+               . &quot;\015\012&quot;);
+
+      #-- read incoming lines
+      $ls = array();
+      while ( !feof($f) &amp;&amp; ($line = trim(fgets($f, 1&lt;&lt;16))) ) {
+         
+         #-- read header names to make result an hash (names in array index)
+         if ($parse) {
+            if ($l = strpos($line, &quot;:&quot;)) {
+               $name = substr($line, 0, $l);
+               $value = trim(substr($line, $l + 1));
+               #-- merge headers
+               if (isset($ls[$name])) {
+                  $ls[$name] .= &quot;, $value&quot;;
+               }
+               else {
+                  $ls[$name] = $value;
+               }
+            }
+            #-- HTTP response status header as result[0]
+            else {
+               $ls[] = $line;
+            }
+         }
+         
+         #-- unparsed header list (numeric indices)
+         else {
+            $ls[] = $line;
+         }
+      }
+
+      #-- close TCP connection and give result
+      fclose($f);
+      return($ls);
+   }
+}
+
+
+#-- list of already/potentially sent HTTP responsee headers(),
+#   CANNOT be implemented (except for Apache module maybe)
+if (!function_exists(&quot;headers_list&quot;)) {
+   function headers_list() {
+      trigger_error(&quot;headers_list(): not supported by this PHP version&quot;, E_USER_WARNING);
+      return (array)NULL;
+   }
+}
+
+
+#-- write formatted string to stream/file,
+#   arbitrary numer of arguments
+if (!function_exists(&quot;fprintf&quot;)) {
+   function fprintf(/*...*/) {
+      $args = func_get_args();
+      $stream = array_shift($args);
+      return fwrite($stream, call_user_func_array(&quot;sprintf&quot;, $args));
+   }
+}
+
+
+#-- write formatted string to stream, args array
+if (!function_exists(&quot;vfprintf&quot;)) {
+   function vfprintf($stream, $format, $args=NULL) {
+      return fwrite($stream, vsprintf($format, $args));
+   }
+}
+
+
+#-- splits a string in evenly sized chunks
+#   and returns this as array
+if (!function_exists(&quot;str_split&quot;)) {
+   function str_split($str, $chunk=1) {
+      $r = array();
+      
+      #-- return back as one chunk completely, if size chosen too low
+      if ($chunk &lt; 1) {
+         $r[] = $str;
+      }
+      
+      #-- add substrings to result array until subject strings end reached
+      else {
+         $len = strlen($str);
+         for ($n=0; $n&lt;$len; $n+=$chunk) {
+            $r[] = substr($str, $n, $chunk);
+         }
+      }
+      return($r);
+   }
+}
+
+
+#-- constructs a QUERY_STRING (application/x-www-form-urlencoded format, non-raw)
+#   from a nested array/hash with name=&gt;value pairs
+#   - only first two args are part of the original API - rest used for recursion
+if (!function_exists(&quot;http_build_query&quot;)) {
+   function http_build_query($data, $int_prefix=&quot;&quot;, $subarray_pfix=&quot;&quot;, $level=0) {
+   
+      #-- empty starting string
+      $s = &quot;&quot;;
+      ($SEP = ini_get(&quot;arg_separator.output&quot;)) or ($SEP = &quot;&amp;&quot;);
+      
+      #-- traverse hash/array/list entries 
+      foreach ($data as $index=&gt;$value) {
+         
+         #-- add sub_prefix for subarrays (happens for recursed innovocation)
+         if ($subarray_pfix) {
+            if ($level) {
+               $index = &quot;[&quot; . $index . &quot;]&quot;;
+            }
+            $index =  $subarray_pfix . $index;
+         }
+         #-- add user-specified prefix for integer-indices
+         elseif (is_int($index) &amp;&amp; strlen($int_prefix)) {
+            $index = $int_prefix . $index;
+         }
+         
+         #-- recurse for sub-arrays
+         if (is_array($value)) {
+            $s .= http_build_query($value, &quot;&quot;, $index, $level + 1);
+         }
+         else {   // or just literal URL parameter
+            $s .= $SEP . $index . &quot;=&quot; . urlencode($value);
+         }
+      }
+      
+      #-- remove redundant &quot;&amp;&quot; from first round (-not checked above to simplifiy loop)
+      if (!$subarray_pfix) {
+         $s = substr($s, strlen($SEP));
+      }
+
+      #-- return result / to previous array level and iteration
+      return($s);
+   }
+}
+
+
+#-- transform into 3to4 uuencode
+#   - this is the bare encoding, not the uu file format
+if (!function_exists(&quot;convert_uuencode&quot;)) {
+   function convert_uuencode($data) {
+
+      #-- init vars
+      $out = &quot;&quot;;
+      $line = &quot;&quot;;
+      $len = strlen($data);
+#      $data .= &quot;\252\252\252&quot;;   // PHP and uuencode(1) use some special garbage??, looks like &quot;\000&quot;* and &quot;`\n`&quot; simply appended
+
+      #-- canvass source string
+      for ($n=0; $n&lt;$len; ) {
+      
+         #-- make 24-bit integer from first three bytes
+         $x = (ord($data[$n++]) &lt;&lt; 16)
+            + (ord($data[$n++]) &lt;&lt;  8)
+            + (ord($data[$n++]) &lt;&lt;  0);
+            
+         #-- disperse that into 4 ascii characters
+         $line .= chr( 32 + (($x &gt;&gt; 18) &amp; 0x3f) )
+                . chr( 32 + (($x &gt;&gt; 12) &amp; 0x3f) )
+                . chr( 32 + (($x &gt;&gt;  6) &amp; 0x3f) )
+                . chr( 32 + (($x &gt;&gt;  0) &amp; 0x3f) );
+                
+         #-- cut lines, inject count prefix before each
+         if (($n % 45) == 0) {
+            $out .= chr(32 + 45) . &quot;$line\n&quot;;
+            $line = &quot;&quot;;
+         }
+      }
+
+      #-- throw last line, +length prefix
+      if ($trail = ($len % 45)) {
+         $out .= chr(32 + $trail) . &quot;$line\n&quot;;
+      }
+
+      // uuencode(5) doesn't tell so, but spaces are replaced with the ` char in most implementations
+      $out = strtr(&quot;$out \n&quot;, &quot; &quot;, &quot;`&quot;);
+      return($out);
+   }
+}
+
+
+#-- decodes uuencoded() data again
+if (!function_exists(&quot;convert_uudecode&quot;)) {
+   function convert_uudecode($data) {
+
+      #-- prepare
+      $out = &quot;&quot;;
+      $data = strtr($data, &quot;`&quot;, &quot; &quot;);
+      
+      #-- go through lines
+      foreach(explode(&quot;\n&quot;, ltrim($data)) as $line) {
+         if (!strlen($line)) {
+            break;  // end reached
+         }
+         
+         #-- current line length prefix
+         unset($num);
+         $num = ord($line{0}) - 32;
+         if (($num &lt;= 0) || ($num &gt; 62)) {  // 62 is the maximum line length
+            break;          // according to uuencode(5), so we stop here too
+         }
+         $line = substr($line, 1);
+         
+         #-- prepare to decode 4-char chunks
+         $add = &quot;&quot;;
+         for ($n=0; strlen($add)&lt;$num; ) {
+         
+            #-- merge 24 bit integer from the 4 ascii characters (6 bit each)
+            $x = ((ord($line[$n++]) - 32) &lt;&lt; 18)
+               + ((ord($line[$n++]) - 32) &lt;&lt; 12)  // were saner with &quot;&amp; 0x3f&quot;
+               + ((ord($line[$n++]) - 32) &lt;&lt;  6)
+               + ((ord($line[$n++]) - 32) &lt;&lt;  0);
+               
+            #-- reconstruct the 3 original data chars
+            $add .= chr( ($x &gt;&gt; 16) &amp; 0xff )
+                  . chr( ($x &gt;&gt;  8) &amp; 0xff )
+                  . chr( ($x &gt;&gt;  0) &amp; 0xff );
+         }
+
+         #-- cut any trailing garbage (last two decoded chars may be wrong)
+         $out .= substr($add, 0, $num);
+         $line = &quot;&quot;;
+      }
+
+      return($out);
+   }
+}
+
+
+#-- return array of filenames in a given directory
+#   (only works for local files)
+if (!function_exists(&quot;scandir&quot;)) {
+   function scandir($dirname, $desc=0) {
+   
+      #-- check for <A HREF="file://">file://</A> protocol, others aren't handled
+      if (strpos($dirname, &quot;<A HREF="file://">file://</A>&quot;) === 0) {
+         $dirname = substr($dirname, 7);
+         if (strpos($dirname, &quot;localh&quot;) === 0) {
+            $dirname = substr($dirname, strpos($dirname, &quot;/&quot;));
+         }
+      }
+      
+      #-- directory reading handle
+      if ($dh = opendir($dirname)) {
+         $ls = array();
+         while ($fn = readdir($dh)) {
+            $ls[] = $fn;  // add to array
+         }
+         closedir($dh);
+         
+         #-- sort filenames
+         if ($desc) {
+            rsort($ls);
+         }
+         else {
+            sort($ls);
+         }
+         return $ls;
+      }
+
+      #-- failure
+      return false;
+   }
+}
+
+
+#-- like date(), but returns an integer for given one-letter format parameter
+if (!function_exists(&quot;idate&quot;)) {
+   function idate($formatchar, $timestamp=NULL) {
+   
+      #-- reject non-simple type parameters
+      if (strlen($formatchar) != 1) {
+         return false;
+      }
+      
+      #-- get current time, if not given
+      if (!isset($timestamp)) {
+         $timestamp = time();
+      }
+      
+      #-- get and turn into integer
+      $str = date($formatchar, $timestamp);
+      return (int)$str;
+   }
+}
+
+
+
+#-- combined sleep() and usleep() 
+if (!function_exists(&quot;time_nanosleep&quot;)) {
+   function time_nanosleep($sec, $nano) {
+      sleep($sec);
+      usleep($nano);
+   }
+}
+
+
+
+#-- search first occourence of any of the given chars, returns rest of haystack
+#   (char_list must be a string for compatibility with the real PHP func)
+if (!function_exists(&quot;strpbrk&quot;)) {
+   function strpbrk($haystack, $char_list) {
+   
+      #-- prepare
+      $len = strlen($char_list);
+      $min = strlen($haystack);
+      
+      #-- check with every symbol from $char_list
+      for ($n = 0; $n &lt; $len; $n++) {
+         $l = strpos($haystack, $char_list{$n});
+         
+         #-- get left-most occourence
+         if (($l !== false) &amp;&amp; ($l &lt; $min)) {
+            $min = $l;
+         }
+      }
+      
+      #-- result
+      if ($min) {
+         return(substr($haystack, $min));
+      }
+      else {
+         return(false);
+      }
+   }
+}
+
+
+
+#-- logo image activation URL query strings (gaga feature)
+if (!function_exists(&quot;php_real_logo_guid&quot;)) {
+   function php_real_logo_guid() { return php_logo_guid(); }
+   function php_egg_logo_guid() { return zend_logo_guid(); }
+}
+
+
+#-- no need to implement this
+#   (there aren't interfaces in PHP4 anyhow)
+if (!function_exists(&quot;get_declared_interfaces&quot;)) {
+   function get_declared_interfaces() {
+      trigger_error(&quot;get_declared_interfaces(): Current script won't run reliably with PHP4.&quot;, E_USER_WARNING);
+      return( (array)NULL );
+   }
+}
+
+
+#-- creates an array from lists of $keys and $values
+#   (both should have same number of entries)
+if (!function_exists(&quot;array_combine&quot;)) {
+   function array_combine($keys, $values) {
+   
+      #-- convert input arrays into lists
+      $keys = array_values($keys);
+      $values = array_values($values);
+      $r = array();
+      
+      #-- one from each
+      foreach ($values as $i=&gt;$val) {
+         if ($key = $keys[$i]) {
+            $r[$key] = $val;
+         }
+         else {
+            $r[] = $val;   // useless, PHP would have long aborted here
+         }
+      }
+      return($r);
+   }
+}
+
+
+#-- apply userfunction to each array element (descending recursively)
+#   use it like:  array_walk_recursive($_POST, &quot;stripslashes&quot;);
+#   - $callback can be static function name or object/method, class/method
+if (!function_exists(&quot;array_walk_recursive&quot;)) {
+   function array_walk_recursive(&amp;$input, $callback, $userdata=NULL) {
+      #-- each entry
+      foreach ($input as $key=&gt;$value) {
+
+         #-- recurse for sub-arrays
+         if (is_array($value)) {
+            array_walk_recursive($input[$key], $callback, $userdata);
+         }
+
+         #-- $callback handles scalars
+         else {
+            call_user_func_array($callback, array(&amp;$input[$key], $key, $userdata) );
+         }
+      }
+
+      // no return value
+   }
+}
+
+
+#-- complicated wrapper around substr() and and strncmp()
+if (!function_exists(&quot;substr_compare&quot;)) {
+   function substr_compare($haystack, $needle, $offset=0, $len=0, $ci=0) {
+
+      #-- check params   
+      if ($len &lt;= 0) {   // not well documented
+         $len = strlen($needle);
+         if (!$len) { return(0); }
+      }
+      #-- length exception
+      if ($len + $offset &gt;= strlen($haystack)) {
+         trigger_error(&quot;substr_compare: given length exceeds main_str&quot;, E_USER_WARNING);
+         return(false);
+      }
+
+      #-- cut
+      if ($offset) {
+         $haystack = substr($haystack, $offset, $len);
+      }
+      #-- case-insensitivity
+      if ($ci) {
+         $haystack = strtolower($haystack);
+         $needle = strtolower($needle);
+      }
+
+      #-- do
+      return(strncmp($haystack, $needle, $len));
+   }
+}
+
+
+#-- stub, returns empty list as usual;
+#   you must load &quot;ext/spl.php&quot; beforehand to get this
+if (!function_exists(&quot;spl_classes&quot;)) {
+   function spl_classes() {
+      trigger_error(&quot;spl_classes(): not built into this PHP version&quot;);
+      return (array)NULL;
+   }
+}
+
+
+
+#-- gets you list of class names the given objects class was derived from, slow
+if (!function_exists(&quot;class_parents&quot;)) {
+   function class_parents($obj) {
+   
+      #-- first get full list
+      $all = get_declared_classes();
+      $r = array();
+      
+      #-- filter out
+      foreach ($all as $potential_parent) {
+         if (is_subclass_of($obj, $potential_parent)) {
+            $r[$potential_parent] = $potential_parent;
+         }
+      }
+      return($r);
+   }
+}
+
+
+#-- an alias
+if (!function_exists(&quot;session_commit&quot;) &amp;&amp; function_exists(&quot;session_write_close&quot;)) {
+   function session_commit() {
+      // simple
+      session_write_close();
+   }
+}
+
+
+#-- aliases
+if (!function_exists(&quot;dns_check_record&quot;)) {
+   function dns_check_record($host, $type=NULL) {
+      // synonym to
+      return checkdnsrr($host, $type);
+   }
+}
+if (!function_exists(&quot;dns_get_mx&quot;)) {
+   function dns_get_mx($host, $mx) {
+      $args = func_get_args();
+      // simple alias - except the optional, but referenced third parameter
+      if ($args[2]) {
+         $w = &amp; $args[2];
+      }
+      else {
+         $w = false;
+      }
+      return getmxrr($host, $mx, $w);
+   }
+}
+
+
+#-- setrawcookie(),
+#   can this be emulated 100% exactly?
+if (!function_exists(&quot;setrawcookie&quot;)) {
+   // we output everything directly as HTTP header(), PHP doesn't seem
+   // to manage an internal cookie list anyhow
+   function setrawcookie($name, $value=NULL, $expire=NULL, $path=NULL, $domain=NULL, $secure=0) {
+      if (isset($value) &amp;&amp; strpbrk($value, &quot;,; \r\t\n\f\014\013&quot;)) {
+         trigger_error(&quot;setrawcookie: value may not contain any of ',; \r\n' and some other control chars; thrown away&quot;, E_USER_WARNING);
+      }
+      else {
+         $h = &quot;Set-Cookie: $name=$value&quot;
+            . ($expire ? &quot;; expires=&quot; . gmstrftime(&quot;%a, %d-%b-%y %H:%M:%S %Z&quot;, $expire) : &quot;&quot;)
+            . ($path ? &quot;; path=$path&quot;: &quot;&quot;)
+            . ($domain ? &quot;; domain=$domain&quot; : &quot;&quot;)
+            . ($secure ? &quot;; secure&quot; : &quot;&quot;);
+         header($h);
+      }
+   }
+}
+
+
+#-- write-at-once file access (counterpart to file_get_contents)
+if (!function_exists(&quot;file_put_contents&quot;)) {
+   function file_put_contents($filename, $data, $flags=0, $resource=NULL) {
+
+      #-- prepare
+      $mode = ($flags &amp; FILE_APPEND ? &quot;a&quot; : &quot;w&quot; ) .&quot;b&quot;;
+      $incl = $flags &amp; FILE_USE_INCLUDE_PATH;
+      $length = strlen($data);
+
+      #-- open for writing
+      $f = fopen($filename, $mode, $incl);
+      if ($f) {
+         $written = fwrite($f, $data);
+         fclose($f);
+         
+         #-- only report success, if completely saved
+         return($length == $written);
+      }
+   }
+}
+
+
+#-- file-related constants
+if (!defined(&quot;FILE_APPEND&quot;)) {
+   define(&quot;FILE_USE_INCLUDE_PATH&quot;, 1);
+   define(&quot;FILE_IGNORE_NEW_LINES&quot;, 2);
+   define(&quot;FILE_SKIP_EMPTY_LINES&quot;, 4);
+   define(&quot;FILE_APPEND&quot;, 8);
+   define(&quot;FILE_NO_DEFAULT_CONTEXT&quot;, 16);
+}
+
+
+#-- more new constants for 5.0
+if (!defined(&quot;E_STRICT&quot;)) {
+   define(&quot;E_STRICT&quot;, 2048);  // _STRICT is a special case of _NOTICE (_DEBUG)
+   # PHP_CONFIG_FILE_SCAN_DIR
+}
+
+
+#-- array count_recursive()
+if (!defined(&quot;COUNT_RECURSIVE&quot;)) {
+   define(&quot;COUNT_NORMAL&quot;, 0);       // count($array, 0);
+   define(&quot;COUNT_RECURSIVE&quot;, 1);    // not supported
+}
+
+
+#-- we introduce a new function, because we cannot emulate the
+#   newly introduced second parameter to count()
+if (!function_exists(&quot;count_recursive&quot;)) {
+   function count_recursive($array, $mode=1) {
+      if (!$mode) {
+         return(count($array));
+      }
+      else {
+         $c = count($array);
+         foreach ($array as $sub) {
+            if (is_array($sub)) {
+               $c += count_recursive($sub);
+            }
+         }
+         return($c);
+      }
+   }
+}
+
+
+
+
+
+
+
+#------------------------------------------------------------------ 4.3 ---
+# money_format - unimpl?
+# sha1, sha1_file - too much code to pack it into here; and this
+#                   has already been implemented elsewhere, btw
+
+
+#-- simplified file read-at-once function
+if (!function_exists(&quot;file_get_contents&quot;)) {
+   function file_get_contents($filename, $use_include_path=1) {
+
+      #-- open file, let fopen() report error
+      $f = fopen($filename, &quot;rb&quot;, $use_include_path);
+      if (!$f) { return; }
+
+      #-- read max 2MB
+      $content = fread($f, 1&lt;&lt;21);
+      fclose($f);
+      return($content);
+   }
+}
+
+
+
+#-- shell-like filename matching (* and ? globbing characters)
+if (!function_exists(&quot;fnmatch&quot;)) {
+
+   #-- associated constants
+   define(&quot;FNM_PATHNAME&quot;, 1&lt;&lt;0);  // no wildcard ever matches a &quot;/&quot;
+   define(&quot;FNM_NOESCAPE&quot;, 1&lt;&lt;1);  // backslash can't escape meta chars
+   define(&quot;FNM_PERIOD&quot;,   1&lt;&lt;2);  // leading dot must be given explicit
+   define(&quot;FNM_LEADING_DIR&quot;, 1&lt;&lt;3);  // not in PHP
+   define(&quot;FNM_CASEFOLD&quot;, 0x50);  // match case-insensitive
+   define(&quot;FNM_EXTMATCH&quot;, 1&lt;&lt;5);  // not in PHP
+   
+   #-- implementation
+   function fnmatch($pattern, $str, $flags=0x0000) {
+      
+      #-- 'hidden' files
+      if ($flags &amp; FNM_PERIOD) {
+         if (($str[0] == &quot;.&quot;) &amp;&amp; ($pattern[0] != &quot;.&quot;)) {
+            return(false);    // abort early
+         }
+      }
+
+      #-- case-insensitivity
+      $rxci = &quot;&quot;;
+      if ($flags &amp; FNM_CASEFOLD) {
+         $rxci = &quot;i&quot;;
+      }
+      #-- handline of pathname separators (/)
+      $wild = &quot;.&quot;;
+      if ($flags &amp; FNM_PATHNAME) {
+         $wild = &quot;[^/&quot;.DIRECTORY_SEPARATOR.DIRECTORY_SEPARATOR.&quot;]&quot;;
+      }
+
+      #-- check for cached regular expressions
+      static $cmp = array();
+      if (isset($cmp[&quot;$pattern+$flags&quot;])) {
+         $rx = $cmp[&quot;$pattern+$flags&quot;];
+      }
+
+      #-- convert filename globs into regex
+      else {
+         $rx = preg_quote($pattern);
+         $rx = strtr($rx, array(
+            &quot;\\*&quot;=&gt;&quot;$wild*?&quot;, &quot;\\?&quot;=&gt;&quot;$wild&quot;, &quot;\\[&quot;=&gt;&quot;[&quot;, &quot;\\]&quot;=&gt;&quot;]&quot;,
+         ));
+         $rx = &quot;{^&quot; . $rx . &quot;$}&quot; . $rxci;
+         
+         #-- cache
+         if (count($cmp) &gt;= 50) {
+            $cmp = array();   // free
+         }
+         $cmp[&quot;$pattern+$flags&quot;] = $rx;
+      }
+      
+      #-- compare
+      return(preg_match($rx, $str));
+   }
+}
+
+
+#-- file search and name matching (with shell patterns)
+if (!function_exists(&quot;glob&quot;)) {
+
+   #-- introduced constants
+   define(&quot;GLOB_MARK&quot;, 1&lt;&lt;0);
+   define(&quot;GLOB_NOSORT&quot;, 1&lt;&lt;1);
+   define(&quot;GLOB_NOCHECK&quot;, 1&lt;&lt;2);
+   define(&quot;GLOB_NOESCAPE&quot;, 1&lt;&lt;3);
+   define(&quot;GLOB_BRACE&quot;, 1&lt;&lt;4);
+   define(&quot;GLOB_ONLYDIR&quot;, 1&lt;&lt;5);
+   define(&quot;GLOB_NOCASE&quot;, 1&lt;&lt;6);
+   define(&quot;GLOB_DOTS&quot;, 1&lt;&lt;7);
+   // unlikely to work under Win(?), without replacing the explode() with
+   // a preg_split() incorporating the native DIRECTORY_SEPARATOR as well
+
+   #-- implementation
+   function glob($pattern, $flags=0x0000) {
+      $ls = array();
+      $rxci = ($flags &amp; GLOB_NOCASE) ? &quot;i&quot; : &quot;&quot;;
+#echo &quot;\n=&gt; glob($pattern)...\n&quot;;
+      
+      #-- transform glob pattern into regular expression
+      #   (similar to fnmatch() but still different enough to require a second func)
+      if ($pattern) {
+
+         #-- look at each directory/fn spec part separately
+         $parts2 = explode(&quot;/&quot;, $pattern);
+         $pat = preg_quote($pattern);
+         $pat = strtr($pat, array(&quot;\\*&quot;=&gt;&quot;.*?&quot;, &quot;\\?&quot;=&gt;&quot;.?&quot;));
+         if ($flags ^ GLOB_NOESCAPE) {
+            // uh, oh, ouuch - the above is unclean enough...
+         }
+         if ($flags ^ GLOB_BRACE) {
+            $pat = preg_replace(&quot;/\{(.+?)\}/e&quot;, 'strtr(&quot;[$1]&quot;, &quot;,&quot;, &quot;&quot;)', $pat);
+         }
+         $parts = explode(&quot;/&quot;, $pat);
+#echo &quot;parts == &quot;.implode(&quot; // &quot;, $parts) . &quot;\n&quot;;
+         $lasti = count($parts) - 1;
+         $dn = &quot;&quot;;
+         foreach ($parts as $i=&gt;$p) {
+
+            #-- basedir included (yet no pattern matching necessary)
+            if (!strpos($p, &quot;*?&quot;) &amp;&amp; (strpos($p, &quot;.?&quot;)===false)) {
+               $dn .= $parts2[$i] . ($i!=$lasti ? &quot;/&quot; : &quot;&quot;);
+#echo &quot;skip:$i, cause no pattern matching char found -&gt; only a basedir spec\n&quot;;
+               continue;
+            }
+            
+            #-- start reading dir + match filenames against current pattern
+            if ($dh = opendir($dn ?$dn:'.')) {
+               $with_dot = ($p[1]==&quot;.&quot;) || ($flags &amp; GLOB_DOTS);
+#echo &quot;part:$i:$p\n&quot;;
+#echo &quot;reading dir \&quot;$dn\&quot;\n&quot;;
+               while ($fn = readdir($dh)) {
+                  if (preg_match(&quot;\007^$p$\007$rxci&quot;, $fn)) {
+
+                     #-- skip over 'hidden' files
+                     if (($fn[0] == &quot;.&quot;) &amp;&amp; !$with_dot) {
+                        continue;
+                     }
+
+                     #-- add filename only if last glob/pattern part
+                     if ($i==$lasti) {
+                        if (is_dir(&quot;$dn$fn&quot;)) {
+                           if ($flags &amp; GLOB_ONLYDIR) {
+                              continue;
+                           }
+                           if ($flags &amp; GLOB_MARK) {
+                              $fn .= &quot;/&quot;;
+                           }
+                        }
+#echo &quot;adding '$fn' for dn=$dn to list\n&quot;;
+                        $ls[] = &quot;$dn$fn&quot;;
+                     }
+
+                     #-- initiate a subsearch, merge result list in
+                     elseif (is_dir(&quot;$dn$fn&quot;)) {
+                        // add reamaining search patterns to current basedir
+                        $remaind = implode(&quot;/&quot;, array_slice($parts2, $i+1));
+                        $ls = array_merge($ls, glob(&quot;$dn$fn/$remaind&quot;, $flags));
+                     }
+                  }
+               }
+               closedir($dh);
+
+               #-- prevent scanning a 2nd part/dir in same glob() instance:
+               break;  
+            }
+
+            #-- given dirname doesn't exist
+            else {
+               return($ls);
+            }
+
+         }// foreach $parts
+      }
+
+      #-- return result list
+      if (!$ls &amp;&amp; ($flags &amp; GLOB_NOCHECK)) {
+         $ls[] = $pattern;
+      }
+      if ($flags ^ GLOB_NOSORT) {
+         sort($ls);
+      }
+#print_r($ls);
+#echo &quot;&lt;=\n&quot;;
+      return($ls);
+   }
+} //@FIX: fully comment, remove debugging code (- as soon as it works ;)
+
+
+#-- redundant alias for isset()
+if (!function_exists(&quot;array_key_exists&quot;)) {
+   function array_key_exists($key, $search) {
+      return isset($search[$key]);
+   }
+}
+
+
+#-- who could need that?
+if (!function_exists(&quot;array_intersect_assoc&quot;)) {
+   function array_intersect_assoc( /*array, array, array...*/ ) {
+
+      #-- parameters, prepare
+      $in = func_get_args();
+      $cmax = count($in);
+      $whatsleftover = array();
+      
+      #-- walk through each array pair
+      #   (take first as checklist)
+      foreach ($in[0] as $i =&gt; $v) {
+         for ($c = 1; $c &lt; $cmax; $c++) {
+            #-- remove entry, as soon as it isn't present
+            #   in one of the other arrays
+            if (!isset($in[$c][$i]) || (@$in[$c][$i] !== $v)) {
+               continue 2;
+            }
+         }
+         #-- it was found in all other arrays
+         $whatsleftover[$i] = $v;
+      }
+      return $whatsleftover;
+   }
+}
+
+
+#-- the opposite of the above
+if (!function_exists(&quot;array_diff_assoc&quot;)) {
+   function array_diff_assoc( /*array, array, array...*/ ) {
+
+      #-- params
+      $in = func_get_args();
+      $diff = array();
+      
+      #-- compare each array with primary/first
+      foreach ($in[0] as $i=&gt;$v) {
+         for ($c=1; $c&lt;count($in); $c++) {
+            #-- skip as soon as it matches with entry in another array
+            if (isset($in[$c][$i]) &amp;&amp; ($in[$c][$i] == $v)) {
+               continue 2;
+            }
+         }
+         #-- else
+         $diff[$i] = $v;
+      }
+      return $diff;
+   }
+}
+
+
+#-- opposite of htmlentities
+if (!function_exists(&quot;html_entity_decode&quot;)) {
+   function html_entity_decode($string, $quote_style=ENT_COMPAT, $charset=&quot;ISO-8859-1&quot;) {
+      //@FIX: we fall short on anything other than Latin-1
+      $y = array_flip(get_html_translation_table(HTML_ENTITIES, $quote_style));
+      return strtr($string, $y);
+   }
+}
+
+
+#-- extracts single words from a string
+if (!function_exists(&quot;str_word_count&quot;)) {
+   function str_word_count($string, $result=0) {
+   
+      #-- let someone else do the work
+      preg_match_all('/([\w](?:[-\'\w]?[\w]+)*)/', $string, $uu);
+
+      #-- return full word list
+      if ($result == 1) {
+         return($uu[1]);
+      }
+      
+      #-- array() of $pos=&gt;$word entries
+      elseif ($result &gt;= 2) {
+         $r = array();
+         $l = 0;
+         foreach ($uu[1] as $word) {
+            $l = strpos($string, $word, $l);
+            $r[$l] = $word;
+            $l += strlen($word);  // speed up next search
+         }
+         return($r);
+      }
+
+      #-- only count
+      else {
+         return(count($uu[1]));
+      }
+   }
+}
+
+
+#-- creates a permutation of the given strings characters
+#   (let's hope the random number generator was alread initialized)
+if (!function_exists(&quot;str_shuffle&quot;)) {
+   function str_shuffle($str) {
+      $r = &quot;&quot;;
+
+      #-- cut string down with every iteration
+      while (strlen($str)) {
+         $n = strlen($str) - 1;
+         if ($n) {
+            $n = rand(0, $n);   // glibcs` rand is ok since 2.1 at least
+         }
+         
+         #-- cut out elected char, add to result string
+         $r .= $str{$n};
+         $str = substr($str, 0, $n) . substr($str, $n + 1);
+      }
+      return($r);
+   }
+}
+
+
+#-- simple shorthands
+if (!function_exists(&quot;get_include_path&quot;)) {
+   function get_include_path() {
+      return(get_cfg_var(&quot;include_path&quot;));
+   }
+   function set_include_path($new) {
+      return ini_set(&quot;include_path&quot;, $new);
+   }
+   function restore_include_path() {
+      ini_restore(&quot;include_path&quot;);
+   }
+}
+
+
+#-- constants for 4.3
+if (!defined(&quot;PATH_SEPARATOR&quot;)) {
+   define(&quot;PATH_SEPARATOR&quot;, ((DIRECTORY_SEPARATOR=='\\') ? ';' :':'));
+   define(&quot;PHP_SHLIB_SUFFIX&quot;, ((DIRECTORY_SEPARATOR=='\\') ? 'dll' :'so'));
+}
+if (!defined(&quot;PHP_SAPI&quot;)) {
+   define(&quot;PHP_SAPI&quot;, php_sapi_name());
+}
+if (!defined(&quot;__FUNCTION__&quot;)) {
+   define(&quot;__FUNCTION__&quot;, NULL);   // empty string would signalize main()
+}
+
+
+#-- not identical to what PHP reports (it seems to `which` for itself)
+if (!defined(&quot;PHP_PREFIX&quot;) &amp;&amp; isset($_ENV[&quot;_&quot;])) { 
+   define(&quot;PHP_PREFIX&quot;, substr($_ENV[&quot;_&quot;], 0, strpos($_ENV[&quot;_&quot;], &quot;bin/&quot;)));
+}
+
+
+
+
+
+
+#------------------------------------------------------------------ 4.2 ---
+# almost complete!?
+
+
+#-- shy away from this one - it was broken in all real PHP4.2 versions, and
+#   this function emulation script won't change that
+if (!function_exists(&quot;str_rot13&quot;)) {
+   function str_rot13($str) {
+      static $from = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&quot;;
+      static $to = &quot;NOPQRSTUVWXYZABCDEFGHIJKLMnopqrstuvwxyzabcdefghijklm&quot;;
+      return strtr($str, $from, $to);
+   }
+}
+
+
+#-- well, if you need it
+if (!function_exists(&quot;array_change_key_case&quot;)) {
+   
+   #-- introduced constants
+   define(&quot;CASE_LOWER&quot;, 0);
+   define(&quot;CASE_UPPER&quot;, 1);
+   
+   #-- implementation
+   function array_change_key_case($array, $case=CASE_LOWER) {
+   
+      #-- loop through
+      foreach ($array as $i=&gt;$v) {
+         #-- do anything for strings only
+         if (is_string($i)) {
+            unset($array[$i]);
+            $i = ($case==CASE_LOWER) ? strtolower($i) : strtoupper($i);
+            $array[$i] = $v;
+         }
+         // non-recursive      
+      }
+      return($array);
+   }
+}
+
+
+#-- create fixed-length array made up of $value data
+if (!function_exists(&quot;array_fill&quot;)) {
+   function array_fill($start_index, $num, $value) {
+
+      #-- params
+      $r = array();
+      $i = $start_index;
+      $end = $num + $start_index;
+      
+      #-- append
+      for (; $i &lt; $end; $i++)
+      {
+         $r[$i] = $value;
+      }
+      return($r);
+   }
+}
+
+
+#-- split an array into evenly sized parts
+if (!function_exists(&quot;array_chunk&quot;)) {
+   function array_chunk($input, $size, $preserve_keys=false) {
+   
+      #-- array for chunked output
+      $r = array();
+      $n = -1;  // chunk index
+      
+      #-- enum input array blocks
+      foreach ($input as $i=&gt;$v) {
+      
+         #-- new chunk
+         if (($n &lt; 0) || (count($r[$n]) == $size)) {
+            $n++;
+            $r[$n] = array();
+         }
+         
+         #-- add input value into current [$n] chunk
+         if ($preserve_keys) {
+            $r[$n][$i] = $v;
+         }
+         else {
+            $r[$n][] = $v;
+         }
+      }
+      return($r);
+   }
+}
+
+
+#-- convenience wrapper
+if (!function_exists(&quot;md5_file&quot;)) {
+   function md5_file($filename, $raw_output=false) {
+
+      #-- read file, apply hash function
+      $data = file_get_contents($filename, &quot;rb&quot;);
+      $r = md5($data);
+      $data = NULL;
+         
+      #-- transform? and return
+      if ($raw_output) {
+         $r = pack(&quot;H*&quot;, $r);
+      }
+      return $r;
+   }
+}
+
+
+#-- object type checking
+if (!function_exists(&quot;is_a&quot;)) {
+   function is_a($obj, $classname) {
+   
+      #-- lowercase everything for comparison
+      $classnaqme = strtolower($classname);
+      $obj_class =  strtolower(get_class($obj));
+      
+      #-- two possible checks
+      return ($obj_class == $classname) or is_subclass_of($obj, $classname);
+   }
+}
+
+
+#-- floating point modulo
+if (!function_exists(&quot;fmod&quot;)) {
+   function fmod($x, $y) {
+      $r = $x / $y;
+      $r -= (int)$r;
+      $r *= $y;
+      return($r);
+   }
+}
+
+
+#-- makes float variable from string
+if (!function_exists(&quot;floatval&quot;)) {
+   function floatval($str) {
+      $str = ltrim($str);
+      return (float)$str;
+   }
+}
+
+
+#-- floats
+if (!function_exists(&quot;is_infinite&quot;)) {
+
+   #-- constants as-is
+   define(&quot;NAN&quot;, &quot;NAN&quot;);
+   define(&quot;INF&quot;, &quot;INF&quot;);   // there is also &quot;-INF&quot;
+   
+   #-- simple checks
+   function is_infinite($f) {
+      $s = (string)$f;
+      return(  ($s==&quot;INF&quot;) || ($s==&quot;-INF&quot;)  );
+   }
+   function is_nan($f) {
+      $s = (string)$f;
+      return(  $s==&quot;NAN&quot;  );
+   }
+   function is_finite($f) {
+      $s = (string)$f;
+      return(  !strpos($s, &quot;N&quot;)  );
+   }
+}
+
+
+#-- throws value-instantiation PHP-code for given variable
+#   (a bit different from the standard, was intentional for its orig use)
+if (!function_exists(&quot;var_export&quot;)) {
+   function var_export($var, $return=false, $indent=&quot;&quot;, $output=&quot;&quot;) {
+
+      #-- output as in-class variable definitions
+      if (is_object($var)) {
+         $output = &quot;class &quot; . get_class($var) . &quot; {\n&quot;;
+         foreach (((array)$var) as $id=&gt;$var) {
+            $output .= &quot;  var \$$id = &quot; . var_export($var, true) . &quot;;\n&quot;;
+         }
+         $output .= &quot;}&quot;;
+      }
+      
+      #-- array constructor
+      elseif (is_array($var)) {
+         foreach ($var as $id=&gt;$next) {
+            if ($output) $output .= &quot;,\n&quot;;
+                    else $output = &quot;array(\n&quot;;
+            $output .= $indent . '  '
+                    . (is_numeric($id) ? $id : '&quot;'.addslashes($id).'&quot;')
+                    . ' =&gt; ' . var_export($next, true, &quot;$indent  &quot;);
+         }
+         if (empty($output)) $output = &quot;array(&quot;;
+         $output .= &quot;\n{$indent})&quot;;
+       #if ($indent == &quot;&quot;) $output .= &quot;;&quot;;
+      }
+      
+      #-- literals
+      elseif (is_numeric($var)) {
+         $output = &quot;$var&quot;;
+      }
+      elseif (is_bool($var)) {
+         $output = $var ? &quot;true&quot; : &quot;false&quot;;
+      }
+      else {
+         $output = &quot;'&quot; . preg_replace(&quot;/([\\\\\'])/&quot;, '\\\\$1', $var) . &quot;'&quot;;
+      }
+
+      #-- done
+      if ($return) {
+         return($output);
+      }
+      else {
+         print($output);
+      }
+   }
+}
+
+
+#-- strcmp() variant that respects locale setting,
+#   existed since PHP 4.0.5, but under Win32 first since 4.3.2
+if (!function_exists(&quot;strcoll&quot;)) {
+   function strcoll($str1, $str2) {
+      return strcmp($str1, $str2);
+   }
+}
+
+
+
+
+
+#------------------------------------------------------------------ 4.1 ---
+# nl_langinfo - unimpl?
+# getmygid
+# version_compare
+#
+# See also &quot;ext/math41.php&quot; for some more (rarely used mathematical funcs).
+
+
+
+
+#-- aliases (an earlier fallen attempt to unify PHP function names)
+if (!function_exists(&quot;diskfreespace&quot;)) {
+   function diskfreespace() {
+      return disk_free_sapce();
+   }
+   function disktotalspace() {
+      return disk_total_sapce();
+   }
+}
+
+
+#-- variable count of arguments (in array list) printf variant
+if (!function_exists(&quot;vprintf&quot;)) {
+   function vprintf($format, $args=NULL) {
+      call_user_func_array(&quot;fprintf&quot;, get_func_args());
+   }
+}
+
+
+#-- same as above, but doesn't output directly and returns formatted string
+if (!function_exists(&quot;vsprintf&quot;)) {
+   function vsprintf($format, $args=NULL) {
+      $args = array_merge(array($format), array_values((array)$args));
+      return call_user_func_array(&quot;sprintf&quot;, $args);
+   }
+}
+
+
+#-- can be used to simulate a register_globals=on environment
+if (!function_exists(&quot;import_request_variables&quot;)) {
+   function import_request_variables($types=&quot;GPC&quot;, $pfix=&quot;&quot;) {
+      
+      #-- associate abbreviations to global var names
+      $alias = array(
+         &quot;G&quot; =&gt; &quot;_GET&quot;,
+         &quot;P&quot; =&gt; &quot;_POST&quot;,
+         &quot;C&quot; =&gt; &quot;_COOKIE&quot;,
+         &quot;S&quot; =&gt; &quot;_SERVER&quot;,   // non-standard
+         &quot;E&quot; =&gt; &quot;_ENV&quot;,      // non-standard
+      );
+      #-- alias long names (PHP &lt; 4.0.6)
+      if (!isset($_REQUEST)) {
+         $_GET = &amp; $HTTP_GET_VARS;
+         $_POST = &amp; $HTTP_POST_VARS;
+         $_COOKIE = &amp; $HTTP_COOKIE_VARS;
+      }
+      
+      #-- copy
+      for ($i=0; $i&lt;strlen($types); $i++) {
+         if ($FROM = $alias[strtoupper($c)]) {
+            foreach ($$FROM as $key=&gt;$val) {
+               if (!isset($GLOBALS[$pfix.$key])) {
+                  $GLOBALS[$pfix . $key] = $val;
+               }
+            }
+         }
+      }
+      // done
+   }
+}
+
+
+// a few mathematical functions follow
+// (wether we should really emulate them is a different question)
+
+#-- me has no idea what this function means
+if (!function_exists(&quot;hypot&quot;)) {
+   function hypot($num1, $num2) {
+      return sqrt($num1*$num1 + $num2*$num2);  // as per PHP manual ;)
+   }
+}
+
+#-- more accurate logarithm func, but we cannot simulate it
+#   (too much work, too slow in PHP)
+if (!function_exists(&quot;log1p&quot;)) {
+   function log1p($x) {
+      return(  log(1+$x)  );
+   }
+   #-- same story for:
+   function expm1($x) {
+      return(  exp($x)-1  );
+   }
+}
+
+#-- as per PHP manual
+if (!function_exists(&quot;sinh&quot;)) {
+   function sinh($f) {
+      return(  (exp($f) - exp(-$f)) / 2  );
+   }
+   function cosh($f) {
+      return(  (exp($f) + exp(-$f)) / 2  );
+   }
+   function tanh($f) {
+      return(  sinh($f) / cosh($f)  );   // ok, that one makes sense again :)
+   }
+}
+
+#-- these look a bit more complicated
+if (!function_exists(&quot;asinh&quot;)) {
+   function asinh($x) {
+      return(  log($x + sqrt($x*$x+1))  );
+   }
+   function acosh($x) {
+      return(  log($x + sqrt($x*$x-1))  );
+   }
+   function atanh($x) {
+      return(  log1p( 2*$x / (1-$x) ) / 2  );
+   }
+}
+
+
+#-- HMAC from RFC2104, but see also PHP_Compat and Crypt_HMAC
+if (!function_exists(&quot;mhash&quot;)) {
+
+   #-- constants
+   define(&quot;MHASH_CRC32&quot;, 0);
+   define(&quot;MHASH_MD5&quot;, 1);       // RFC1321
+   define(&quot;MHASH_SHA1&quot;, 2);      // RFC3174
+   define(&quot;MHASH_TIGER&quot;, 7);
+   define(&quot;MHASH_MD4&quot;, 16);      // RFC1320
+   define(&quot;MHASH_SHA256&quot;, 17);
+   define(&quot;MHASH_ADLER32&quot;, 18);
+   
+   #-- implementation
+   function mhash($hashtype, $text, $key) {
+   
+      #-- hash function
+      if (!($func = mhash_get_hash_name($hashtype)) || !function_exists($func)) {
+         return trigger_error(&quot;mhash: cannot use hash algorithm #$hashtype/$func&quot;, E_USER_ERROR);
+      }
+      if (!$key) {
+         trigger_error(&quot;mhash: called without key&quot;, E_USER_WARNING);
+      }
+      
+      #-- params
+      $bsize = mhash_get_block_size($hashtype);   // fixed size, 64
+
+      #-- pad key
+      if (strlen($key) &gt; $bsize) {  // hash key, when it's too long
+         $key = $func($key); 
+         $key = pack(&quot;H*&quot;, $key);   // binarify
+      }
+      $key = str_pad($key, $bsize, &quot;\0&quot;);  // fill up with NULs (1)
+      
+      #-- prepare inner and outer padding stream
+      $ipad = str_pad(&quot;&quot;, $bsize, &quot;6&quot;);   // %36
+      $opad = str_pad(&quot;&quot;, $bsize, &quot;\\&quot;);  // %5C
+      
+      #-- call hash func    // php can XOR strings for us
+      $dgst = pack(&quot;H*&quot;,  $func(  ($key ^ $ipad)  .  $text  ));  // (2,3,4)
+      $dgst = pack(&quot;H*&quot;,  $func(  ($key ^ $opad)  .  $dgst  ));  // (5,6,7)
+      return($dgst);
+   }
+   
+   #-- return which hash functions are implemented
+   function mhash_count() {
+      return(MHASH_SHA1);
+   }
+   
+   #-- map numeric identifier to hash function name
+   function mhash_get_hash_name($i) {
+      static $hash_funcs = array(
+          MHASH_CRC32 =&gt; &quot;crc32&quot;,   // would need dechex()ing in main func?
+          MHASH_MD5 =&gt; &quot;md5&quot;,
+          MHASH_SHA1 =&gt; &quot;sha1&quot;,
+      );
+      return(strtoupper($hash_funcs[$i]));
+   }
+   
+   #-- static value
+   function mhash_get_block_size($i) {
+      return(64);
+   }
+}
+
+
+
+#-- other stuff
+/*
+  removed funcs??
+      [18] =&gt; leak
+*/
+
+
+
+#-- pre-4.1 -- end
+// no need to implement anything below that, because such old versions
+// will be incompatbile anyhow (- none of the newer superglobals known),
+// but see also &quot;ext/old&quot;
+
+
+?&gt;

Modified: YDFramework2.0/trunk/YDFramework2/YDF2_init.php
===================================================================
--- YDFramework2.0/trunk/YDFramework2/YDF2_init.php	2006-12-09 18:08:01 UTC (rev 2249)
+++ YDFramework2.0/trunk/YDFramework2/YDF2_init.php	2006-12-09 18:13:10 UTC (rev 2250)
@@ -222,6 +222,13 @@
     }
 
     /**
+     *	This function will include a upgrade file that simulates php functions not present in this php system
+     */
+    function YDIncludeCompatibility() {
+        include_once( dirname( __FILE__ ) . '/3rdparty/upgrade/upgrade.php' );
+    }
+
+    /**
      *	This function will add a marker to the global timer.
      *
      *	@param $name	The name of the marker.


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000840.html">[ydf-devel] r2249 -	YDFramework2.0/trunk/YDFramework2/YDClasses/YDFormElements
</A></li>
	<LI>Next message: <A HREF="000842.html">[ydf-devel] r2251 - in YDFramework2.0/trunk/YDFramework2: 3rdparty	3rdparty/captcha 3rdparty/fonts YDClasses	YDClasses/YDFormElements addons addons/YDCaptcha
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#841">[ date ]</a>
              <a href="thread.html#841">[ thread ]</a>
              <a href="subject.html#841">[ subject ]</a>
              <a href="author.html#841">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/ydframework-devel">More information about the YDFramework-devel
mailing list</a><br>
</body></html>
